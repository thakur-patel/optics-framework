{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Optics Framework","text":"<p>Welcome to the official documentation for the Optics Framework, an open-source test automation framework designed to simplify and streamline the creation and execution of automated tests across various platforms. Whether you're testing mobile apps (including DRM-enabled ones), Optics Framework provides a flexible, extensible, and user-friendly solution to meet your testing needs.</p> <p> </p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li> <p> Vision Powered</p> <p>UI object detections powered by computer vision, not just XPath elements</p> </li> <li> <p> No Code Automation</p> <p>Build automation scripts without programming knowledge or IDE access</p> </li> <li> <p> Non-Intrusive Drivers</p> <p>Support for BLE mouse and keyboard for production monitoring</p> </li> <li> <p> Data-Driven Testing</p> <p>Execute test cases dynamically with multiple datasets</p> </li> <li> <p> Extensible &amp; Scalable</p> <p>Easily add new keywords and modules without hassle</p> </li> <li> <p> AI Integration</p> <p>Choose which AI models to use for object recognition and OCR</p> </li> <li> <p> Self-Healing</p> <p>Automatic fallback to alternative detection methods when primary fails</p> </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get started with Optics Framework in minutes:</p> <pre><code>pip install optics-framework\noptics setup --install Appium EasyOCR\noptics init --name my_test_project --path . --template contact\noptics execute my_test_project\n</code></pre> <p> Read the Quick Start Guide \u2192</p>"},{"location":"#explore-documentation","title":"Explore Documentation","text":"<ul> <li> <p> Introduction</p> <p>Learn about the framework's architecture and capabilities</p> <p> Introduction \u2192</p> </li> <li> <p> Quick Start</p> <p>Get up and running with your first test in minutes</p> <p> Quick Start \u2192</p> </li> <li> <p> Architecture</p> <p>Deep dive into the framework's architecture, components, and design patterns</p> <p> Architecture \u2192</p> </li> <li> <p> User Workflow</p> <p>Understand the typical workflow for creating and running tests</p> <p> User Workflow \u2192</p> </li> <li> <p> Usage</p> <p>Comprehensive guides for CLI and keyword usage</p> <p> Usage \u2192</p> </li> <li> <p> API Reference</p> <p>Python API documentation and REST API usage guides</p> <p> API Reference \u2192</p> </li> <li> <p> Developer Guide</p> <p>Learn how to extend and contribute to the framework</p> <p> Developer Guide \u2192</p> </li> <li> <p> Contributing</p> <p>Guidelines for contributing to the project</p> <p> Contributing \u2192</p> </li> <li> <p> Help Wanted</p> <p>Areas where we need your help to improve the framework</p> <p> Help Wanted \u2192</p> </li> <li> <p> Code of Conduct</p> <p>Our community standards and expectations</p> <p> Code of Conduct \u2192</p> </li> </ul>"},{"location":"#need-help","title":"Need Help?","text":"<ul> <li> GitHub Issues - Report bugs or request features</li> <li> Documentation - Browse the full documentation</li> <li> Contact - Reach out for support</li> </ul>"},{"location":"api_reference/","title":"API Reference","text":"<p>This section provides comprehensive Python API documentation for the Optics Framework, automatically generated from code docstrings.</p> <p>The API is organized into the following components:</p> <ul> <li> <p>Optics Class The main entry point for the Optics Framework. Provides a unified interface for both programmatic use and Robot Framework integration.</p> </li> <li> <p>Action Keywords Methods for interacting with elements, including pressing, swiping, typing, and other user actions.</p> </li> <li> <p>App Management Functionality for launching, terminating, and managing application sessions.</p> </li> <li> <p>Verification Methods to verify elements, screens, and data integrity during test execution.</p> </li> <li> <p>Flow Control Control flow operations including loops, conditions, and data management for test sessions.</p> </li> </ul>"},{"location":"api_reference/#related-documentation","title":"Related Documentation","text":"<ul> <li>REST API Usage - REST API endpoint reference</li> <li>Library Usage - Python library usage guide</li> <li>Architecture - Framework architecture overview</li> </ul>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>The Optics Framework is built on a modular, extensible architecture that enables vision-powered, self-healing test automation. This document provides a high-level overview of the framework's design, core principles, and component relationships.</p>"},{"location":"architecture/#design-principles","title":"Design Principles","text":"<p>The framework follows several key design principles:</p> <ol> <li>Modularity: Components are organized into clear, independent modules with well-defined interfaces</li> <li>Extensibility: New drivers, element sources, and vision models can be added without modifying core code</li> <li>Resilience: Built-in fallback mechanisms ensure tests continue even when primary methods fail</li> <li>Separation of Concerns: Clear boundaries between action execution, element detection, and vision processing</li> <li>Interface-Based Design: Components communicate through well-defined interfaces, enabling easy substitution</li> </ol>"},{"location":"architecture/#level-1-system-context","title":"Level 1 \u2013 System Context","text":"<p>At the system level, the Optics Framework sits between test authors and external automation infrastructure. It exposes multiple entry points (CLI, REST API, Python library) while orchestrating drivers, vision models, and device farms underneath.</p> <pre><code>graph TB\n    actorTester[\"Tester or QA Engineer\"]\n    actorIntegrator[\"Framework Integrator or Tooling Engineer\"]\n    actorCi[\"CI or Orchestration System\"]\n\n    systemOptics[\"Optics Framework\"]\n\n    extAutomation[\"Automation Backends (Appium, Selenium, Playwright, BLE)\"]\n    extDevices[\"Real Devices or Device Farms\"]\n    extVision[\"Vision and OCR Services\"]\n\n    actorTester --&gt; systemOptics\n    actorIntegrator --&gt; systemOptics\n    actorCi --&gt; systemOptics\n\n    systemOptics --&gt; extAutomation\n    systemOptics --&gt; extDevices\n    systemOptics --&gt; extVision</code></pre>"},{"location":"architecture/#level-2-containers-and-layers","title":"Level 2 \u2013 Containers and Layers","text":"<p>The rest of this document describes the Optics Framework's internal containers and layers (C4 Level 2), and how they collaborate at runtime.</p> <p>The framework is organized into several key layers:</p> <pre><code>graph TB\n    subgraph \"User Interface Layer\"\n        CLI[CLI Commands]\n        API[REST API]\n        Library[Python Library]\n    end\n\n    subgraph \"Core Layer\"\n        Optics[Optics Class]\n        SessionMgr[SessionManager]\n        Config[ConfigHandler]\n    end\n\n    subgraph \"Builder Layer\"\n        Builder[OpticsBuilder]\n        Factories[Factories]\n    end\n\n    subgraph \"API Layer\"\n        ActionKW[ActionKeyword]\n        AppMgmt[AppManagement]\n        Verifier[Verifier]\n        FlowCtrl[FlowControl]\n    end\n\n    subgraph \"Strategy Layer\"\n        StrategyMgr[StrategyManager]\n        Strategies[Location Strategies]\n    end\n\n    subgraph \"Engine Layer\"\n        Drivers[Drivers]\n        ElementSources[Element Sources]\n        VisionModels[Vision Models]\n    end\n\n    subgraph \"Execution Layer\"\n        ExecEngine[ExecutionEngine]\n        TestRunner[TestRunner]\n        EventSys[Event System]\n    end\n\n    CLI --&gt; Optics\n    API --&gt; Optics\n    Library --&gt; Optics\n    Optics --&gt; SessionMgr\n    SessionMgr --&gt; Builder\n    Builder --&gt; Factories\n    Factories --&gt; Drivers\n    Factories --&gt; ElementSources\n    Factories --&gt; VisionModels\n    Builder --&gt; ActionKW\n    Builder --&gt; AppMgmt\n    Builder --&gt; Verifier\n    Builder --&gt; FlowCtrl\n    ActionKW --&gt; StrategyMgr\n    StrategyMgr --&gt; Strategies\n    Strategies --&gt; ElementSources\n    Strategies --&gt; VisionModels\n    ExecEngine --&gt; TestRunner\n    TestRunner --&gt; ActionKW\n    TestRunner --&gt; AppMgmt\n    TestRunner --&gt; Verifier\n    TestRunner --&gt; FlowCtrl\n    ExecEngine --&gt; EventSys</code></pre> <p>The layers have the following responsibilities and primary references:</p> <ul> <li>User Interface Layer:</li> <li>Entry points for humans and tooling via CLI commands, the REST API, and the Python library.</li> <li>Translates user intent into high-level operations without dealing directly with drivers or vision models.</li> <li> <p>See CLI Layer and REST API Layer.</p> </li> <li> <p>Core Layer:</p> </li> <li>Hosts the <code>Optics</code> facade, <code>SessionManager</code>, and <code>ConfigHandler</code>.</li> <li>Owns configuration and session lifecycle, bridging interface-layer calls into the builder and execution pipeline.</li> <li> <p>See Component Architecture for core component details.</p> </li> <li> <p>Builder Layer:</p> </li> <li>Uses <code>OpticsBuilder</code> and factories to turn configuration into concrete driver, element source, and vision model instances.</li> <li>Central place for dependency wiring and fallback chains between engines.</li> <li> <p>See Component Architecture and Engines.</p> </li> <li> <p>API Layer:</p> </li> <li>Provides high-level, user-facing keywords for actions, app management, verification, and flow control.</li> <li>Encapsulates orchestration logic while delegating low-level work to strategies and engines.</li> <li> <p>See Component Architecture and Strategies.</p> </li> <li> <p>Strategy Layer:</p> </li> <li>Implements self-healing location strategies that combine DOM, text, and image-based techniques.</li> <li>Decides which element or vision strategy to apply and in what order.</li> <li> <p>See Strategies for details.</p> </li> <li> <p>Engine Layer:</p> </li> <li>Contains concrete automation backends (drivers), element sources, and vision models.</li> <li>Talks to external systems such as Appium/Selenium/Playwright, device farms, and OCR/image services.</li> <li> <p>See Engines for driver, element source, and vision model implementations.</p> </li> <li> <p>Execution Layer:</p> </li> <li>Coordinates test execution, result collection, and event publishing.</li> <li>Provides runners and event infrastructure that drive API-layer keywords over time.</li> <li>See Execution and Event System.</li> </ul> <p>For a deeper, component-level (C4 Level 3) view and the concrete design patterns used in Optics, see: - Component Architecture: Component Architecture for Optics, SessionManager, builders, factories, and interfaces. - Strategies and Engines: Strategies and Engines for self-healing strategies and engine implementations. - Architecture Decisions: Architecture Decisions for the rationale behind major architectural choices.</p>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#session-creation-flow","title":"Session Creation Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Optics\n    participant SessionMgr\n    participant Session\n    participant Builder\n    participant Factory\n\n    User-&gt;&gt;Optics: setup(config)\n    Optics-&gt;&gt;SessionMgr: create_session()\n    SessionMgr-&gt;&gt;Session: new Session()\n    Session-&gt;&gt;Builder: new OpticsBuilder()\n    Builder-&gt;&gt;Factory: get_driver(config)\n    Factory-&gt;&gt;Factory: discover &amp; instantiate\n    Factory--&gt;&gt;Builder: driver instance\n    Builder--&gt;&gt;Session: configured builder\n    Session--&gt;&gt;SessionMgr: session created\n    SessionMgr--&gt;&gt;Optics: session_id</code></pre>"},{"location":"architecture/#element-location-flow","title":"Element Location Flow","text":"<pre><code>sequenceDiagram\n    participant ActionKW\n    participant StrategyMgr\n    participant Strategy\n    participant ElementSource\n    participant VisionModel\n\n    ActionKW-&gt;&gt;StrategyMgr: locate(element)\n    StrategyMgr-&gt;&gt;Strategy: try XPathStrategy\n    Strategy-&gt;&gt;ElementSource: locate(element)\n    ElementSource--&gt;&gt;Strategy: result or None\n    alt XPath fails\n        StrategyMgr-&gt;&gt;Strategy: try TextDetectionStrategy\n        Strategy-&gt;&gt;ElementSource: capture()\n        ElementSource--&gt;&gt;Strategy: screenshot\n        Strategy-&gt;&gt;VisionModel: detect_text(screenshot)\n        VisionModel--&gt;&gt;Strategy: text locations\n    end\n    Strategy--&gt;&gt;StrategyMgr: coordinates\n    StrategyMgr--&gt;&gt;ActionKW: element location</code></pre>"},{"location":"architecture/#cross-cutting-concerns","title":"Cross-Cutting Concerns","text":"<p>These concerns cut across multiple layers and containers, and collectively shape the framework's runtime behavior and quality attributes.</p>"},{"location":"architecture/#self-healing-mechanism","title":"Self-Healing Mechanism","text":"<p>The framework implements self-healing through multiple layers:</p> <ol> <li>Strategy Fallback: If one location strategy fails, try the next</li> <li>Driver Fallback: If one driver fails, try the next configured driver</li> <li>Element Source Fallback: If one element source fails, try the next</li> <li>Vision Model Fallback: If one OCR/image model fails, try the next</li> </ol> <p>This multi-layered approach ensures maximum test resilience.</p>"},{"location":"architecture/#configuration-structure","title":"Configuration Structure","text":"<p>Configuration is hierarchical and supports: - Multiple drivers with priority ordering - Multiple element sources with fallback chains - Multiple vision models for redundancy - Per-component configuration options</p>"},{"location":"architecture/#extension-points","title":"Extension Points","text":"<p>The framework is designed for easy extension:</p> <ol> <li>New Drivers: Implement <code>DriverInterface</code> in <code>engines/drivers/</code></li> <li>New Element Sources: Implement <code>ElementSourceInterface</code> in <code>engines/elementsources/</code></li> <li>New Vision Models: Implement <code>ImageInterface</code> or <code>TextInterface</code> in <code>engines/vision_models/</code></li> <li>New Strategies: Extend <code>LocatorStrategy</code> in <code>common/strategies.py</code></li> <li>New Keywords: Add methods to API classes with <code>@keyword</code> decorator</li> </ol>"},{"location":"architecture/#next-steps","title":"Next Steps","text":"<p>From here you can move from the C4 Level 1 and Level 2 views in this document into more detailed Level 3 component and system documentation.</p>"},{"location":"architecture/#containers-and-layers-level-2-level-3","title":"Containers and Layers (Level 2 \u2192 Level 3)","text":"<ul> <li>Component Architecture - Deep dive into individual components</li> <li>Engines - Driver, element source, and vision model implementations</li> <li>Strategies - Strategy pattern and self-healing mechanisms</li> <li>Execution - Test execution flow and event system</li> <li>Event System - EventSDK and event tracking</li> <li>Error Handling - Error codes and error handling system</li> </ul>"},{"location":"architecture/#interface-entry-points","title":"Interface Entry Points","text":"<ul> <li>REST API Layer - REST API architecture and integration</li> <li>CLI Layer - Command-line interface architecture</li> <li>Library Layer - Python library and programmatic interface</li> </ul>"},{"location":"architecture/#cross-cutting-systems-and-decisions","title":"Cross-Cutting Systems and Decisions","text":"<ul> <li>Logging Architecture - Logging system and configuration</li> <li>Architecture Decisions - ADRs and design rationale</li> </ul>"},{"location":"architecture/#extension-and-customization","title":"Extension and Customization","text":"<ul> <li>Extending the Framework - Creating custom extensions</li> </ul>"},{"location":"architecture/#related-documentation","title":"Related Documentation","text":"<ul> <li>REST API Usage - Complete REST API endpoint reference</li> <li>API Reference - Python API documentation</li> <li>Configuration - Configuration guide</li> <li>Quick Start - Getting started guide</li> <li>Usage Guide - Usage examples and patterns</li> </ul>"},{"location":"configuration/","title":"Configuration Reference","text":"<p>This document provides comprehensive documentation for all configuration options available in the Optics Framework. The configuration system is managed by the <code>ConfigHandler</code> class and uses YAML files for configuration.</p>"},{"location":"configuration/#overview","title":"Overview","text":"<p>The Optics Framework uses a hierarchical configuration system that merges configurations in the following order (with later configurations taking priority):</p> <ol> <li>Default Configuration - Built-in defaults</li> <li>Global Configuration - <code>~/.optics/global_config.yaml</code> (user-wide settings)</li> <li>Project Configuration - <code>config.yaml</code> in your project directory (project-specific settings)</li> </ol> <p>Configuration Priority</p> <p>Project configuration overrides global configuration, which overrides default configuration. This allows you to set common settings globally and override them per-project.</p>"},{"location":"configuration/#quick-reference","title":"Quick Reference","text":"Category Key Settings Common Values Logging <code>console</code>, <code>file_log</code>, <code>json_log</code>, <code>log_level</code> <code>log_level: INFO</code> or <code>DEBUG</code> Paths <code>project_path</code>, <code>execution_output_path</code> <code>./my_project</code>, <code>./outputs</code> Execution <code>halt_duration</code>, <code>max_attempts</code> <code>0.1</code>, <code>3</code> Drivers <code>appium</code>, <code>selenium</code>, <code>playwright</code>, <code>ble</code> See Driver Sources tab Element Sources <code>appium_find_element</code>, <code>playwright_screenshot</code>, etc. See Element Sources tab Text Detection <code>easyocr</code>, <code>pytesseract</code>, <code>google_vision</code> See Text Detection tab Image Detection <code>templatematch</code>, <code>remote_oir</code> See Image Detection tab"},{"location":"configuration/#configuration-structure","title":"Configuration Structure","text":"<p>All configurations are defined in YAML format. The main configuration file (<code>config.yaml</code>) supports the following top-level sections:</p> <ul> <li>Core settings - Logging, paths, execution parameters</li> <li>Driver sources - Automation frameworks (Appium, Selenium, Playwright, BLE)</li> <li>Element sources - Element detection methods</li> <li>Text detection engines - OCR capabilities</li> <li>Image detection engines - Template matching</li> </ul>"},{"location":"configuration/#core-settings","title":"Core Settings","text":"Logging ConfigurationPaths &amp; ExecutionTest Control"},{"location":"configuration/#console","title":"<code>console</code>","text":"<p>Type: <code>bool</code> | Default: <code>true</code></p> <p>Enable or disable console log output.</p> <pre><code>console: true\n</code></pre>"},{"location":"configuration/#file_log","title":"<code>file_log</code>","text":"<p>Type: <code>bool</code> | Default: <code>false</code></p> <p>Enable writing logs to a file. When enabled, logs are written to the path specified by <code>log_path</code> or a default location.</p> <pre><code>file_log: true\nlog_path: \"./logs/test_execution.log\"  # Optional, defaults to execution_output_path/logs.log\n</code></pre>"},{"location":"configuration/#json_log","title":"<code>json_log</code>","text":"<p>Type: <code>bool</code> | Default: <code>false</code></p> <p>Enable JSON format logging. When enabled, logs are written in JSON format to the path specified by <code>json_path</code>.</p> <pre><code>json_log: true\njson_path: \"./logs/test_logs.json\"  # Optional, defaults to execution_output_path/logs.json\n</code></pre>"},{"location":"configuration/#log_level","title":"<code>log_level</code>","text":"<p>Type: <code>str</code> | Default: <code>\"INFO\"</code></p> <p>Sets the verbosity of log messages. Valid values (in order of verbosity):</p> <ul> <li><code>DEBUG</code> - Detailed information for troubleshooting</li> <li><code>INFO</code> - General informational messages (default)</li> <li><code>WARNING</code> - Warning messages only</li> <li><code>ERROR</code> - Error messages only</li> <li><code>CRITICAL</code> - Critical failures only</li> </ul> <pre><code>log_level: DEBUG\n</code></pre>"},{"location":"configuration/#log_path","title":"<code>log_path</code>","text":"<p>Type: <code>Optional[str]</code> | Default: <code>null</code></p> <p>Path for log file. If not specified and <code>file_log</code> is enabled, defaults to <code>{execution_output_path}/logs.log</code>.</p> <pre><code>file_log: true\nlog_path: \"./logs/custom_execution.log\"\n</code></pre>"},{"location":"configuration/#json_path","title":"<code>json_path</code>","text":"<p>Type: <code>Optional[str]</code> | Default: <code>null</code></p> <p>Path for JSON log file. If not specified and <code>json_log</code> is enabled, defaults to <code>{execution_output_path}/logs.json</code>.</p> <pre><code>json_log: true\njson_path: \"./logs/custom_logs.json\"\n</code></pre>"},{"location":"configuration/#project_path","title":"<code>project_path</code>","text":"<p>Type: <code>Optional[str]</code> | Default: <code>null</code></p> <p>Root directory for test project files. This path should contain your CSV files (<code>test_cases.csv</code>, <code>test_modules.csv</code>, <code>elements.csv</code>) and <code>input_templates/</code> directory.</p> <pre><code>project_path: \"./my_test_project\"\n</code></pre>"},{"location":"configuration/#execution_output_path","title":"<code>execution_output_path</code>","text":"<p>Type: <code>Optional[str]</code> | Default: <code>null</code> (auto-generated if <code>project_path</code> is set)</p> <p>Directory where execution outputs (logs, screenshots, etc.) are stored. If not specified and <code>project_path</code> is set, defaults to <code>{project_path}/execution_output</code>.</p> <pre><code>execution_output_path: \"./outputs\"\n</code></pre>"},{"location":"configuration/#halt_duration","title":"<code>halt_duration</code>","text":"<p>Type: <code>float</code> | Default: <code>0.1</code></p> <p>Pause duration (in seconds) between actions. This helps ensure UI stability and prevents race conditions.</p> <pre><code>halt_duration: 0.1  # 100ms pause between actions\n</code></pre>"},{"location":"configuration/#max_attempts","title":"<code>max_attempts</code>","text":"<p>Type: <code>int</code> | Default: <code>3</code></p> <p>Maximum number of retry attempts for failing actions. The framework will retry up to this many times before reporting failure.</p> <pre><code>max_attempts: 3\n</code></pre>"},{"location":"configuration/#include","title":"<code>include</code>","text":"<p>Type: <code>Optional[List[str]]</code> | Default: <code>null</code></p> <p>List of test case names to include in execution. Only the specified test cases will be executed; all others will be skipped.</p> <pre><code>include:\n  - \"Test Login Flow\"\n  - \"Test Checkout Process\"\n</code></pre>"},{"location":"configuration/#exclude","title":"<code>exclude</code>","text":"<p>Type: <code>Optional[List[str]]</code> | Default: <code>null</code></p> <p>List of test case names to exclude from execution. All other test cases will be executed.</p> <pre><code>exclude:\n  - \"Test Legacy Feature\"\n  - \"Test Deprecated Flow\"\n</code></pre>"},{"location":"configuration/#event_attributes_json","title":"<code>event_attributes_json</code>","text":"<p>Type: <code>Optional[str]</code> | Default: <code>null</code></p> <p>Path to a JSON file containing event attributes for the Event SDK. This file defines custom attributes to be included in event tracking.</p> <pre><code>event_attributes_json: \"./config/event_attributes.json\"\n</code></pre>"},{"location":"configuration/#driver-sources","title":"Driver Sources","text":"<p>Driver sources define the automation frameworks used to control devices or browsers.</p> AppiumSeleniumPlaywrightBLE <p>Purpose: Mobile app automation for Android and iOS devices.</p> <p>Configuration:</p> <pre><code>driver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723/wd/hub\"\n      capabilities:\n        automationName: \"UiAutomator2\"  # or \"XCUITest\" for iOS\n        deviceName: \"emulator-5554\"\n        platformName: \"Android\"  # or \"iOS\"\n        platformVersion: \"13.0\"\n        appPackage: \"com.example.app\"\n        appActivity: \"com.example.app.MainActivity\"\n        udid: \"device_unique_id\"  # Optional, for specific device\n</code></pre> <p>Common Capabilities:</p> Capability Android iOS Description <code>automationName</code> <code>\"UiAutomator2\"</code> <code>\"XCUITest\"</code> Automation framework <code>platformName</code> <code>\"Android\"</code> <code>\"iOS\"</code> Platform identifier <code>platformVersion</code> <code>\"13.0\"</code> <code>\"16.0\"</code> OS version <code>deviceName</code> Device identifier Device identifier Device name <code>appPackage</code> Package name - Android app package <code>appActivity</code> Activity name - Android activity <code>udid</code> Device UDID Device UDID Unique device ID <p>Purpose: Web browser automation.</p> <p>Configuration:</p> <pre><code>driver_sources:\n  - selenium:\n      enabled: true\n      url: \"http://localhost:4444/wd/hub\"  # Selenium Grid or standalone\n      capabilities:\n        browserName: \"chrome\"  # or \"firefox\", \"safari\", \"edge\"\n        browserVersion: \"latest\"\n        platformName: \"Windows\"\n</code></pre> <p>Common Capabilities:</p> Capability Values Description <code>browserName</code> <code>\"chrome\"</code>, <code>\"firefox\"</code>, <code>\"safari\"</code>, <code>\"edge\"</code> Browser type <code>browserVersion</code> Version string Browser version <code>platformName</code> <code>\"Windows\"</code>, <code>\"Linux\"</code>, <code>\"macOS\"</code> Operating system <p>Purpose: Modern web automation with better reliability and performance.</p> <p>Configuration:</p> <pre><code>driver_sources:\n  - playwright:\n      enabled: true\n      url: null  # Playwright runs locally\n      capabilities:\n        browser: \"chromium\"  # or \"firefox\", \"webkit\"\n        headless: false\n        viewport:\n          width: 1920\n          height: 1080\n</code></pre> <p>Common Capabilities:</p> Capability Values Description <code>browser</code> <code>\"chromium\"</code>, <code>\"firefox\"</code>, <code>\"webkit\"</code> Browser engine <code>headless</code> <code>true</code>, <code>false</code> Run browser in headless mode <code>viewport</code> <code>{width, height}</code> Browser viewport dimensions <p>Purpose: Bluetooth Low Energy (BLE) device automation for non-intrusive mouse/keyboard control.</p> <p>Configuration:</p> <pre><code>driver_sources:\n  - ble:\n      enabled: true\n      url: null\n      capabilities:\n        device_id: \"Samsung A50\"\n        port: \"/dev/ttyACM0\"\n        x_invert: 1\n        y_invert: 1\n        pixel_width: 1080\n        pixel_height: 2336\n        mickeys_height: 2336\n        mickeys_width: 1080\n</code></pre> <p>Common Capabilities:</p> Capability Description <code>device_id</code> Device identifier <code>port</code> Serial port for BLE communication <code>x_invert</code>, <code>y_invert</code> Coordinate inversion flags <code>pixel_width</code>, <code>pixel_height</code> Screen pixel dimensions <code>mickeys_width</code>, <code>mickeys_height</code> Mouse coordinate dimensions"},{"location":"configuration/#element-sources","title":"Element Sources","text":"<p>Element sources define methods for locating and capturing UI elements.</p> Appium SourcesSelenium SourcesPlaywright SourcesCamera Source"},{"location":"configuration/#appium_find_element","title":"<code>appium_find_element</code>","text":"<p>Purpose: Locates elements using Appium's native element finding strategies (XPath, ID, etc.).</p> <pre><code>elements_sources:\n  - appium_find_element:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#appium_page_source","title":"<code>appium_page_source</code>","text":"<p>Purpose: Retrieves the entire XML page source from Appium for element location.</p> <pre><code>elements_sources:\n  - appium_page_source:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#appium_screenshot","title":"<code>appium_screenshot</code>","text":"<p>Purpose: Captures screenshots through Appium for visual element detection.</p> <pre><code>elements_sources:\n  - appium_screenshot:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#selenium_find_element","title":"<code>selenium_find_element</code>","text":"<p>Purpose: Locates elements using Selenium's element finding strategies (CSS selectors, XPath, etc.).</p> <pre><code>elements_sources:\n  - selenium_find_element:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#selenium_screenshot","title":"<code>selenium_screenshot</code>","text":"<p>Purpose: Captures screenshots from Selenium browser sessions.</p> <pre><code>elements_sources:\n  - selenium_screenshot:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#playwright_find_element","title":"<code>playwright_find_element</code>","text":"<p>Purpose: Locates elements using Playwright's modern locator API (CSS, text, XPath).</p> <pre><code>elements_sources:\n  - playwright_find_element:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#playwright_page_source","title":"<code>playwright_page_source</code>","text":"<p>Purpose: Retrieves DOM HTML from Playwright for element location.</p> <pre><code>elements_sources:\n  - playwright_page_source:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#playwright_screenshot","title":"<code>playwright_screenshot</code>","text":"<p>Purpose: Captures high-quality screenshots from Playwright sessions.</p> <pre><code>elements_sources:\n  - playwright_screenshot:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#camera_screenshot","title":"<code>camera_screenshot</code>","text":"<p>Purpose: Captures screenshots from external cameras or capture cards (useful for production monitoring).</p> <pre><code>elements_sources:\n  - camera_screenshot:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#text-detection","title":"Text Detection","text":"<p>Text detection engines provide OCR (Optical Character Recognition) capabilities for locating text on screen.</p> EasyOCRPytesseractGoogle VisionRemote OCR <p>Purpose: EasyOCR library for text recognition. Provides good accuracy but may be slower.</p> <pre><code>text_detection:\n  - easyocr:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre> <p>Performance</p> <p>EasyOCR provides excellent accuracy but can be slower than Pytesseract. Consider using it when accuracy is more important than speed.</p> <p>Purpose: Tesseract OCR engine via Python wrapper. Generally faster than EasyOCR.</p> <pre><code>text_detection:\n  - pytesseract:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre> <p>Speed vs Accuracy</p> <p>Pytesseract is generally faster than EasyOCR but may have lower accuracy for complex text or non-standard fonts.</p> <p>Purpose: Google Cloud Vision API for text recognition. Requires API credentials.</p> <pre><code>text_detection:\n  - google_vision:\n      enabled: true\n      url: null\n      capabilities:\n        credentials_path: \"./config/google_credentials.json\"\n</code></pre> <p>API Credentials Required</p> <p>You must provide valid Google Cloud credentials in the <code>credentials_path</code> capability.</p> <p>Purpose: Remote OCR service for text extraction. Useful for distributed or cloud-based OCR.</p> <pre><code>text_detection:\n  - remote_ocr:\n      enabled: true\n      url: \"https://your-ocr-service.com/api/extract\"\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#image-detection","title":"Image Detection","text":"<p>Image detection engines provide template matching capabilities for locating UI elements by image.</p> Template MatchRemote OIR <p>Purpose: OpenCV-based template matching for image recognition.</p> <pre><code>image_detection:\n  - templatematch:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre> <p>Local Processing</p> <p>Template matching runs locally using OpenCV and does not require external services.</p> <p>Purpose: Remote Object Image Recognition (OIR) service for image-based element detection.</p> <pre><code>image_detection:\n  - remote_oir:\n      enabled: true\n      url: \"https://your-oir-service.com/api/match\"\n      capabilities: {}\n</code></pre>"},{"location":"configuration/#dependency-configuration-structure","title":"Dependency Configuration Structure","text":"<p>All dependency types (driver sources, element sources, text detection, image detection) use the same <code>DependencyConfig</code> structure:</p>"},{"location":"configuration/#enabled","title":"<code>enabled</code>","text":"<p>Type: <code>bool</code> | Required: <code>true</code></p> <p>Whether this dependency is enabled. Only enabled dependencies are used by the framework.</p>"},{"location":"configuration/#url","title":"<code>url</code>","text":"<p>Type: <code>Optional[str]</code> | Default: <code>null</code></p> <p>Service URL for remote dependencies (e.g., Appium server, remote OCR service). Set to <code>null</code> for local dependencies.</p>"},{"location":"configuration/#capabilities","title":"<code>capabilities</code>","text":"<p>Type: <code>Dict[str, Any]</code> | Default: <code>{}</code></p> <p>Dependency-specific configuration options. The structure varies by dependency type.</p>"},{"location":"configuration/#example-dependency-configuration","title":"Example Dependency Configuration","text":"<pre><code>driver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723/wd/hub\"\n      capabilities:\n        automationName: \"UiAutomator2\"\n        deviceName: \"emulator-5554\"\n        platformName: \"Android\"\n</code></pre>"},{"location":"configuration/#configuration-examples","title":"Configuration Examples","text":"Android Mobile AppWeb Application (Playwright)Mixed Driver ConfigurationFull Logging Configuration <p>Complete configuration for Android app testing with Appium:</p> <pre><code># Core Settings\nconsole: true\nfile_log: true\nlog_level: INFO\nproject_path: \"./my_android_project\"\nhalt_duration: 0.1\nmax_attempts: 3\n\n# Driver Configuration\ndriver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723/wd/hub\"\n      capabilities:\n        automationName: \"UiAutomator2\"\n        deviceName: \"emulator-5554\"\n        platformName: \"Android\"\n        platformVersion: \"13.0\"\n        appPackage: \"com.example.app\"\n        appActivity: \"com.example.app.MainActivity\"\n\n# Element Sources\nelements_sources:\n  - appium_find_element:\n      enabled: true\n      url: null\n      capabilities: {}\n  - appium_screenshot:\n      enabled: true\n      url: null\n      capabilities: {}\n\n# Text Detection\ntext_detection:\n  - easyocr:\n      enabled: true\n      url: null\n      capabilities: {}\n\n# Image Detection\nimage_detection:\n  - templatematch:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre> <p>Configuration for web testing using Playwright:</p> <pre><code># Core Settings\nconsole: true\nfile_log: true\njson_log: true\nlog_level: INFO\nproject_path: \"./web_test_project\"\nhalt_duration: 0.2\nmax_attempts: 5\n\n# Driver Configuration\ndriver_sources:\n  - playwright:\n      enabled: true\n      url: null\n      capabilities:\n        browser: \"chromium\"\n        headless: false\n        viewport:\n          width: 1920\n          height: 1080\n\n# Element Sources\nelements_sources:\n  - playwright_find_element:\n      enabled: true\n      url: null\n      capabilities: {}\n  - playwright_screenshot:\n      enabled: true\n      url: null\n      capabilities: {}\n\n# Text Detection\ntext_detection:\n  - pytesseract:\n      enabled: true\n      url: null\n      capabilities: {}\n\n# Image Detection\nimage_detection:\n  - templatematch:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre> <p>Example with multiple drivers for fallback support:</p> <pre><code>driver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723/wd/hub\"\n      capabilities:\n        automationName: \"UiAutomator2\"\n        deviceName: \"emulator-5554\"\n        platformName: \"Android\"\n  - selenium:\n      enabled: true\n      url: \"http://localhost:4444/wd/hub\"\n      capabilities:\n        browserName: \"chrome\"\n\nelements_sources:\n  - appium_find_element:\n      enabled: true\n      url: null\n      capabilities: {}\n  - selenium_find_element:\n      enabled: true\n      url: null\n      capabilities: {}\n</code></pre> <p>Example with comprehensive logging setup:</p> <pre><code>console: true\nfile_log: true\njson_log: true\nlog_level: DEBUG\nlog_path: \"./logs/execution.log\"\njson_path: \"./logs/execution.json\"\nproject_path: \"./test_project\"\nexecution_output_path: \"./outputs\"\n</code></pre>"},{"location":"configuration/#configuration-priority-and-merging","title":"Configuration Priority and Merging","text":"<p>The Optics Framework merges configurations in the following order (later configurations override earlier ones):</p> <ol> <li>Default Configuration - Built-in defaults from the <code>Config</code> class</li> <li>Global Configuration - <code>~/.optics/global_config.yaml</code> (user-wide settings)</li> <li>Project Configuration - <code>config.yaml</code> in your project directory</li> </ol>"},{"location":"configuration/#merging-behavior","title":"Merging Behavior","text":"<ul> <li>Simple fields (strings, numbers, booleans): Later values completely replace earlier values</li> <li>Lists (driver_sources, elements_sources, etc.): Items are merged, with later items taking precedence for duplicates</li> <li>Dictionaries (capabilities): Deep merged, with later values overriding earlier values</li> </ul>"},{"location":"configuration/#example-merging","title":"Example Merging","text":"<p>Global Config (<code>~/.optics/global_config.yaml</code>): <pre><code>log_level: INFO\ndriver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723/wd/hub\"\n      capabilities:\n        platformName: \"Android\"\n</code></pre></p> <p>Project Config (<code>config.yaml</code>): <pre><code>log_level: DEBUG\ndriver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723/wd/hub\"\n      capabilities:\n        platformName: \"Android\"\n        deviceName: \"emulator-5554\"\n</code></pre></p> <p>Result: The merged configuration will have <code>log_level: DEBUG</code> and the Appium capabilities will include both <code>platformName: \"Android\"</code> and <code>deviceName: \"emulator-5554\"</code>.</p>"},{"location":"configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Enable Only What You Need: Disabled dependencies reduce overhead and improve performance</li> <li>Use Appropriate OCR: Choose EasyOCR for accuracy, Pytesseract for speed</li> <li>Set Log Level Appropriately: Use DEBUG during development, INFO or WARNING in production</li> <li>Configure Execution Paths: Set <code>project_path</code> and <code>execution_output_path</code> for organized output</li> <li>Use Global Config for Common Settings: Store frequently used settings in <code>~/.optics/global_config.yaml</code></li> <li>Leverage Configuration Priority: Override global settings in project-specific configs when needed</li> <li>Test Configuration Changes: Verify configurations work correctly before running large test suites</li> </ol>"},{"location":"introduction/","title":"Introduction","text":"<p>Optics Framework is a powerful, extensible no-code test automation framework designed for vision-powered, data-driven testing and production app synthetic monitoring. It enables seamless integration with intrusive action &amp; detection drivers such as Appium / WebDriver as well as non-intrusive action drivers such as BLE mouse / keyboard and detection drivers such as video capture card and external web cams.</p>"},{"location":"introduction/#primary-use-cases","title":"Primary Use Cases","text":"<p>This framework was designed primarily for the following use cases:</p> <ol> <li> <p>Production App Monitoring     Where access to USB debugging / developer mode and device screenshots is prohibited</p> </li> <li> <p>Resilient Self-Healing Test Automation     That rely on more than one element identifier and multiple fallbacks to ensure maximum recovery</p> </li> <li> <p>Enable Non-Coders to Build Test Automation Scripts     No programming knowledge required to create and execute tests</p> </li> </ol>"},{"location":"introduction/#supported-platforms","title":"Supported Platforms","text":"<ul> <li> iOS - Native iOS app testing</li> <li> Android - Native Android app testing</li> <li> Browsers - Web application testing</li> <li> Smart TVs - BLE-enabled device testing</li> </ul>"},{"location":"introduction/#key-features","title":"Key Features","text":""},{"location":"introduction/#vision-powered-detections","title":"Vision Powered Detections","text":"<p>UI object detections are powered by computer vision and not just on XPath elements. This makes tests more resilient to UI changes.</p>"},{"location":"introduction/#no-code-automation","title":"No Code Automation","text":"<p>No knowledge of programming languages or access to IDE needed to build automation scripts. Define tests using simple CSV files.</p>"},{"location":"introduction/#non-intrusive-action-drivers","title":"Non-Intrusive Action Drivers","text":"<p>Non-intrusive action drivers such as BLE mouse and keyboard are supported, enabling testing of production apps without developer mode.</p>"},{"location":"introduction/#data-driven-testing-ddt","title":"Data-Driven Testing (DDT)","text":"<p>Execute test cases dynamically with multiple datasets, enabling parameterized testing and iterative execution.</p>"},{"location":"introduction/#extensible-scalable","title":"Extensible &amp; Scalable","text":"<p>Easily add new keywords and modules without any hassle. The modular architecture allows for easy extension.</p>"},{"location":"introduction/#ai-integration","title":"AI Integration","text":"<p>Choose which AI models to use for object recognition and OCR. Support for multiple vision models and OCR engines.</p>"},{"location":"introduction/#self-healing-capability","title":"Self-Healing Capability","text":"<p>Configure multiple drivers, screen capture methods, and detection techniques with priority-based execution. If a primary method fails, the system automatically switches to the next available method in the defined hierarchy.</p>"},{"location":"introduction/#architecture","title":"Architecture","text":"<p>Optics Framework offers a modular architecture paired with a command-line interface (CLI) that enables testers and developers to:</p> <ul> <li>Define test cases using CSV files</li> <li>Manage test data efficiently</li> <li>Execute tests with ease</li> <li>Extend functionality through plugins</li> </ul>"},{"location":"introduction/#who-can-use-it","title":"Who Can Use It?","text":"<p>Whether you're:</p> <ul> <li> A beginner looking to automate your first test</li> <li> An experienced developer contributing new features</li> <li> A QA engineer building comprehensive test suites</li> <li> A DevOps engineer setting up CI/CD pipelines</li> </ul> <p>The Optics Framework is designed to empower you.</p>"},{"location":"introduction/#license","title":"License","text":"<p>The Optics Framework is licensed under the Apache License 2.0, which can be found here. This permissive license allows you to use, modify, and distribute the software freely, as long as you comply with its terms.</p> <p>License Key Points</p> <ul> <li>Redistributions of the code must include a copy of the license and any relevant notices</li> <li>If you modify the code, you should also document your changes</li> <li>The software is provided \"as is\" without any warranties</li> <li>You can use, modify, distribute, and even sublicense the software with minimal restrictions</li> </ul>"},{"location":"introduction/#next-steps","title":"Next Steps","text":"<p>Ready to get started? Check out our Quick Start Guide to create your first test in minutes!</p>"},{"location":"quickstart/","title":"Quick Start Guide","text":"<p>This guide will walk you through creating automated tests using Optics Framework.</p>"},{"location":"quickstart/#installation-setup","title":"Installation &amp; Setup","text":""},{"location":"quickstart/#install-optics-framework","title":"Install Optics Framework","text":"<pre><code>pip install optics-framework\n</code></pre>"},{"location":"quickstart/#quick-start","title":"Quick Start","text":""},{"location":"quickstart/#step-1-create-python-virtual-environment","title":"Step 1: Create Python Virtual Environment","text":"<p>Prerequisites</p> <p>Ensure Appium server is running and a virtual Android device is enabled before proceeding.</p> <pre><code>mkdir ~/test-code\ncd ~/test-code\npython3 -m venv venv\nsource venv/bin/activate\npip install optics-framework\n</code></pre> <p>Important</p> <p>Conda environments are not supported for <code>easyocr</code> and <code>optics-framework</code> together, due to conflicting requirements for <code>numpy</code> (version 1.x vs 2.x). Please use a standard Python virtual environment instead.</p>"},{"location":"quickstart/#step-2-create-a-new-test-project","title":"Step 2: Create a New Test Project","text":"<pre><code>optics setup --install Appium EasyOCR\noptics init --name my_test_project --path . --template contact\n</code></pre> <p>This creates a project structure with sample templates to help you get started.</p> <p>Note</p> <p>Intel based Macs cannot download easyocr.</p>"},{"location":"quickstart/#project-structure","title":"Project Structure","text":"<p>Your test project uses four main components that work together:</p> <pre><code>optics_framework/\n\u2514\u2500\u2500 samples/\n    \u2514\u2500\u2500 my_test_project/\n        \u251c\u2500\u2500 config.yaml\n        \u251c\u2500\u2500 modules/\n        |   \u2514\u2500\u2500 modules.csv\n        \u251c\u2500\u2500 test_data/\n        |   \u251c\u2500\u2500 elements.csv\n        |   \u2514\u2500\u2500 input_templates/\n        \u2514\u2500\u2500 test_cases/\n            \u2514\u2500\u2500 test_cases.csv\n</code></pre> <p><code>my_test_project/</code> - Your specific project name (you choose this)</p>"},{"location":"quickstart/#using-invoke-api-and-api-definition-files","title":"Using Invoke API and API definition files","text":"<p>Projects that use the Invoke Api keyword include API definition YAML files, which are a separate asset from element files. The Invoke Api keyword does not use <code>elements.csv</code> or element YAML; it uses API definition data only. Add an <code>api.yaml</code> (or other YAML files under the project) that contains a top-level <code>api</code> or <code>apis</code> key. The runner auto-discovers and loads any such YAML files under the project directory. Example layout when using API tests:</p> <pre><code>my_test_project/\n\u251c\u2500\u2500 config.yaml\n\u251c\u2500\u2500 api.yaml\n\u251c\u2500\u2500 modules/\n\u251c\u2500\u2500 test_data/\n|   \u251c\u2500\u2500 elements.csv\n|   \u2514\u2500\u2500 input_templates/\n\u2514\u2500\u2500 test_cases/\n</code></pre> <p>The API YAML format is different from element files: it defines collections, base URLs, endpoints, request/response, and optional <code>extract</code> rules. See the Invoke Api and Add Api sections in Keyword Usage, and sample <code>api.yaml</code> files</p>"},{"location":"quickstart/#step-1-configure-your-environment","title":"Step 1: Configure Your Environment","text":"<p>The <code>config.yaml</code> file tells the framework how to connect to your device and what tools to use for finding elements.</p>"},{"location":"quickstart/#driver-connection","title":"Driver Connection","text":"<p>Connects to your device/emulator:</p> <pre><code>driver_sources:\n    - appium:\n        enabled: true\n        url: \"http://127.0.0.1:4723/wd/hub\"\n        capabilities:\n            automationName: UiAutomator2\n            deviceName: emulator-5554\n            platformName: Android\n</code></pre>"},{"location":"quickstart/#key-settings-to-update","title":"Key Settings to Update","text":"<ul> <li><code>platformVersion</code>: Your Android/iOS version</li> <li><code>deviceName</code>: Your device name</li> <li><code>udid</code>: Your device's unique identifier (find with <code>adb devices</code>)</li> <li><code>url</code>: Your Appium server address (usually localhost)</li> </ul>"},{"location":"quickstart/#step-2-capture-ui-element-screenshots","title":"Step 2: Capture UI Element Screenshots","text":"<p>Before defining elements in the CSV, you need to capture screenshots of the UI elements you want to interact with.</p>"},{"location":"quickstart/#what-is-input_templates","title":"What is <code>input_templates/</code>?","text":"<p>This folder stores PNG images of buttons, icons, text fields, and other UI elements from your application. The framework uses these images to visually locate elements on the screen when other methods fail.</p> <p>Best Practice</p> <p>Organize <code>input_templates/</code> with subfolders for different screens and name images to match their Element_ID exactly.</p>"},{"location":"quickstart/#step-3-define-your-elements","title":"Step 3: Define Your Elements","text":"<p>Elements are the UI components you'll interact with \u2013 buttons, text fields, tabs, etc.</p>"},{"location":"quickstart/#csv-structure","title":"CSV Structure","text":"<pre><code>Element_Name,Element_ID_xpath,Element_ID,Element_ID_Text\n</code></pre>"},{"location":"quickstart/#column-explanations","title":"Column Explanations","text":"<ul> <li>Element_Name: A descriptive name you'll use in modules (e.g., <code>login_button</code>)</li> <li>Element_ID_xpath: The technical XPath or accessibility ID for finding the element</li> <li>Element_ID: The PNG filename from <code>input_templates/</code> for visual matching</li> <li>Element_Text: The visible text on the element (optional, for verification)</li> </ul>"},{"location":"quickstart/#example-elementscsv","title":"Example <code>elements.csv</code>","text":"<pre><code>Element_Name,Element_ID_xpath,Element_ID,Element_Text\nlogin_button,\"//android.widget.Button[@resource-id=\"\"com.app.login:id/btnLogin\"\"]\",button_login.png,Login\n</code></pre>"},{"location":"quickstart/#special-element-types","title":"Special Element Types","text":"<pre><code>Element_Name,Element_ID_xpath,Element_ID,Element_Text\ntest_password,,,SecurePass123\nretry_count,,,3\nitem_list,\"[\"\"Item1\"\",\"\"Item2\"\",\"\"Item3\"\"]\",,\n</code></pre>"},{"location":"quickstart/#finding-xpaths","title":"Finding XPaths","text":"<p>Use Appium Inspector or your device's UI Automator to find element XPaths:</p> <ol> <li>Connect Appium Inspector to your device</li> <li>Navigate to the screen with your element</li> <li>Click the element in the inspector</li> <li>Copy the XPath</li> <li>Paste into <code>Element_ID_xpath</code> column</li> </ol> <p>Newlines and special characters in CSV</p> <p>XPaths and other locator strings in CSV stay one line per row. To include a newline in a value (e.g. in <code>@content-desc</code>), use <code>\\n</code>; for a tab use <code>\\t</code>, and for a literal backslash use <code>\\\\</code>. Example: <code>//android.widget.ImageView[@content-desc=\"I\\nIcici Bank Limited\"]</code> in a cell is read as an XPath whose attribute value contains a real newline between <code>I</code> and <code>Icici Bank Limited</code>.</p>"},{"location":"quickstart/#step-4-create-reusable-modules","title":"Step 4: Create Reusable Modules","text":"<p>Modules are sequences of actions that accomplish a specific task, such as building blocks.</p>"},{"location":"quickstart/#csv-structure_1","title":"CSV Structure","text":"<pre><code>module_name,module_step,param_1,param_2,param_3,param_4,param_5\n</code></pre>"},{"location":"quickstart/#column-explanations_1","title":"Column Explanations","text":"<ul> <li>module_name: Name of your module (can repeat for multi-step modules)</li> <li>module_step: The action to perform (see common actions below)</li> <li>param_1 to param_x: Parameters for the action (vary by action type)</li> </ul> <p>Parameter Count</p> <p>If your module has fewer <code>param_x</code> columns than the action requires, those extra parameters will be ignored \u2014 leading to incomplete or failed test execution. Always check the expected number of parameters for each keyword and ensure your CSV matches it exactly.</p>"},{"location":"quickstart/#common-actions","title":"Common Actions","text":"<pre><code>module_name,module_step,param_1,param_2,param_3,param_4,param_5\nLaunch Application,Launch App,,,,\nNavigate To Settings,Press Element,${settings_icon},,,\nAdd Multiple Items,Run Loop,Add Single Item,item_name,${item_list},,\nClose Application,Force Terminate App,,,,\nLaunch External App,Launch Other App,com.example.otherapp,,,,\n</code></pre> <p>Variable References</p> <p><code>${element_name}</code> references an element from <code>elements.csv</code></p>"},{"location":"quickstart/#step-5-build-test-cases","title":"Step 5: Build Test Cases","text":"<p>Test cases combine modules into complete test scenarios.</p>"},{"location":"quickstart/#csv-structure_2","title":"CSV Structure","text":"<pre><code>test_case,test_step\n</code></pre>"},{"location":"quickstart/#column-explanations_2","title":"Column Explanations","text":"<ul> <li>test_case: Name of your test scenario</li> <li>test_step: Module to execute (references <code>module_name</code> from <code>modules.csv</code>)</li> </ul>"},{"location":"quickstart/#special-test-cases","title":"Special Test Cases","text":"<p>Suite Setup - Runs before all tests:</p> <pre><code>test_case,test_step\nSuite Setup,Launch Application\n</code></pre> <p>Suite Teardown - Runs after all tests:</p> <pre><code>test_case,test_step\nSuite Teardown,Close Application\n</code></pre> <p>Regular Test:</p> <pre><code>test_case,test_step\nVerify User Login,User Login\n</code></pre>"},{"location":"quickstart/#why-separate-test-cases-from-modules","title":"Why Separate Test Cases from Modules?","text":"<p>Test cases define what to test, modules define how to do it. This separation lets you mix and match modules for different test scenarios.</p>"},{"location":"quickstart/#running-your-tests","title":"Running Your Tests","text":""},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 installed on your system</li> <li>Optics Framework installed in your virtual environment</li> <li>Appium server running: <code>appium</code></li> <li>Android virtual device or physical device connected and verified: <code>adb devices</code></li> </ul>"},{"location":"quickstart/#always-dry-run-test-cases-before-executing","title":"Always Dry Run Test Cases Before Executing","text":"<pre><code>optics dry_run my_test_project\n</code></pre>"},{"location":"quickstart/#why-are-dry-runs-needed","title":"Why Are Dry Runs Needed?","text":"<ul> <li>Detects missing files (like <code>elements.csv</code> or input templates) early</li> <li>Verifies CSV and YAML syntax and formatting</li> <li>Checks that all referenced elements and modules exist</li> <li>Saves time by catching setup errors before full execution</li> </ul>"},{"location":"quickstart/#execute-test-cases","title":"Execute Test Cases","text":"<pre><code>optics execute my_test_project\n</code></pre>"},{"location":"quickstart/#what-happens-during-execution","title":"What Happens During Execution","text":"<ol> <li>Framework reads your <code>config.yaml</code> and connects to device</li> <li>Loads all elements from <code>elements.csv</code></li> <li>Loads all modules from <code>modules.csv</code></li> <li>Loads element images from <code>input_templates/</code></li> <li>Executes test cases in order from <code>test_cases.csv</code></li> <li>Generates a test report with results and logs</li> </ol>"},{"location":"quickstart/#best-practices","title":"Best Practices","text":""},{"location":"quickstart/#1-naming-conventions","title":"1. Naming Conventions","text":"<ul> <li>Use descriptive names: <code>login_button_xpath</code>, <code>login_button_text</code>, etc.</li> <li>Be consistent: if you use <code>firsttest_case</code>, use it everywhere</li> <li>Include element type in name: <code>_button</code>, <code>_field</code>, <code>_icon</code>, <code>_tab</code></li> <li>Match <code>Element_Name</code> with PNG filename for clarity</li> </ul>"},{"location":"quickstart/#2-screenshot-management","title":"2. Screenshot Management","text":"<ul> <li>Organize <code>input_templates/</code> with subfolders for different screens</li> <li>Name images to match their <code>Element_ID</code> exactly</li> <li>Update screenshots when UI changes</li> </ul>"},{"location":"quickstart/#3-module-design","title":"3. Module Design","text":"<ul> <li>Keep modules focused on one task</li> <li>Make modules reusable \u2013 avoid hardcoded values</li> <li>Use variables (<code>${variable_name}</code>) for data that changes</li> <li>Name modules clearly to describe their purpose</li> </ul>"},{"location":"quickstart/#4-element-definition","title":"4. Element Definition","text":"<ul> <li>Prefer (text, image) over xpaths</li> <li>Test each element can be found reliably</li> <li>Update <code>elements.csv</code> when app UI changes</li> </ul>"},{"location":"quickstart/#5-test-organization","title":"5. Test Organization","text":"<ul> <li>Always include Suite Setup and Suite Teardown</li> <li>Group related tests together</li> <li>Start with a clean state (use Setup to reset app)</li> <li>Test one feature per test case</li> <li>Name tests clearly: <code>\"Test_FeatureName_Scenario\"</code></li> </ul>"},{"location":"quickstart/#6-file-organization","title":"6. File Organization","text":"<pre><code>optics_framework/\n    \u2514\u2500\u2500 samples/\n        \u2514\u2500\u2500 my_test_project/\n                \u251c\u2500\u2500 config.yaml\n                \u251c\u2500\u2500 modules/\n                |   \u2514\u2500\u2500 modules.csv\n                \u251c\u2500\u2500 test_data/\n                |   \u251c\u2500\u2500 elements.csv\n                |   \u2514\u2500\u2500 input_templates/\n                |       \u251c\u2500\u2500 button_login.png\n                |       \u2514\u2500\u2500 field_username.png\n                \u2514\u2500\u2500 test_cases/\n                    \u2514\u2500\u2500 test_cases.csv\n</code></pre>"},{"location":"quickstart/#7-debugging","title":"7. Debugging","text":"<ul> <li>Set <code>log_level: DEBUG</code> in <code>config.yaml</code> for detailed logs</li> <li>Enable <code>file_log: true</code> to save logs to file</li> <li>Test modules individually before combining them</li> <li>Use meaningful module names that explain what failed</li> <li>Check <code>input_templates/</code> images load correctly</li> <li>Verify element names match exactly (case-sensitive)</li> </ul>"},{"location":"quickstart/#quick-start-checklist","title":"Quick Start Checklist","text":"<ul> <li> Configure <code>config.yaml</code> with your device details</li> <li> Capture screenshots of UI elements</li> <li> Save screenshots to <code>test_data/input_templates/</code></li> <li> Define elements in <code>elements.csv</code> (with XPaths and image filenames)</li> <li> Create modules in <code>modules.csv</code> for each action sequence</li> <li> Build test cases in <code>test_cases.csv</code> combining modules</li> <li> Start Appium server</li> <li> Connect device/emulator</li> <li> Dry run tests</li> <li> Execute tests</li> <li> Review test results and logs</li> </ul>"},{"location":"quickstart/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<p>Avoid These Mistakes</p> <ul> <li>\u274c Hardcoding values - Use variables instead</li> <li>\u274c Duplicate logic - Create reusable modules</li> <li>\u274c Poor element identifiers - Elements should be unique and stable</li> <li>\u274c Missing screenshots - <code>Element_ID</code> references non-existent PNG files</li> <li>\u274c Wrong file paths - Ensure <code>input_templates/</code> path is correct</li> <li>\u274c No error handling - Define fallback element finding methods</li> <li>\u274c Skipping Setup/Teardown - Always clean up after tests</li> <li>\u274c Testing too much at once - Keep test cases focused</li> <li>\u274c Outdated screenshots - Update images when UI changes</li> <li>\u274c Generic element names - <code>button1.png</code> is less clear than <code>button_login.png</code></li> </ul>"},{"location":"quickstart/#need-help","title":"Need Help?","text":""},{"location":"quickstart/#common-issues","title":"Common Issues","text":"<p>Troubleshooting</p> <ul> <li>Element not found: Check XPath in Appium Inspector, verify PNG exists in <code>input_templates/</code></li> <li>Wrong element clicked: Screenshot may be outdated or too similar to other elements</li> <li>Test hangs: Check if app is waiting for user input or loading</li> <li>Image match fails: Recapture screenshot on same device/resolution</li> </ul>"},{"location":"quickstart/#troubleshooting-steps","title":"Troubleshooting Steps","text":"<ol> <li>Check logs in the test output directory</li> <li>Verify elements exist with Appium Inspector</li> <li>Test individual modules before full test cases</li> <li>Verify the <code>dry_run</code> works before executing to save time</li> <li>Ensure all file paths and element names match exactly (case-sensitive)</li> <li>Verify PNG files are in correct location and named correctly</li> <li>Check image quality and cropping of templates</li> </ol>"},{"location":"user_workflow/","title":"User Workflow","text":"<p>This guide walks you through the workflow for using the Optics Framework to create and execute automated tests. The framework relies on a CSV-based structure and a YAML configuration file to define test cases, modules, and elements.</p>"},{"location":"user_workflow/#initial-setup","title":"Initial Setup","text":"<p>To begin, the Optics Framework requires at least one YAML configuration file (<code>config.yaml</code>) and CSV files to define your tests. You can bootstrap a project using the <code>optics init</code> command:</p> <pre><code>optics init --name youtube --path ./youtube\n</code></pre> <ul> <li>--name: Specifies the project name (e.g., <code>youtube</code>).</li> <li>--path: Defines where the project folder will be created.</li> <li>--template: (Optional) Uses a predefined sample template to populate initial files.</li> </ul> <p>This command generates a project directory with a default structure, including a <code>config.yaml</code> and placeholder CSV files.</p>"},{"location":"user_workflow/#csv-use-cases","title":"CSV Use Cases","text":"<p>The framework uses three primary CSV files to organize test logic: <code>test_cases.csv</code>, <code>test_modules.csv</code>, and <code>elements.csv</code>. Below are their purposes and examples.</p>"},{"location":"user_workflow/#test_casescsv","title":"test_cases.csv","text":"<p>This file defines test cases and links them to specific test steps (modules). It has two columns: <code>test_case</code> and <code>test_step</code>.</p> <p>Example:</p> <pre><code>test_case,test_step\nRunning youtube using text,Launching App using text\nRunning youtube unknown,Repeat Test\n</code></pre> <ul> <li>test_case: The name of the test case.</li> <li>test_step: The module or step to execute for that test case.</li> </ul> <pre><code>test_case,test_step\nSuite Setup, Launch youtube app\nSuite Teardown, Terminate youtube app\nSetup, Load home page\nTeardown, Return to Home Page\nRunning youtube using text,Launching App using text\nRunning youtube unknown,Repeat Test\n</code></pre> <p>Suite Setup/Teardown and Test Case Setup/Teardown</p> <p>You can define setup and teardown steps in the test_cases.csv to ensure proper initialization and cleanup for both the entire test suite and individual test cases.</p>"},{"location":"user_workflow/#test_modulescsv","title":"test_modules.csv","text":"<p>This file lists all modules, their steps, and associated parameters. Columns include <code>module_name</code>, <code>module_step</code>, and optional <code>param_1</code> to <code>param_n</code> (as many parameters as needed).</p> <p>Example:</p> <pre><code>module_name,module_step,param_1,param_2,param_3,param_4,param_5\nLaunching App using text,Launch App,,,,\nLaunching App using text,Press Element,//android.widget.Button[@resource-id=\"com.android.permissioncontroller:id/permission_allow_button\"],,,\nInteract using text,Assert Presence,${Subscriptions_text},,,\nInteract using text,Press Element,${Subscriptions_text},,,\nInteract using text,Press Element,${Home_text},,,\nInteract using xpath,Assert Presence,${Subscriptions_xpath},,,\nInteract using xpath,Press Element,${Subscriptions_xpath},,,\nInteract using xpath,Press Element,${Home_xpath},,,\nInteract using images,Press Element,${Subscriptions_image},,,\nInteract using images,Press Element,${Home_image},,,\nDynamic Launch,condition,${METHOD} == 'text',Interact using text,${METHOD} == 'xpath',Interact using xpath,Interact using images\nRepeat Test,Run Loop,Dynamic Launch,${METHOD},${List}\n</code></pre> <ul> <li>module_name: The name of the module.</li> <li>module_step: A keyword or action (e.g., <code>Launch App</code>, <code>Press Element</code>). See Keywords Reference for a full list.</li> <li>param_1, param_2, ...: Parameters for the action, such as element IDs or conditions.</li> </ul>"},{"location":"user_workflow/#elementscsv","title":"elements.csv","text":"<p>This file acts as a variable store, mapping element names to their identifiers (e.g., XPath, text, or image files).</p> <p>Example:</p> <pre><code>Element_Name,Element_ID\nSubscriptions_xpath,//android.widget.TextView[@resource-id=\"com.google.android.youtube:id/text\" and @text=\"Subscriptions\"]\nyou_xpath,(//android.widget.ImageView[@resource-id=\"com.google.android.youtube:id/image\"])[4]\nHome_xpath,//android.widget.TextView[@resource-id=\"com.google.android.youtube:id/text\" and @text=\"Home\"]\nSubscriptions_text,Subscriptions\nyou_text,Library\nHome_text,Home\nSubscriptions_image,sub.jpeg\nYoutube_image,youtube.jpeg\nHome_image,home.png\nMETHOD,None\nList,\"[\"\"xpath\"\",\"\"text\"\",\"\"images\"\"]\"\n</code></pre> <ul> <li>Element_Name: The variable name used in <code>test_modules.csv</code>.</li> <li>Element_ID: The actual identifier (e.g., XPath, text value, or image filename). To include newlines in XPath or locator values, use <code>\\n</code> in the CSV; use <code>\\t</code> for tab and <code>\\\\</code> for a literal backslash.</li> </ul>"},{"location":"user_workflow/#configuration-file-configyaml","title":"Configuration File (config.yaml)","text":"<p>The <code>config.yaml</code> file specifies the driver and detection methods for your project. Below is an example tailored for an Android YouTube app test:</p> <pre><code>driver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\n      capabilities:\n        appActivity: \"com.google.android.youtube.app.honeycomb.Shell$HomeActivity\"\n        appPackage: \"com.google.android.youtube\"\n        automationName: \"UiAutomator2\"\n        deviceName: \"emulator-5554\"\n        platformName: \"Android\"\n\nelements_sources:\n  - appium_find_element:\n      enabled: true\n      url: null\n      capabilities: {}\n  - appium_screenshot:\n      enabled: true\n      url: null\n      capabilities: {}\n\n\ntext_detection:\n  - easyocr:\n      enabled: true\n      url: null\n      capabilities: {}\n\nimage_detection:\n  - templatematch:\n      enabled: true\n      url: null\n      capabilities: {}\n\nlog_level: INFO\n\ninclude:\n- \"Test cases to be included\"\n\nexclude:\n- \"Test Cases to be excluded\"\n</code></pre> <ul> <li>driver_sources: Defines the automation driver (e.g., Appium for Android).</li> <li>elements_sources: Specifies how elements are located (e.g., Appium or screenshots).</li> <li>text_detection: Configures text recognition tools (e.g., EasyOCR).</li> <li>image_detection: Sets up image matching (e.g., Template Matching).</li> <li>include: Test cases to be executed, the rest of the test cases will be skipped.</li> <li>exclude: Specified test cases to be skipped, all other test cases will be executed.</li> </ul>"},{"location":"user_workflow/#project-structure","title":"Project Structure","text":"<p>Your project folder should look like this:</p> <pre><code>/youtube\n\u251c\u2500\u2500 config.yaml\n\u251c\u2500\u2500 elements.csv\n\u251c\u2500\u2500 execution_output\n\u2502   \u2514\u2500\u2500 logs.log\n\u251c\u2500\u2500 input_templates\n\u2502   \u251c\u2500\u2500 home.png\n\u2502   \u251c\u2500\u2500 sub.jpeg\n\u2502   \u2514\u2500\u2500 youtube.jpeg\n\u251c\u2500\u2500 test_cases.csv\n\u2514\u2500\u2500 test_modules.csv\n</code></pre> <ul> <li>input_templates/: Store any input images (e.g., <code>home.png</code>) referenced in <code>elements.csv</code>.</li> <li>execution_output/: Contains logs and other output generated during test runs.</li> </ul>"},{"location":"user_workflow/#using-keywords-in-modules","title":"Using Keywords in Modules","text":"<p>Modules in <code>test_modules.csv</code> use a predefined set of keywords (e.g., <code>Launch App</code>, <code>Press Element</code>, <code>Assert Presence</code>). For a complete list, refer to the Keywords Reference.</p>"},{"location":"user_workflow/#samples-for-your-reference","title":"Samples For Your Reference","text":"<p>Sample test scripts are provided to demonstrate the framework\u2019s capabilities and guide users in writing their own. These examples show how texts, XPaths, and images can be used interchangeably, and how test data can be structured using CSV files.</p> <p>\ud83d\udcc5 Calendar</p> <p>Calendar sample showcases how our framework supports dynamic data fetching using APIs (e.g. fetching current date) and apply natural date evaluations to compute future dates on the fly.</p> <p>\ud83d\udcfa Youtube</p> <p>Youtube sample showcases our framework's ability to interact with the devices using multiple element types such as texts, xpaths and images.</p> <p>\ud83d\udc65 Contact</p> <p>Contact example showcases form input automation, screen validation using dynamic element assertions, and how structured test data (like ${First_Name}) can be reused across steps.</p> <p>\ud83d\udce7 Gmail Website</p> <p>A Selenium-based sample that automates Gmail sign-in and account creation. It includes clicking on buttons like \u201cSign in\u201d and \u201cCreate an account,\u201d and entering user credentials, showcasing web interaction using text-based locators.</p>"},{"location":"user_workflow/#validating-your-setup","title":"Validating Your Setup","text":"<p>To check for syntactical errors in your CSV files and configuration, run a dry run:</p> <pre><code>optics dry_run ./contact\n</code></pre> <p>For a specific test case:</p> <pre><code>optics dry_run ./contact\n</code></pre> <p>This command simulates the test execution without interacting with the device, helping you catch issues early.</p>"},{"location":"user_workflow/#executing-tests","title":"Executing Tests","text":"<p>Once validated, execute your tests with:</p> <pre><code>optics execute ./contact\n</code></pre> <ul> <li>./contact: Path to your project directory. The runner discovers test cases, modules, and config from this folder.</li> </ul> <p>Output, including logs, will be saved in the <code>execution_output/</code> folder.</p>"},{"location":"api_reference/action_keywords/","title":"Action Keywords","text":"<p>The <code>ActionKeyword</code> class provides methods for interacting with elements, including pressing, swiping, typing, and other user actions.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword","title":"<code>optics_framework.api.action_keyword.ActionKeyword</code>","text":"<p>High-Level API for Action Keywords</p> <p>This class provides functionality for managing action keywords related to applications, including pressing elements, scrolling, swiping, and text input.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.clear_element_text","title":"<code>clear_element_text(element, aoi_x='0', aoi_y='0', aoi_width='100', aoi_height='100', event_name=None, *, located=None)</code>","text":"<p>Clear text from a specified element.</p> <p>:param element: The target element (Image template, OCR template, or XPath). :param aoi_x: X percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_y: Y percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_width: Width percentage of Area of Interest (0-100). Default: 100. :param aoi_height: Height percentage of Area of Interest (0-100). Default: 100. :param event_name: The event triggering the action.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.detect_and_press","title":"<code>detect_and_press(element, timeout='30', event_name=None)</code>","text":"<p>Detect and press a specified element.</p> <p>:param element: The element to be detected and pressed (Image template, OCR template, or XPath). :param timeout: Timeout for the detection operation. :param event_name: The event triggering the press.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.enter_number","title":"<code>enter_number(element, number, aoi_x='0', aoi_y='0', aoi_width='100', aoi_height='100', event_name=None, *, located=None)</code>","text":"<p>Enter a specified number into an element.</p> <p>:param element: The target element (Image template, OCR template, or XPath). :param number: The number to be entered. :param aoi_x: X percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_y: Y percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_width: Width percentage of Area of Interest (0-100). Default: 100. :param aoi_height: Height percentage of Area of Interest (0-100). Default: 100. :param event_name: The event triggering the input.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.enter_text","title":"<code>enter_text(element, text, aoi_x='0', aoi_y='0', aoi_width='100', aoi_height='100', event_name=None, *, located=None)</code>","text":"<p>Enter text into a specified element.</p> <p>:param element: The target element (Image template, OCR template, or XPath). :param text: The text to be entered. :param aoi_x: X percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_y: Y percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_width: Width percentage of Area of Interest (0-100). Default: 100. :param aoi_height: Height percentage of Area of Interest (0-100). Default: 100. :param event_name: The event triggering the input.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.enter_text_direct","title":"<code>enter_text_direct(text, event_name=None)</code>","text":"<p>Enter text using the keyboard.</p> <p>:param text: The text to be entered. :param event_name: The event triggering the input.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.enter_text_using_keyboard","title":"<code>enter_text_using_keyboard(text_input, event_name=None)</code>","text":"<p>Enter text or press a special key using the keyboard.</p> <p>If the input is a string that includes angle brackets (e.g., ''), the text between the brackets will be interpreted as a special key name and mapped accordingly. <p>:param input: The text or special key identifier to send. :param event_name: Optional event label for logging.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.execute_script","title":"<code>execute_script(script_or_json, event_name=None)</code>","text":"<p>Execute JavaScript/script in the current context.</p> <p>:param script_or_json: The JavaScript code/script command, or a JSON string containing                        {\"script\": \"...\", \"args\": {...}} or {\"script\": \"...\"}.                        Examples:                        - \"mobile:pressKey\" (plain script)                        - '{\"script\": \"mobile:pressKey\", \"args\": {\"keycode\": 3}}' (JSON with args)                        - '{\"script\": \"mobile:clear\"}' (JSON without args) :type script_or_json: str :param event_name: The event triggering the script execution, if any. :type event_name: Optional[str] :return: The result of the script execution. :rtype: Any</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.get_text","title":"<code>get_text(element)</code>","text":"<p>Get the text from a specified element.</p> <p>:param element: The target element (Image template, OCR template, or XPath). :return: The text from the element or None if not supported.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.press_by_coordinates","title":"<code>press_by_coordinates(coor_x, coor_y, repeat='1', event_name=None)</code>","text":"<p>Press an element by absolute coordinates.</p> <p>:param coor_x: X coordinate of the press. :param coor_y: Y coordinate of the press. :param repeat: Number of times to repeat the press. :param event_name: The event triggering the press.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.press_by_percentage","title":"<code>press_by_percentage(percent_x, percent_y, repeat='1', event_name=None)</code>","text":"<p>Press an element by percentage coordinates.</p> <p>:param percent_x: X percentage of the press (as string, will be converted to float). :param percent_y: Y percentage of the press (as string, will be converted to float). :param repeat: Number of times to repeat the press. :param event_name: The event triggering the press.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.press_checkbox","title":"<code>press_checkbox(element, aoi_x='0', aoi_y='0', aoi_width='100', aoi_height='100', event_name=None, *, located=None)</code>","text":"<p>Press a specified checkbox element.</p> <p>:param element: The checkbox element (Image template, OCR template, or XPath). :param aoi_x: X percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_y: Y percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_width: Width percentage of Area of Interest (0-100). Default: 100. :param aoi_height: Height percentage of Area of Interest (0-100). Default: 100. :param event_name: The event triggering the press.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.press_element","title":"<code>press_element(element, repeat='1', offset_x='0', offset_y='0', index='0', aoi_x='0', aoi_y='0', aoi_width='100', aoi_height='100', event_name=None, *, located=None)</code>","text":"<p>Press a specified element.</p> <p>:param element: The element to be pressed (text, xpath or image). :param repeat: Number of times to repeat the press. :param offset_x: X offset of the press. :param offset_y: Y offset of the press. :param index: Index of the element if multiple matches are found. :param event_name: The event triggering the press. :param aoi_x: X percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_y: Y percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_width: Width percentage of Area of Interest (0-100). Default: 100. :param aoi_height: Height percentage of Area of Interest (0-100). Default: 100.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.press_keycode","title":"<code>press_keycode(keycode, event_name=None)</code>","text":"<p>Press a specified keycode.</p> <p>:param keycode: The keycode to be pressed. :param event_name: The event triggering the press.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.press_radio_button","title":"<code>press_radio_button(element, aoi_x='0', aoi_y='0', aoi_width='100', aoi_height='100', event_name=None, *, located=None)</code>","text":"<p>Press a specified radio button.</p> <p>:param element: The radio button element (Image template, OCR template, or XPath). :param aoi_x: X percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_y: Y percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_width: Width percentage of Area of Interest (0-100). Default: 100. :param aoi_height: Height percentage of Area of Interest (0-100). Default: 100. :param event_name: The event triggering the press.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.scroll","title":"<code>scroll(direction, event_name=None)</code>","text":"<p>Perform a scroll action in a specified direction.</p> <p>:param direction: The scroll direction (up, down, left, right). :param event_name: The event triggering the scroll.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.scroll_from_element","title":"<code>scroll_from_element(element, direction, scroll_length, aoi_x='0', aoi_y='0', aoi_width='100', aoi_height='100', event_name=None, *, located=None)</code>","text":"<p>Perform a scroll action starting from a specified element.</p> <p>:param element: The element to scroll from (Image template, OCR template, or XPath). :param direction: The scroll direction (up, down, left, right). :param scroll_length: The length of the scroll. :param aoi_x: X percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_y: Y percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_width: Width percentage of Area of Interest (0-100). Default: 100. :param aoi_height: Height percentage of Area of Interest (0-100). Default: 100. :param event_name: The event triggering the scroll.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.scroll_until_element_appears","title":"<code>scroll_until_element_appears(element, direction, timeout, event_name=None)</code>","text":"<p>Scroll in a specified direction until an element appears.</p> <p>:param element: The target element (Image template, OCR template, or XPath). :param direction: The scroll direction (up, down, left, right). :param timeout: Timeout for the scroll operation. :param event_name: The event triggering the scroll.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.select_dropdown_option","title":"<code>select_dropdown_option(element, option, event_name=None)</code>","text":"<p>Select a specified dropdown option.</p> <p>:param element: The dropdown element (Image template, OCR template, or XPath). :param option: The option to be selected. :param event_name: The event triggering the selection.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.sleep","title":"<code>sleep(duration)</code>","text":"<p>Sleep for a specified duration.</p> <p>:param duration: The duration of the sleep in seconds.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.swipe","title":"<code>swipe(coor_x, coor_y, direction='right', swipe_length='50', event_name=None)</code>","text":"<p>Perform a swipe action in a specified direction.</p> <p>:param coor_x: X coordinate of the swipe. :param coor_y: Y coordinate of the swipe. :param direction: The swipe direction (up, down, left, right). :param swipe_length: The length of the swipe. :param event_name: The event triggering the swipe.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.swipe_by_percentage","title":"<code>swipe_by_percentage(percent_x, percent_y, direction='right', swipe_length='50', event_name=None)</code>","text":"<p>Perform a swipe action in a specified direction by percentage.</p> <p>:param percent_x: X percentage of the swipe. :param percent_y: Y percentage of the swipe. :param direction: The swipe direction (up, down, left, right). :param swipe_length: The length of the swipe. :param event_name: The event triggering the swipe.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.swipe_from_element","title":"<code>swipe_from_element(element, direction, swipe_length, aoi_x='0', aoi_y='0', aoi_width='100', aoi_height='100', event_name=None, *, located=None)</code>","text":"<p>Perform a swipe action starting from a specified element.</p> <p>:param element: The element to swipe from (Image template, OCR template, or XPath). :param direction: The swipe direction (up, down, left, right). :param swipe_length: The length of the swipe. :param aoi_x: X percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_y: Y percentage of Area of Interest top-left corner (0-100). Default: 0. :param aoi_width: Width percentage of Area of Interest (0-100). Default: 100. :param aoi_height: Height percentage of Area of Interest (0-100). Default: 100. :param event_name: The event triggering the swipe.</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.swipe_seekbar_to_right_android","title":"<code>swipe_seekbar_to_right_android(element, event_name=None)</code>","text":"<p>Swipe a seekbar to the right.</p> <p>:param element: The seekbar element (Image template, OCR template, or XPath).</p>"},{"location":"api_reference/action_keywords/#optics_framework.api.action_keyword.ActionKeyword.swipe_until_element_appears","title":"<code>swipe_until_element_appears(element, direction, timeout, event_name=None)</code>","text":"<p>Swipe in a specified direction until an element appears.</p> <p>:param element: The target element (Image template, OCR template, or XPath). :param direction: The swipe direction (up, down, left, right). :param timeout: Timeout until element search is performed. :param event_name: The event triggering the swipe.</p>"},{"location":"api_reference/app_management/","title":"App Management","text":"<p>The <code>AppManagement</code> class provides functionality for launching, terminating, and managing application sessions.</p>"},{"location":"api_reference/app_management/#optics_framework.api.app_management.AppManagement","title":"<code>optics_framework.api.app_management.AppManagement</code>","text":"<p>A high-level API for managing applications.</p> <p>This class provides functionality for launching, terminating, and modifying app settings.</p> <p>Attributes:</p> Name Type Description <code>driver</code> <code>object</code> <p>The driver instance for managing applications.</p>"},{"location":"api_reference/app_management/#optics_framework.api.app_management.AppManagement.close_and_terminate_app","title":"<code>close_and_terminate_app()</code>","text":"<p>Closes and terminates a specified application.</p> <p>:param package_name: The package name of the application. :param event_name: The event triggering the app termination, if any.</p>"},{"location":"api_reference/app_management/#optics_framework.api.app_management.AppManagement.force_terminate_app","title":"<code>force_terminate_app(app_name, event_name=None)</code>","text":"<p>Forcefully terminates the specified application.</p> <p>:param app_name: The name of the application to terminate. :param event_name: The event triggering the forced termination, if any.</p>"},{"location":"api_reference/app_management/#optics_framework.api.app_management.AppManagement.get_app_version","title":"<code>get_app_version()</code>","text":"<p>Gets the version of the application.</p> <p>:return: The version of the application, or None if not available.</p>"},{"location":"api_reference/app_management/#optics_framework.api.app_management.AppManagement.get_driver_session_id","title":"<code>get_driver_session_id()</code>","text":"<p>Return the current driver session id, if available.</p>"},{"location":"api_reference/app_management/#optics_framework.api.app_management.AppManagement.initialise_setup","title":"<code>initialise_setup()</code>","text":"<p>Sets up the environment for the driver module.</p> <p>This method should be called before performing any application management operations.</p>"},{"location":"api_reference/app_management/#optics_framework.api.app_management.AppManagement.launch_app","title":"<code>launch_app(app_identifier=None, app_activity=None, event_name=None)</code>","text":"<p>Launches the specified application.</p> <p>:param event_name: The event triggering the app launch, if any.</p>"},{"location":"api_reference/app_management/#optics_framework.api.app_management.AppManagement.launch_other_app","title":"<code>launch_other_app(app_name, event_name=None)</code>","text":"<p>Starts another application.</p> <p>:param package_name: The package name of the application. :param event_name: The event triggering the app start, if any.</p>"},{"location":"api_reference/app_management/#optics_framework.api.app_management.AppManagement.start_appium_session","title":"<code>start_appium_session(event_name=None)</code>","text":"<p>Starts an Appium session.</p> <p>:param event_name: The event triggering the session start, if any.</p>"},{"location":"api_reference/flow_control/","title":"Flow Control","text":"<p>The <code>FlowControl</code> class manages control flow operations including loops, conditions, and data management for test sessions.</p>"},{"location":"api_reference/flow_control/#read-data","title":"Read Data","text":"<p>The <code>read_data</code> method loads tabular data from a file path, an environment variable (using the <code>ENV:VAR_NAME</code> form), or a 2D list; applies optional query parts such as <code>select=col1,col2</code> and filter expressions; and stores the result in the session's elements. For full details on the <code>ENV:</code> prefix, query syntax (including variable resolution <code>${var}</code>), and all supported <code>file_path</code> forms, see Read Data in Keyword Usage.</p>"},{"location":"api_reference/flow_control/#optics_framework.api.flow_control.FlowControl","title":"<code>optics_framework.api.flow_control.FlowControl</code>","text":"<p>Manages control flow operations (loops, conditions, data) for a session.</p>"},{"location":"api_reference/flow_control/#optics_framework.api.flow_control.FlowControl.condition","title":"<code>condition(*args)</code>","text":"<p>Evaluates conditions and executes corresponding targets.</p>"},{"location":"api_reference/flow_control/#optics_framework.api.flow_control.FlowControl.date_evaluate","title":"<code>date_evaluate(param1, param2, param3, param4='%d %B')</code>","text":"<p>Evaluates a date expression based on an input date and stores the result in session.elements.</p> <p>Parameters:</p> Name Type Description Default <code>param1</code> <code>str</code> <p>The variable name (placeholder) where the evaluated date result will be stored.</p> required <code>param2</code> <code>str</code> <p>The input date string (e.g., \"04/25/2025\" or \"2025-04-25\"). Format is auto-detected.</p> required <code>param3</code> <code>str</code> <p>The date expression to evaluate, such as \"+1 day\", \"-2 days\", or \"today\".</p> required <code>param4</code> <code>Optional[str]</code> <p>The output format for the evaluated date (default is \"%d %B\", e.g., \"26 April\").</p> <code>'%d %B'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The resulting evaluated and formatted date string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the session is not present, the input date format cannot be detected,         or the expression format is invalid.</p> Example <p>date_evaluate(\"tomorrow\", \"04/25/2025\", \"+1 day\") \u2794 Stores \"26 April\" in session.elements[\"tomorrow\"]</p>"},{"location":"api_reference/flow_control/#optics_framework.api.flow_control.FlowControl.evaluate","title":"<code>evaluate(param1, param2)</code>","text":"<p>Evaluates an expression and stores the result in session.elements.</p>"},{"location":"api_reference/flow_control/#optics_framework.api.flow_control.FlowControl.execute_module","title":"<code>execute_module(module_name)</code>","text":"<p>Executes a module's keywords using the session's keyword_map.</p>"},{"location":"api_reference/flow_control/#optics_framework.api.flow_control.FlowControl.invoke_api","title":"<code>invoke_api(api_identifier)</code>","text":"<p>Invokes an API call based on a definition from the session's API data.</p>"},{"location":"api_reference/flow_control/#optics_framework.api.flow_control.FlowControl.read_data","title":"<code>read_data(input_element, file_path, query='')</code>","text":"<p>Reads tabular data from a CSV file, JSON file, environment variable, or a 2D list, applies optional filtering and column selection, and stores the result in the session's elements.</p> <p>Parameters:</p> Name Type Description Default <code>input_element</code> <code>str</code> <p>Variable name where the result is stored (e.g. <code>${data}</code>). Prefer <code>${name}</code> form.</p> required <code>file_path</code> <code>Union[str, List[Any]]</code> <p>Data source. One of: (1) path to a <code>.csv</code> or <code>.json</code> file; (2) string <code>ENV:VAR_NAME</code> to use an environment variable (value parsed as JSON, CSV, or plain string); (3) a 2D list with first row as headers (Python API only).</p> required <code>query</code> <code>str</code> <p>Optional semicolon-separated parts: <code>select=col1,col2</code> and/or filter expressions (pandas-style). Any <code>${varname}</code> in the query is resolved from <code>session.elements</code> before evaluation. Default <code>\"\"</code>.</p> <code>''</code> <p>Returns:</p> Type Description <code>List[Any]</code> <p>The stored value as a list (or list of lists for multi-row results). Also writes into</p> <code>List[Any]</code> <p><code>session.elements</code> under the name derived from <code>input_element</code>.</p>"},{"location":"api_reference/flow_control/#optics_framework.api.flow_control.FlowControl.run_loop","title":"<code>run_loop(target, *args)</code>","text":"<p>Runs a loop over a target module, either by count or with variables.</p>"},{"location":"api_reference/optics/","title":"Optics Class","text":"<p>The main entry point for the Optics Framework. This class provides a unified interface for both programmatic use and Robot Framework integration.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics","title":"<code>optics_framework.optics.Optics</code>","text":"<p>A lightweight interface to interact with the Optics Framework. Provides direct access to app management, action, and verification keywords with a single setup method. Supports Robot Framework as a library when Robot Framework is installed.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.__enter__","title":"<code>__enter__()</code>","text":"<p>Support for context manager to ensure cleanup.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Clean up on context exit.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.__init__","title":"<code>__init__(config=None)</code>","text":"<p>Initialize the Optics instance. Call setup() to configure the driver and sources.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.add_api","title":"<code>add_api(api_data)</code>","text":"<p>Add or update an API definition in the current session by fully replacing session.apis.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.add_element","title":"<code>add_element(name, value)</code>","text":"<p>Add or update an element in the current session.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.add_module","title":"<code>add_module(module_name, module_def)</code>","text":"<p>Add or update a module in the current session.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.add_testcase","title":"<code>add_testcase(testcase)</code>","text":"<p>Add or update a testcase in the current session.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.assert_presence","title":"<code>assert_presence(elements, timeout='60', rule='any', event_name=None)</code>","text":"<p>Assert the presence of elements.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.capture_pagesource","title":"<code>capture_pagesource()</code>","text":"<p>Capture the page source and timestamp of the current screen.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.capture_screenshot","title":"<code>capture_screenshot()</code>","text":"<p>Capture a screenshot of the current screen.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.clear_element_text","title":"<code>clear_element_text(element, event_name=None)</code>","text":"<p>Clear text from an element.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.close_and_terminate_app","title":"<code>close_and_terminate_app()</code>","text":"<p>Close and terminate an application.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.condition","title":"<code>condition(*args)</code>","text":"<p>Evaluate conditions and execute corresponding targets.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.date_evaluate","title":"<code>date_evaluate(param1, param2, param3, param4='%d %B')</code>","text":"<p>Evaluate a date expression and store the result in session elements.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.detect_and_press","title":"<code>detect_and_press(element, timeout='10', event_name=None)</code>","text":"<p>Detect and press an element.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.discover_templates","title":"<code>discover_templates(project_path)</code>","text":"<p>Discover all image templates in the project directory.</p> <p>:param project_path: The path to the project directory. :type project_path: str</p> <p>:return: TemplateData containing image name to path mappings. :rtype: TemplateData</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.enter_number","title":"<code>enter_number(element, number, event_name=None)</code>","text":"<p>Enter a number into an element.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.enter_text","title":"<code>enter_text(element, text, event_name=None)</code>","text":"<p>Enter text into an element. Supports element fallback for any param of the form ${...}.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.enter_text_direct","title":"<code>enter_text_direct(text, event_name=None)</code>","text":"<p>Enter text using the keyboard.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.enter_text_using_keyboard","title":"<code>enter_text_using_keyboard(text_input, event_name=None)</code>","text":"<p>Enter text or press a special key.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.evaluate","title":"<code>evaluate(param1, param2)</code>","text":"<p>Evaluate an expression and store the result in session elements.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.execute_script","title":"<code>execute_script(script_or_json, event_name=None)</code>","text":"<p>Execute JavaScript/script in the current context.</p> <p>:param script_or_json: The JavaScript code/script command, or a JSON string containing                        {\"script\": \"...\", \"args\": {...}} or {\"script\": \"...\"}.                        Examples:                        - \"mobile:pressKey\" (plain script)                        - '{\"script\": \"mobile:pressKey\", \"args\": {\"keycode\": 3}}' (JSON with args) :param event_name: Optional event name for tracking. :return: The result of the script execution.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.force_terminate_app","title":"<code>force_terminate_app(app_name, event_name=None)</code>","text":"<p>Forcefully terminate the specified application.</p> <p>:param app_name: The name of the application to terminate. :param event_name: The event triggering the forced termination, if any.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.get_app_version","title":"<code>get_app_version()</code>","text":"<p>Get the application version.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.get_driver_session_id","title":"<code>get_driver_session_id()</code>","text":"<p>Get the current Appium session ID for the active driver.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.get_element_value","title":"<code>get_element_value(name)</code>","text":"<p>Get the value of an element by name from the current session.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.get_interactive_elements","title":"<code>get_interactive_elements(filter_config=None)</code>","text":"<p>Get interactive elements on the screen.</p> <p>Parameters:</p> Name Type Description Default <code>filter_config</code> <code>Optional[List[str]]</code> <p>Optional list of filter types. Valid values: - \"all\": Show all elements (default when None or empty) - \"interactive\": Only interactive elements - \"buttons\": Only button elements - \"inputs\": Only input/text field elements - \"images\": Only image elements - \"text\": Only text elements Can be combined: [\"buttons\", \"inputs\"]</p> <code>None</code>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.get_text","title":"<code>get_text(element)</code>","text":"<p>Get text from an element.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.invoke_api","title":"<code>invoke_api(api)</code>","text":"<p>Invoke a REST API endpoint.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.launch_app","title":"<code>launch_app(app_identifier=None, app_activity=None, event_name=None)</code>","text":"<p>Launch the application.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.launch_other_app","title":"<code>launch_other_app(bundleid)</code>","text":"<p>Launch another application.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.press_by_coordinates","title":"<code>press_by_coordinates(coor_x, coor_y, repeat='1', event_name=None)</code>","text":"<p>Press at absolute coordinates.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.press_by_percentage","title":"<code>press_by_percentage(percent_x, percent_y, repeat='1', event_name=None)</code>","text":"<p>Press at percentage coordinates.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.press_element","title":"<code>press_element(element, repeat='1', offset_x='0', offset_y='0', index='0', aoi_x=None, aoi_y=None, aoi_width=None, aoi_height=None, event_name=None)</code>","text":"<p>Press an element with specified parameters and optional Area of Interest. Supports fallback for any param as a list or single string. All parameters: str or List[str].</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.press_element_with_index","title":"<code>press_element_with_index(element, index='0', event_name=None)</code>","text":"<p>Press an element at a specific index.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.press_keycode","title":"<code>press_keycode(keycode, event_name=None)</code>","text":"<p>Press a keycode.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.quit","title":"<code>quit()</code>","text":"<p>Clean up session resources and terminate the session.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.read_data","title":"<code>read_data(element, source, query='')</code>","text":"<p>Read data from a specified source.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.run_loop","title":"<code>run_loop(target, *args)</code>","text":"<p>Run a loop over a target module, by count or with variables.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.scroll","title":"<code>scroll(direction='down', event_name=None)</code>","text":"<p>Perform a scroll gesture.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.scroll_from_element","title":"<code>scroll_from_element(element, direction='down', scroll_length='100', event_name=None)</code>","text":"<p>Scroll starting from an element.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.scroll_until_element_appears","title":"<code>scroll_until_element_appears(element, direction='down', timeout='30', event_name=None)</code>","text":"<p>Scroll until an element appears.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.setup","title":"<code>setup(config=None, driver_sources=None, elements_sources=None, image_detection=None, text_detection=None, execution_output_path_param=None)</code>","text":"<p>Configure the Optics Framework with required driver and element source settings.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.setup_from_file","title":"<code>setup_from_file(config_file_path)</code>","text":"<p>Configure the Optics Framework from a JSON or YAML configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config_file_path</code> <code>str</code> <p>Path to the configuration file (JSON or YAML).</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be read or parsed.</p> <code>FileNotFoundError</code> <p>If the configuration file doesn't exist.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.sleep","title":"<code>sleep(duration)</code>","text":"<p>Sleep for a specified duration.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.start_appium_session","title":"<code>start_appium_session(event_name=None)</code>","text":"<p>Start an Appium session.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.swipe","title":"<code>swipe(coor_x, coor_y, direction='right', swipe_length='50', event_name=None)</code>","text":"<p>Perform a swipe gesture.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.swipe_by_percentage","title":"<code>swipe_by_percentage(percent_x, percent_y, direction='right', swipe_length='50', event_name=None)</code>","text":"<p>Swipe by percentage.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.swipe_from_element","title":"<code>swipe_from_element(element, direction='right', swipe_length='50', event_name=None)</code>","text":"<p>Swipe starting from an element.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.swipe_until_element_appears","title":"<code>swipe_until_element_appears(element, direction='down', timeout='30', event_name=None)</code>","text":"<p>Swipe until an element appears.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.validate_element","title":"<code>validate_element(element, timeout='10', rule='all', event_name=None)</code>","text":"<p>Validate an element's presence.</p>"},{"location":"api_reference/optics/#optics_framework.optics.Optics.validate_screen","title":"<code>validate_screen(elements, timeout='30', rule='any', event_name=None)</code>","text":"<p>Validate a screen by checking element presence.</p>"},{"location":"api_reference/verification/","title":"Verification","text":"<p>The <code>Verifier</code> class provides methods to verify elements, screens, and data integrity during test execution.</p>"},{"location":"api_reference/verification/#optics_framework.api.verifier.Verifier","title":"<code>optics_framework.api.verifier.Verifier</code>","text":"<p>Provides methods to verify elements, screens, and data integrity.</p>"},{"location":"api_reference/verification/#optics_framework.api.verifier.Verifier.assert_equality","title":"<code>assert_equality(output, expression, event_name=None)</code>","text":"<p>Compares two values for equality.</p> <p>:param output: The first value to be compared. :param expression: The second value to be compared. :param event_name: The name of the event associated with the comparison, if any.</p>"},{"location":"api_reference/verification/#optics_framework.api.verifier.Verifier.assert_presence","title":"<code>assert_presence(elements, timeout_str='30', rule='any', event_name=None, fail=True)</code>","text":"<p>Asserts the presence of elements.</p> <p>:param elements: Comma-separated string of elements to check (Image templates, OCR templates, or XPaths). :param timeout: The time to wait for the elements in seconds. :param rule: The rule for verification (\"any\" or \"all\"). :param event_name: The name of the event associated with the assertion, if any. :return: True if the rule is satisfied, False otherwise.</p>"},{"location":"api_reference/verification/#optics_framework.api.verifier.Verifier.capture_pagesource","title":"<code>capture_pagesource(event_name=None)</code>","text":"<p>Captures the page source and timestamp of the current screen.</p> <p>:param event_name: The name of the event associated with the page source capture, if any. :return: Dict with \"page_source\" and \"timestamp\" keys.</p>"},{"location":"api_reference/verification/#optics_framework.api.verifier.Verifier.capture_screenshot","title":"<code>capture_screenshot(event_name=None)</code>","text":"<p>Captures a screenshot of the current screen.</p> <p>:param event_name: The name of the event associated with the screenshot capture, if any. :return: The path to the captured screenshot.</p>"},{"location":"api_reference/verification/#optics_framework.api.verifier.Verifier.get_interactive_elements","title":"<code>get_interactive_elements(filter_config=None)</code>","text":"<p>Retrieves a list of interactive elements on the current screen.</p> <p>XPath and text fields are converted to one-line, CSV-friendly form (newlines as \\n, tabs as \\t, etc.) so output can be pasted into elements.csv or similar.</p> <p>:param filter_config: Optional list of filter types (e.g., [\"buttons\", \"inputs\"]). :type filter_config: Optional[List[str]] :return: A list of interactive elements.</p>"},{"location":"api_reference/verification/#optics_framework.api.verifier.Verifier.get_screen_elements","title":"<code>get_screen_elements()</code>","text":"<p>Captures a screenshot and retrieves interactive elements for API response.</p> <p>:return: Dict with base64-encoded screenshot and list of elements.</p>"},{"location":"api_reference/verification/#optics_framework.api.verifier.Verifier.is_element","title":"<code>is_element(element, element_state, timeout, event_name=None)</code>","text":"<p>Checks if the specified element is in a given state (e.g., Enabled/Disabled/Visible/Invisible).</p> <p>:param element: The element to be checked (Image template, OCR template, or XPath). :param element_state: The state to verify (visible, invisible, enabled, disabled). :param timeout: The time to wait for the element in seconds. :param event_name: The name of the event associated with the check, if any.</p>"},{"location":"api_reference/verification/#optics_framework.api.verifier.Verifier.validate_element","title":"<code>validate_element(element, timeout='10', rule='all', event_name=None)</code>","text":"<p>Verifies the specified element.</p> <p>:param element: The element to be verified (Image template, OCR template, or XPath). :param timeout: The time to wait for verification in seconds. :param rule: The rule used for verification (\"all\" or \"any\"). :param event_name: The name of the event associated with the verification, if any.</p>"},{"location":"api_reference/verification/#optics_framework.api.verifier.Verifier.validate_screen","title":"<code>validate_screen(elements, timeout='30', rule='any', event_name=None)</code>","text":"<p>Verifies the specified screen by checking element presence.</p> <p>:param elements: Comma-separated string of elements to verify (Image templates, OCR templates, or XPaths). :param timeout: The time to wait for verification in seconds. :param rule: The rule for verification (\"any\" or \"all\"). :param event_name: The name of the event associated with the verification, if any.</p>"},{"location":"architecture/api_layer/","title":"REST API Architecture","text":"<p>The Optics Framework provides a RESTful API layer built on FastAPI that enables programmatic access to framework functionality. This document explains the API architecture, request/response flows, and integration with the core framework.</p>"},{"location":"architecture/api_layer/#overview","title":"Overview","text":"<p>The REST API layer provides:</p> <ol> <li>Session Management - Create, manage, and terminate sessions</li> <li>Keyword Execution - Execute keywords programmatically</li> <li>Workspace Streaming - Real-time workspace updates via SSE</li> <li>Event Streaming - Real-time execution events via SSE</li> <li>Workspace Inspection - Get screenshots, elements, and page source</li> </ol>"},{"location":"architecture/api_layer/#api-architecture","title":"API Architecture","text":"<pre><code>graph TB\n    A[Client] --&gt; B[FastAPI Server]\n    B --&gt; C[Session Manager]\n    B --&gt; D[Execution Engine]\n    B --&gt; E[Event Manager]\n    C --&gt; F[Session Storage]\n    D --&gt; G[Keyword Registry]\n    D --&gt; H[Test Runner]\n    E --&gt; I[Event Queue]\n    B --&gt; J[SSE Streams]\n    J --&gt; K[Workspace Stream]\n    J --&gt; L[Event Stream]</code></pre> <p>Location: <code>optics_framework/common/expose_api.py</code></p>"},{"location":"architecture/api_layer/#api-server","title":"API Server","text":"<p>The API server is built using FastAPI:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI(title=\"Optics Framework API\", version=\"1.0\")\n\n# CORS configuration\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n</code></pre>"},{"location":"architecture/api_layer/#server-startup","title":"Server Startup","text":"<p>The API server can be started using the CLI:</p> <pre><code>optics serve --host 0.0.0.0 --port 8000\n</code></pre> <p>Or programmatically:</p> <pre><code>from optics_framework.helper.serve import run_uvicorn_server\n\nrun_uvicorn_server(host=\"0.0.0.0\", port=8000, workers=1)\n</code></pre>"},{"location":"architecture/api_layer/#requestresponse-flow","title":"Request/Response Flow","text":""},{"location":"architecture/api_layer/#session-creation-flow","title":"Session Creation Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant API\n    participant SessionMgr\n    participant Builder\n    participant Driver\n\n    Client-&gt;&gt;API: POST /v1/sessions/start\n    API-&gt;&gt;API: Normalize config\n    API-&gt;&gt;SessionMgr: create_session(config)\n    SessionMgr-&gt;&gt;Builder: Build components\n    Builder-&gt;&gt;Driver: Initialize driver\n    Driver--&gt;&gt;Builder: Driver ready\n    Builder--&gt;&gt;SessionMgr: Session created\n    SessionMgr--&gt;&gt;API: session_id\n    API-&gt;&gt;API: Execute launch_app\n    API--&gt;&gt;Client: SessionResponse</code></pre>"},{"location":"architecture/api_layer/#keyword-execution-flow","title":"Keyword Execution Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant API\n    participant Engine\n    participant Registry\n    participant Keyword\n    participant Driver\n\n    Client-&gt;&gt;API: POST /v1/sessions/{id}/action\n    API-&gt;&gt;API: Resolve parameters\n    API-&gt;&gt;Engine: execute_keyword()\n    Engine-&gt;&gt;Registry: Get keyword method\n    Registry--&gt;&gt;Engine: method\n    Engine-&gt;&gt;Keyword: Execute with params\n    Keyword-&gt;&gt;Driver: Perform action\n    Driver--&gt;&gt;Keyword: Result\n    Keyword--&gt;&gt;Engine: Result\n    Engine--&gt;&gt;API: ExecutionResponse\n    API--&gt;&gt;Client: JSON Response</code></pre>"},{"location":"architecture/api_layer/#session-management","title":"Session Management","text":""},{"location":"architecture/api_layer/#session-creation","title":"Session Creation","text":"<p>Endpoint: <code>POST /v1/sessions/start</code></p> <p>Request Body: <pre><code>{\n  \"driver_sources\": [{\"appium\": {\"enabled\": true, \"url\": \"...\", \"capabilities\": {...}}}],\n  \"elements_sources\": [{\"appium\": {\"enabled\": true}}],\n  \"text_detection\": [{\"easyocr\": {\"enabled\": true}}],\n  \"image_detection\": [{\"templatematch\": {\"enabled\": true}}],\n  \"project_path\": \"/path/to/project\"\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"session_id\": \"uuid-string\",\n  \"driver_id\": \"driver-session-id\",\n  \"status\": \"created\"\n}\n</code></pre></p> <p>Implementation Details:</p> <ol> <li>Configuration Normalization: Converts various input formats to internal format</li> <li>Session Creation: Creates session with normalized configuration</li> <li>Auto-Launch: Automatically executes <code>launch_app</code> keyword</li> <li>Logging Configuration: Reconfigures logging for the session</li> </ol>"},{"location":"architecture/api_layer/#session-termination","title":"Session Termination","text":"<p>Endpoint: <code>DELETE /v1/sessions/{session_id}/stop</code></p> <p>Response: <pre><code>{\n  \"status\": \"terminated\"\n}\n</code></pre></p> <p>Implementation Details:</p> <ol> <li>Retrieves session from SessionManager</li> <li>Terminates driver connection</li> <li>Cleans up session resources</li> <li>Removes session from storage</li> </ol>"},{"location":"architecture/api_layer/#keyword-execution","title":"Keyword Execution","text":""},{"location":"architecture/api_layer/#execute-keyword","title":"Execute Keyword","text":"<p>Endpoint: <code>POST /v1/sessions/{session_id}/action</code></p> <p>Request Body: <pre><code>{\n  \"mode\": \"keyword\",\n  \"keyword\": \"Press Element\",\n  \"params\": [\"submit_button\"]\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"execution_id\": \"uuid-string\",\n  \"status\": \"SUCCESS\",\n  \"data\": {\n    \"result\": \"action completed\"\n  }\n}\n</code></pre></p>"},{"location":"architecture/api_layer/#parameter-formats","title":"Parameter Formats","text":"<p>The API supports multiple parameter formats:</p>"},{"location":"architecture/api_layer/#positional-parameters","title":"Positional Parameters","text":"<pre><code>{\n  \"params\": [\"element_id\", \"30\", \"button_clicked\"]\n}\n</code></pre>"},{"location":"architecture/api_layer/#named-parameters","title":"Named Parameters","text":"<pre><code>{\n  \"params\": {\n    \"element\": \"submit_button\",\n    \"timeout\": \"30\",\n    \"event_name\": \"button_clicked\"\n  }\n}\n</code></pre>"},{"location":"architecture/api_layer/#fallback-parameters","title":"Fallback Parameters","text":"<pre><code>{\n  \"params\": [\"value1\", \"value2\", \"value3\"]\n}\n</code></pre> <p>Or nested fallbacks: <pre><code>{\n  \"params\": [[\"value1a\", \"value1b\"], \"value2\"]\n}\n</code></pre></p>"},{"location":"architecture/api_layer/#parameter-resolution","title":"Parameter Resolution","text":"<p>The API automatically:</p> <ol> <li>Detects Format: Determines if params are positional, named, or fallback</li> <li>Normalizes Values: Converts all values to lists for fallback support</li> <li>Resolves Named Params: Converts named params to positional based on method signature</li> <li>Generates Combinations: Creates all fallback combinations using <code>itertools.product</code></li> <li>Tries Each Combination: Executes until one succeeds or all fail</li> </ol>"},{"location":"architecture/api_layer/#fallback-execution","title":"Fallback Execution","text":"<pre><code># Generate all combinations\ncombinations = list(product(*normalized_param_lists))\n\n# Try each combination\nfor combo in combinations:\n    try:\n        result = execute_keyword(keyword, combo)\n        return result  # Success\n    except Exception:\n        continue  # Try next combination\n\n# All failed\nraise RuntimeError(\"All fallback attempts failed\")\n</code></pre>"},{"location":"architecture/api_layer/#server-sent-events-sse","title":"Server-Sent Events (SSE)","text":"<p>The API uses Server-Sent Events for real-time streaming.</p>"},{"location":"architecture/api_layer/#event-streaming","title":"Event Streaming","text":"<p>Endpoint: <code>GET /v1/sessions/{session_id}/events</code></p> <p>Response: SSE stream of execution events</p> <p>Event Format: <pre><code>{\n  \"execution_id\": \"uuid-string\",\n  \"status\": \"RUNNING|SUCCESS|FAIL|HEARTBEAT\",\n  \"message\": \"Event message\"\n}\n</code></pre></p> <p>Implementation:</p> <pre><code>async def event_generator(session: Session):\n    HEARTBEAT_INTERVAL = 15  # seconds\n    while True:\n        try:\n            event = await asyncio.wait_for(\n                session.event_queue.get(),\n                timeout=HEARTBEAT_INTERVAL\n            )\n            yield {\"data\": json.dumps(event)}\n        except asyncio.TimeoutError:\n            # Send heartbeat\n            yield {\"data\": json.dumps({\n                \"execution_id\": \"heartbeat\",\n                \"status\": \"HEARTBEAT\"\n            })}\n</code></pre>"},{"location":"architecture/api_layer/#workspace-streaming","title":"Workspace Streaming","text":"<p>Endpoint: <code>GET /v1/sessions/{session_id}/workspace/stream</code></p> <p>Query Parameters: - <code>interval_ms</code> (int, default: 2000): Polling interval (minimum 500ms) - <code>include_source</code> (bool, default: false): Include page source - <code>filter_config</code> (List[str], optional): Filter element types</p> <p>Response: SSE stream of workspace updates</p> <p>Workspace Data Format: <pre><code>{\n  \"screenshot\": \"base64-encoded-image\",\n  \"elements\": [...],\n  \"source\": \"...\" // if include_source=true\n}\n</code></pre></p> <p>Change Detection:</p> <p>The API only emits updates when workspace data changes:</p> <pre><code># Compute hash of current workspace\ncurrent_hash = _compute_workspace_hash(workspace_data)\nlast_hash = workspace_hashes.get(session_id)\n\n# Only emit if changed\nif current_hash != last_hash:\n    workspace_hashes[session_id] = current_hash\n    yield {\"data\": json.dumps(workspace_data)}\nelse:\n    # Send heartbeat if no change\n    yield {\"data\": json.dumps({\"type\": \"heartbeat\"})}\n</code></pre> <p>Benefits: - Reduces network traffic - Lowers driver load - Provides efficient real-time updates</p>"},{"location":"architecture/api_layer/#workspace-inspection","title":"Workspace Inspection","text":""},{"location":"architecture/api_layer/#get-screenshot","title":"Get Screenshot","text":"<p>Endpoint: <code>GET /v1/sessions/{session_id}/screenshot</code></p> <p>Response: <pre><code>{\n  \"execution_id\": \"uuid-string\",\n  \"status\": \"SUCCESS\",\n  \"data\": {\n    \"result\": \"base64-encoded-image\"\n  }\n}\n</code></pre></p>"},{"location":"architecture/api_layer/#get-page-source","title":"Get Page Source","text":"<p>Endpoint: <code>GET /v1/sessions/{session_id}/source</code></p> <p>Response: <pre><code>{\n  \"execution_id\": \"uuid-string\",\n  \"status\": \"SUCCESS\",\n  \"data\": {\n    \"result\": \"&lt;html&gt;...&lt;/html&gt;\"\n  }\n}\n</code></pre></p>"},{"location":"architecture/api_layer/#get-screen-elements","title":"Get Screen Elements","text":"<p>Endpoint: <code>GET /v1/sessions/{session_id}/screen_elements</code></p> <p>Query Parameters: - <code>filter_config</code> (List[str], optional): Filter types (all, interactive, buttons, inputs, images, text)</p> <p>Response: <pre><code>{\n  \"execution_id\": \"uuid-string\",\n  \"status\": \"SUCCESS\",\n  \"data\": {\n    \"result\": [\n      {\n        \"type\": \"button\",\n        \"text\": \"Submit\",\n        \"bounds\": {...},\n        \"clickable\": true\n      }\n    ]\n  }\n}\n</code></pre></p>"},{"location":"architecture/api_layer/#error-handling","title":"Error Handling","text":""},{"location":"architecture/api_layer/#error-response-format","title":"Error Response Format","text":"<p>The API converts <code>OpticsError</code> to HTTP responses:</p> <pre><code>try:\n    result = execute_keyword(keyword, params)\nexcept OpticsError as e:\n    raise HTTPException(\n        status_code=e.status_code,\n        detail=e.to_payload(include_status=True)\n    )\n</code></pre>"},{"location":"architecture/api_layer/#error-response-structure","title":"Error Response Structure","text":"<pre><code>{\n  \"detail\": {\n    \"type\": \"optics:driver\",\n    \"code\": \"E0101\",\n    \"status\": 500,\n    \"message\": \"Driver not initialized\",\n    \"details\": {\n      \"driver\": \"appium\",\n      \"session_id\": \"abc123\"\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/api_layer/#common-error-codes","title":"Common Error Codes","text":"<ul> <li>404: Session not found, keyword not found</li> <li>400: Invalid parameters, configuration error</li> <li>500: Driver error, execution error</li> <li>504: Timeout errors</li> </ul> <p>See Error Handling for complete error code reference.</p>"},{"location":"architecture/api_layer/#keyword-discovery","title":"Keyword Discovery","text":""},{"location":"architecture/api_layer/#list-keywords","title":"List Keywords","text":"<p>Endpoint: <code>GET /v1/keywords</code></p> <p>Response: <pre><code>[\n  {\n    \"keyword\": \"Press Element\",\n    \"keyword_slug\": \"press_element\",\n    \"description\": \"Taps on a given element...\",\n    \"parameters\": [\n      {\n        \"name\": \"element\",\n        \"type\": \"str\",\n        \"default\": null\n      }\n    ]\n  }\n]\n</code></pre></p> <p>Implementation:</p> <p>The API discovers keywords by:</p> <ol> <li>Scanning <code>optics_framework.api</code> package</li> <li>Extracting public methods from API classes</li> <li>Inspecting method signatures for parameters</li> <li>Extracting docstrings for descriptions</li> </ol> <pre><code>def discover_keywords() -&gt; List[KeywordInfo]:\n    api_pkg = \"optics_framework.api\"\n    keywords = []\n    for module in api_modules:\n        for cls in module_classes:\n            for method in public_methods(cls):\n                keywords.append(KeywordInfo(\n                    keyword=_humanize_keyword(method_name),\n                    keyword_slug=method_name,\n                    description=method.__doc__,\n                    parameters=_get_keyword_parameters(method)\n                ))\n    return keywords\n</code></pre>"},{"location":"architecture/api_layer/#configuration-normalization","title":"Configuration Normalization","text":"<p>The API normalizes various configuration formats to a consistent internal format.</p>"},{"location":"architecture/api_layer/#supported-formats","title":"Supported Formats","text":""},{"location":"architecture/api_layer/#simple-string-list","title":"Simple String List","text":"<pre><code>{\n  \"driver_sources\": [\"appium\", \"selenium\"]\n}\n</code></pre>"},{"location":"architecture/api_layer/#detailed-dictionary","title":"Detailed Dictionary","text":"<pre><code>{\n  \"driver_sources\": [\n    {\n      \"appium\": {\n        \"enabled\": true,\n        \"url\": \"http://localhost:4723\",\n        \"capabilities\": {\n          \"platformName\": \"Android\"\n        }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"architecture/api_layer/#deprecated-format-with-warnings","title":"Deprecated Format (with warnings)","text":"<pre><code>{\n  \"appium_url\": \"http://localhost:4723\",\n  \"appium_config\": {\n    \"capabilities\": {...}\n  }\n}\n</code></pre>"},{"location":"architecture/api_layer/#normalization-process","title":"Normalization Process","text":"<pre><code>def normalize_sources(self) -&gt; Dict[str, List[Dict[str, DependencyConfig]]]:\n    driver = [\n        self._normalize_item(i, top_level_url=self.appium_url)\n        for i in self.driver_sources\n    ]\n    # ... normalize other sources\n    return {\n        \"driver_sources\": driver,\n        \"elements_sources\": elements,\n        \"text_detection\": text,\n        \"image_detection\": image\n    }\n</code></pre>"},{"location":"architecture/api_layer/#integration-with-core-framework","title":"Integration with Core Framework","text":""},{"location":"architecture/api_layer/#session-manager-integration","title":"Session Manager Integration","text":"<pre><code>session_manager = SessionManager()\n\n@app.post(\"/v1/sessions/start\")\nasync def create_session(config: SessionConfig):\n    session_id = session_manager.create_session(\n        session_config,\n        test_cases=None,\n        modules=None\n    )\n    return SessionResponse(session_id=session_id)\n</code></pre>"},{"location":"architecture/api_layer/#execution-engine-integration","title":"Execution Engine Integration","text":"<pre><code>execution_engine = ExecutionEngine()\n\nasync def execute_keyword(session_id: str, request: ExecuteRequest):\n    params = ExecutionParams(\n        session_id=session_id,\n        mode=\"keyword\",\n        keyword=request.keyword,\n        params=request.params\n    )\n    result = await execution_engine.execute(params)\n    return ExecutionResponse(\n        execution_id=str(uuid4()),\n        status=\"SUCCESS\",\n        data={\"result\": result}\n    )\n</code></pre>"},{"location":"architecture/api_layer/#event-manager-integration","title":"Event Manager Integration","text":"<pre><code>@app.get(\"/v1/sessions/{session_id}/events\")\nasync def stream_events(session_id: str):\n    session = session_manager.get_session(session_id)\n    event_manager = get_event_manager(session_id)\n    return EventSourceResponse(event_generator(session))\n</code></pre>"},{"location":"architecture/api_layer/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/api_layer/#1-connection-pooling","title":"1. Connection Pooling","text":"<ul> <li>Sessions reuse driver connections</li> <li>Multiple API requests share the same session</li> <li>Driver connections persist until session termination</li> </ul>"},{"location":"architecture/api_layer/#2-streaming-efficiency","title":"2. Streaming Efficiency","text":"<ul> <li>Workspace streaming only emits on changes</li> <li>Heartbeat mechanism prevents connection timeouts</li> <li>Configurable polling intervals</li> </ul>"},{"location":"architecture/api_layer/#3-parameter-resolution","title":"3. Parameter Resolution","text":"<ul> <li>Named parameter resolution is cached</li> <li>Fallback combinations generated lazily</li> <li>Early exit on first successful execution</li> </ul>"},{"location":"architecture/api_layer/#4-error-handling","title":"4. Error Handling","text":"<ul> <li>Errors are caught and converted to HTTP responses</li> <li>No exception propagation to client</li> <li>Structured error responses for debugging</li> </ul>"},{"location":"architecture/api_layer/#security-considerations","title":"Security Considerations","text":""},{"location":"architecture/api_layer/#cors-configuration","title":"CORS Configuration","text":"<p>Currently, CORS is enabled for all origins:</p> <pre><code>app.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # Consider restricting in production\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n</code></pre> <p>Recommendation: Restrict CORS in production environments.</p>"},{"location":"architecture/api_layer/#authentication","title":"Authentication","text":"<p>Currently, the API does not require authentication. Consider adding:</p> <ul> <li>API key authentication</li> <li>Bearer token authentication</li> <li>Session-based authentication</li> </ul>"},{"location":"architecture/api_layer/#input-validation","title":"Input Validation","text":"<ul> <li>Pydantic models validate all inputs</li> <li>Parameter types are checked</li> <li>Configuration is normalized and validated</li> </ul>"},{"location":"architecture/api_layer/#best-practices","title":"Best Practices","text":""},{"location":"architecture/api_layer/#1-session-management","title":"1. Session Management","text":"<ul> <li>Create sessions for logical test groups</li> <li>Terminate sessions when done</li> <li>Reuse sessions for multiple operations</li> </ul>"},{"location":"architecture/api_layer/#2-error-handling","title":"2. Error Handling","text":"<ul> <li>Check response status codes</li> <li>Handle OpticsError responses</li> <li>Implement retry logic for transient errors</li> </ul>"},{"location":"architecture/api_layer/#3-streaming","title":"3. Streaming","text":"<ul> <li>Use appropriate polling intervals</li> <li>Handle heartbeat events</li> <li>Implement reconnection logic</li> </ul>"},{"location":"architecture/api_layer/#4-parameter-passing","title":"4. Parameter Passing","text":"<ul> <li>Use named parameters for clarity</li> <li>Leverage fallback parameters for resilience</li> <li>Validate parameters before sending</li> </ul>"},{"location":"architecture/api_layer/#troubleshooting","title":"Troubleshooting","text":""},{"location":"architecture/api_layer/#session-not-found","title":"Session Not Found","text":"<p>Problem: 404 error when accessing session endpoints.</p> <p>Solutions:</p> <ol> <li>Verify session ID is correct</li> <li>Check session hasn't been terminated</li> <li>Ensure session was created successfully</li> </ol>"},{"location":"architecture/api_layer/#keyword-execution-fails","title":"Keyword Execution Fails","text":"<p>Problem: Keyword execution returns error.</p> <p>Solutions:</p> <ol> <li>Check keyword name is correct</li> <li>Verify parameters match method signature</li> <li>Review error details in response</li> <li>Check driver is properly initialized</li> </ol>"},{"location":"architecture/api_layer/#streaming-issues","title":"Streaming Issues","text":"<p>Problem: SSE stream disconnects or doesn't emit.</p> <p>Solutions:</p> <ol> <li>Check session is still active</li> <li>Verify network connectivity</li> <li>Review server logs for errors</li> <li>Ensure proper SSE client implementation</li> </ol>"},{"location":"architecture/api_layer/#related-documentation","title":"Related Documentation","text":"<ul> <li>REST API Usage - Complete REST API endpoint reference</li> <li>API Reference - Python API documentation</li> <li>Session Management - Session lifecycle</li> <li>Execution - Execution engine details</li> <li>Error Handling - Error codes and handling</li> <li>Fallback Parameters - Fallback parameter system</li> <li>Keyword Registry - Keyword registration</li> <li>Architecture Decisions - API design decisions</li> </ul>"},{"location":"architecture/cli_layer/","title":"CLI Layer Architecture","text":"<p>The Optics Framework provides a command-line interface (CLI) that enables users to interact with the framework without writing code. This document explains the CLI architecture, command structure, and how commands integrate with the core framework.</p>"},{"location":"architecture/cli_layer/#overview","title":"Overview","text":"<p>The CLI layer provides:</p> <ol> <li>Project Management - Initialize and manage test projects</li> <li>Test Execution - Execute and validate test cases</li> <li>Driver Setup - Install and configure drivers</li> <li>Code Generation - Generate test framework code</li> <li>API Server - Start the REST API server</li> <li>Configuration - Manage framework configuration</li> </ol>"},{"location":"architecture/cli_layer/#cli-architecture","title":"CLI Architecture","text":"<pre><code>graph TB\n    A[User] --&gt; B[CLI Entry Point]\n    B --&gt; C[Command Parser]\n    C --&gt; D[Command Registry]\n    D --&gt; E[Command Execution]\n    E --&gt; F[Helper Modules]\n    F --&gt; G[Core Framework]\n\n    D --&gt; H[Init Command]\n    D --&gt; I[Execute Command]\n    D --&gt; J[Setup Command]\n    D --&gt; K[Generate Command]\n    D --&gt; L[Server Command]\n    D --&gt; M[Config Command]</code></pre> <p>Location: <code>optics_framework/helper/cli.py</code></p>"},{"location":"architecture/cli_layer/#command-structure","title":"Command Structure","text":"<p>The CLI follows a command-based architecture where each command is a self-contained unit that:</p> <ul> <li>Registers itself with the argument parser</li> <li>Defines its arguments and options</li> <li>Executes its functionality when invoked</li> <li>Integrates with helper modules and the core framework</li> </ul> <p>All commands follow a consistent pattern: registration, argument parsing, validation, and execution.</p>"},{"location":"architecture/cli_layer/#available-commands","title":"Available Commands","text":""},{"location":"architecture/cli_layer/#1-init-command","title":"1. Init Command","text":"<p>Command: <code>optics init</code></p> <p>Purpose: Initialize a new test project</p> <p>Usage: <pre><code>optics init --name my_project --path ./tests --template contact --git-init\n</code></pre></p> <p>Arguments:</p> <ul> <li><code>--name</code> (required): Project name</li> <li><code>--path</code> (optional): Directory where project will be created</li> <li><code>--template</code> (optional): Project template to use</li> <li><code>--force</code> (flag): Override if project exists</li> <li><code>--git-init</code> (flag): Initialize git repository</li> </ul> <p>Flow:</p> <pre><code>sequenceDiagram\n    participant User\n    participant CLI\n    participant InitHelper\n    participant FileSystem\n\n    User-&gt;&gt;CLI: optics init --name project\n    CLI-&gt;&gt;InitHelper: create_project(args)\n    InitHelper-&gt;&gt;FileSystem: Create project structure\n    InitHelper-&gt;&gt;FileSystem: Copy template files\n    InitHelper-&gt;&gt;FileSystem: Initialize git (if requested)\n    InitHelper--&gt;&gt;CLI: Project created\n    CLI--&gt;&gt;User: Success message</code></pre>"},{"location":"architecture/cli_layer/#2-execute-command","title":"2. Execute Command","text":"<p>Command: <code>optics execute</code></p> <p>Purpose: Execute test cases from a project</p> <p>Usage: <pre><code>optics execute ./my_project --runner test_runner --use-printer\n</code></pre></p> <p>Arguments:</p> <ul> <li><code>folder_path</code> (required): Path to project folder</li> <li><code>--runner</code> (optional): Test runner to use (default: test_runner)</li> <li><code>--use-printer</code> / <code>--no-use-printer</code>: Enable/disable live result printer</li> </ul> <p>Flow:</p> <pre><code>sequenceDiagram\n    participant User\n    participant CLI\n    participant ExecuteHelper\n    participant ConfigHandler\n    participant ExecutionEngine\n\n    User-&gt;&gt;CLI: optics execute ./project\n    CLI-&gt;&gt;ExecuteHelper: execute_main(folder_path)\n    ExecuteHelper-&gt;&gt;ConfigHandler: Load configuration\n    ExecuteHelper-&gt;&gt;ExecuteHelper: Load test cases\n    ExecuteHelper-&gt;&gt;ExecutionEngine: Execute tests\n    ExecutionEngine--&gt;&gt;ExecuteHelper: Results\n    ExecuteHelper--&gt;&gt;CLI: Execution complete\n    CLI--&gt;&gt;User: Results displayed</code></pre>"},{"location":"architecture/cli_layer/#3-dry-run-command","title":"3. Dry Run Command","text":"<p>Command: <code>optics dry_run</code></p> <p>Purpose: Validate test cases without executing actions</p> <p>Usage: <pre><code>optics dry_run ./my_project --runner test_runner\n</code></pre></p> <p>Arguments:</p> <ul> <li><code>folder_path</code> (required): Path to project folder</li> <li><code>--runner</code> (optional): Test runner to use</li> <li><code>--use-printer</code> / <code>--no-use-printer</code>: Enable/disable result printer</li> </ul> <p>Behavior: Similar to ExecuteCommand but validates test cases without performing actual actions, useful for syntax checking and validation.</p>"},{"location":"architecture/cli_layer/#4-setup-command","title":"4. Setup Command","text":"<p>Command: <code>optics setup</code></p> <p>Purpose: Install and configure drivers</p> <p>Usage: <pre><code>optics setup --install Appium EasyOCR\noptics setup --list\n</code></pre></p> <p>Arguments:</p> <ul> <li><code>--install</code> (list): Drivers to install</li> <li><code>--list</code> (flag): List available drivers</li> </ul> <p>Modes: - Interactive Mode: Launches a TUI (Text User Interface) for driver selection - List Mode: Displays all available drivers - Install Mode: Installs specified drivers via package manager</p> <p>Available Drivers: - Appium - Selenium - Playwright - EasyOCR - GoogleVision - PyTesseract - TemplateMatch - RemoteOIR - RemoteOCR</p>"},{"location":"architecture/cli_layer/#5-generate-command","title":"5. Generate Command","text":"<p>Command: <code>optics generate</code></p> <p>Purpose: Generate test framework code from project</p> <p>Usage: <pre><code>optics generate ./my_project --framework pytest --output test_generated.py\n</code></pre></p> <p>Arguments:</p> <ul> <li><code>project_path</code> (required): Path to project</li> <li><code>--framework</code> (optional): Framework to use (pytest, robot)</li> <li><code>--output</code> (optional): Output file path</li> </ul> <p>Behavior: Reads test cases, modules, and configuration from the project and generates executable test code in the specified framework format.</p>"},{"location":"architecture/cli_layer/#6-server-command","title":"6. Server Command","text":"<p>Command: <code>optics serve</code></p> <p>Purpose: Start the REST API server</p> <p>Usage: <pre><code>optics serve --host 0.0.0.0 --port 8000 --workers 1\n</code></pre></p> <p>Arguments:</p> <ul> <li><code>--host</code> (optional): Host to bind (default: 127.0.0.1)</li> <li><code>--port</code> (optional): Port to bind (default: 8000)</li> <li><code>--workers</code> (optional): Number of worker processes (default: 1)</li> </ul> <p>Behavior: Starts a FastAPI server that exposes the framework functionality via REST API endpoints.</p>"},{"location":"architecture/cli_layer/#7-list-command","title":"7. List Command","text":"<p>Command: <code>optics list</code></p> <p>Purpose: List all available keywords</p> <p>Usage: <pre><code>optics list\n</code></pre></p> <p>Behavior: Scans the framework API package and displays all available keywords that can be used in test cases, along with their parameters and descriptions.</p>"},{"location":"architecture/cli_layer/#8-config-command","title":"8. Config Command","text":"<p>Command: <code>optics config</code></p> <p>Purpose: Manage framework configuration</p> <p>Usage: <pre><code>optics config\n</code></pre></p> <p>Behavior: Launches an interactive configuration manager that allows users to view, edit, and validate framework configuration files.</p>"},{"location":"architecture/cli_layer/#9-completion-command","title":"9. Completion Command","text":"<p>Command: <code>optics completion</code></p> <p>Purpose: Enable shell autocompletion</p> <p>Usage: <pre><code>optics completion\n</code></pre></p> <p>Behavior: Updates shell RC files (<code>.bashrc</code>, <code>.zshrc</code>) to enable command and argument autocompletion for the CLI.</p>"},{"location":"architecture/cli_layer/#helper-modules","title":"Helper Modules","text":"<p>The CLI layer delegates complex operations to helper modules that encapsulate specific functionality:</p>"},{"location":"architecture/cli_layer/#execute-helper","title":"Execute Helper","text":"<p>Location: <code>optics_framework/helper/execute.py</code></p> <p>Responsibilities:</p> <ul> <li>Loads configuration and test cases from project</li> <li>Creates and manages test sessions</li> <li>Executes tests via ExecutionEngine</li> <li>Manages live result printing and output formatting</li> </ul>"},{"location":"architecture/cli_layer/#initialize-helper","title":"Initialize Helper","text":"<p>Location: <code>optics_framework/helper/initialize.py</code></p> <p>Responsibilities:</p> <ul> <li>Creates project directory structure</li> <li>Copies template files and configurations</li> <li>Initializes git repository (optional)</li> <li>Sets up initial configuration files</li> </ul>"},{"location":"architecture/cli_layer/#generate-helper","title":"Generate Helper","text":"<p>Location: <code>optics_framework/helper/generate.py</code></p> <p>Responsibilities:</p> <ul> <li>Reads test cases, modules, and elements from project</li> <li>Converts project structure to target framework format (pytest/Robot Framework)</li> <li>Generates executable test code</li> <li>Writes generated code to output file</li> </ul>"},{"location":"architecture/cli_layer/#setup-helper","title":"Setup Helper","text":"<p>Location: <code>optics_framework/helper/setup.py</code></p> <p>Responsibilities:</p> <ul> <li>Lists available drivers and their dependencies</li> <li>Installs driver packages via package manager</li> <li>Provides interactive TUI for driver selection</li> <li>Validates driver installations</li> </ul>"},{"location":"architecture/cli_layer/#config-manager","title":"Config Manager","text":"<p>Location: <code>optics_framework/helper/config_manager.py</code></p> <p>Responsibilities:</p> <ul> <li>Interactive configuration file editor</li> <li>Configuration validation and error checking</li> <li>Configuration file management (create, read, update)</li> <li>Configuration template generation</li> </ul>"},{"location":"architecture/cli_layer/#serve-helper","title":"Serve Helper","text":"<p>Location: <code>optics_framework/helper/serve.py</code></p> <p>Responsibilities:</p> <ul> <li>Configures and starts Uvicorn server</li> <li>Sets up FastAPI application with routes</li> <li>Manages server lifecycle (start, stop, restart)</li> <li>Handles server configuration and logging</li> </ul>"},{"location":"architecture/cli_layer/#error-handling","title":"Error Handling","text":"<p>The CLI includes comprehensive error handling with appropriate exit codes:</p> <p>Exit Codes: - <code>0</code>: Success - <code>1</code>: Unexpected error - <code>2</code>: Argument error - <code>3</code>: Value error - <code>130</code>: User cancellation (Ctrl+C)</p> <p>Error handling covers:</p> <ul> <li>User input validation</li> <li>Configuration errors</li> <li>Execution failures</li> <li>Resource errors</li> <li>User interruptions</li> </ul>"},{"location":"architecture/cli_layer/#integration-with-core-framework","title":"Integration with Core Framework","text":""},{"location":"architecture/cli_layer/#session-creation","title":"Session Creation","text":"<p>CLI commands that execute tests create sessions through the <code>SessionManager</code>. The session encapsulates all test execution state, including configuration, test cases, and component instances.</p>"},{"location":"architecture/cli_layer/#execution","title":"Execution","text":"<p>Test execution commands use the <code>ExecutionEngine</code> to orchestrate test runs. The engine handles test case parsing, keyword execution, result collection, and event publishing.</p>"},{"location":"architecture/cli_layer/#configuration-loading","title":"Configuration Loading","text":"<p>Commands load configuration through <code>ConfigHandler</code>, which supports hierarchical configuration (default, global, project) with proper precedence and merging.</p>"},{"location":"architecture/cli_layer/#command-execution-flow","title":"Command Execution Flow","text":"<pre><code>graph TB\n    A[User Input] --&gt; B[Parse Arguments]\n    B --&gt; C{Command Type}\n    C --&gt;|Init| D[Create Project]\n    C --&gt;|Execute| E[Load Config]\n    C --&gt;|Setup| F[Install Drivers]\n    C --&gt;|Generate| G[Generate Code]\n    C --&gt;|Serve| H[Start Server]\n    E --&gt; I[Create Session]\n    I --&gt; J[Execute Tests]\n    J --&gt; K[Display Results]\n    D --&gt; L[Project Ready]\n    F --&gt; M[Drivers Installed]\n    G --&gt; N[Code Generated]\n    H --&gt; O[Server Running]</code></pre>"},{"location":"architecture/cli_layer/#best-practices","title":"Best Practices","text":""},{"location":"architecture/cli_layer/#1-command-design","title":"1. Command Design","text":"<ul> <li>Use descriptive command names that clearly indicate purpose</li> <li>Provide clear help text and documentation</li> <li>Validate arguments early in the execution flow</li> <li>Use structured models for argument validation</li> </ul>"},{"location":"architecture/cli_layer/#2-error-messages","title":"2. Error Messages","text":"<ul> <li>Provide clear, actionable error messages</li> <li>Include suggestions for fixing common errors</li> <li>Use appropriate exit codes for different error types</li> <li>Log detailed errors for debugging while showing user-friendly messages</li> </ul>"},{"location":"architecture/cli_layer/#3-user-experience","title":"3. User Experience","text":"<ul> <li>Provide progress indicators for long-running operations</li> <li>Use consistent output formatting across commands</li> <li>Support both interactive and non-interactive modes</li> <li>Offer helpful suggestions when commands fail</li> </ul>"},{"location":"architecture/cli_layer/#4-integration","title":"4. Integration","text":"<ul> <li>Reuse core framework components rather than duplicating logic</li> <li>Delegate complex operations to helper modules</li> <li>Maintain clear separation between CLI layer and core framework</li> <li>Use helper modules for operations that require multiple framework components</li> </ul>"},{"location":"architecture/cli_layer/#extending-the-cli","title":"Extending the CLI","text":"<p>To add a new command:</p> <ol> <li>Create Command Class: Define a command class that registers arguments and implements execution logic</li> <li>Register Command: Add the command to the command registry in the main CLI entry point</li> <li>Create Helper Module (if needed): For complex operations, create a helper module that encapsulates the functionality</li> </ol> <p>The CLI architecture is designed to be extensible, allowing new commands to be added without modifying existing code.</p>"},{"location":"architecture/cli_layer/#troubleshooting","title":"Troubleshooting","text":""},{"location":"architecture/cli_layer/#command-not-found","title":"Command Not Found","text":"<p>Problem: Command not recognized</p> <p>Solutions:</p> <ol> <li>Verify command is registered in the CLI entry point</li> <li>Check command name spelling</li> <li>Verify CLI installation is complete</li> </ol>"},{"location":"architecture/cli_layer/#argument-errors","title":"Argument Errors","text":"<p>Problem: Invalid arguments</p> <p>Solutions:</p> <ol> <li>Check argument names and types</li> <li>Review command help: <code>optics &lt;command&gt; --help</code></li> <li>Verify required arguments are provided</li> </ol>"},{"location":"architecture/cli_layer/#execution-failures","title":"Execution Failures","text":"<p>Problem: Command execution fails</p> <p>Solutions:</p> <ol> <li>Check error messages for details</li> <li>Verify configuration is correct</li> <li>Check dependencies are installed</li> <li>Review logs for more information</li> </ol>"},{"location":"architecture/cli_layer/#related-documentation","title":"Related Documentation","text":"<ul> <li>API Layer - REST API server architecture</li> <li>Library Layer - Python library interface</li> <li>Execution - Test execution architecture</li> <li>Configuration - Configuration management</li> <li>CLI Usage Guide - CLI usage examples</li> </ul>"},{"location":"architecture/components/","title":"Component Architecture","text":"<p>This document provides detailed documentation of all major components in the Optics Framework, their responsibilities, and how they interact.</p>"},{"location":"architecture/components/#core-components","title":"Core Components","text":""},{"location":"architecture/components/#optics-class","title":"Optics Class","text":"<p>Location: <code>optics_framework/optics.py</code></p> <p>The <code>Optics</code> class is the main entry point for the framework. It provides a unified interface for both programmatic use and Robot Framework integration.</p>"},{"location":"architecture/components/#key-responsibilities","title":"Key Responsibilities","text":"<ul> <li>Configuration parsing and validation</li> <li>Session lifecycle management</li> <li>Keyword registration and exposure</li> <li>Template discovery</li> <li>Element and API data management</li> </ul>"},{"location":"architecture/components/#key-methods","title":"Key Methods","text":"<pre><code>@keyword(\"Setup\")\ndef setup(self, config: Union[str, Dict[str, Any], None] = None, ...)\n    \"\"\"Configure the framework with driver and element source settings.\"\"\"\n\n@keyword(\"Press Element\")\n@fallback_params\ndef press_element(self, element: fallback_str, ...)\n    \"\"\"Press an element with automatic fallback support.\"\"\"\n\n@keyword(\"Add Element\")\ndef add_element(self, name: str, value: Any)\n    \"\"\"Add or update an element in the current session.\"\"\"\n</code></pre>"},{"location":"architecture/components/#architecture-notes","title":"Architecture Notes","text":"<ul> <li>Uses <code>@fallback_params</code> decorator to support multiple fallback values</li> <li>Integrates with Robot Framework when available</li> <li>Manages session state through <code>SessionManager</code></li> <li>Delegates actual execution to API classes (ActionKeyword, Verifier, etc.)</li> </ul>"},{"location":"architecture/components/#fallback-parameter-system","title":"Fallback Parameter System","text":"<p>The Optics Framework provides a sophisticated fallback parameter system that allows keywords to automatically try multiple values until one succeeds. This is particularly useful for element location where multiple strategies or identifiers might work.</p>"},{"location":"architecture/components/#how-it-works","title":"How It Works","text":"<p>The <code>@fallback_params</code> decorator enables automatic fallback for parameters typed as <code>fallback_str</code>:</p> <pre><code>from optics_framework.optics import fallback_str, fallback_params\n\n@keyword(\"Press Element\")\n@fallback_params\ndef press_element(self, element: fallback_str, timeout: int = 30):\n    \"\"\"Press an element, trying multiple values if needed.\"\"\"\n    # Implementation\n</code></pre> <p>Type Definition: <pre><code>fallback_str = Union[str, List[str]]\n</code></pre></p>"},{"location":"architecture/components/#parameter-normalization","title":"Parameter Normalization","text":"<p>The decorator normalizes fallback values:</p> <pre><code>def _normalize_fallback_values(name: str, val: Any) -&gt; List[str]:\n    \"\"\"\n    Normalize fallback parameter values.\n\n    - str -&gt; [str] (single value)\n    - List[str] -&gt; List[str] (multiple values)\n    - None -&gt; [] (empty, skipped)\n    - Empty list -&gt; ValueError\n    \"\"\"\n</code></pre> <p>Examples: <pre><code># Single value (no fallback)\npress_element(\"submit_button\")  # element = [\"submit_button\"]\n\n# Multiple values (fallback)\npress_element([\"submit_btn\", \"submit_button\", \"//button[@id='submit']\"])\n# Tries each value in order until one succeeds\n\n# Mixed parameters\npress_element([\"btn1\", \"btn2\"], timeout=30)  # Only element has fallback\n</code></pre></p>"},{"location":"architecture/components/#combination-generation","title":"Combination Generation","text":"<p>When multiple parameters have fallback values, all combinations are tried:</p> <pre><code>from itertools import product\n\n# Generate all combinations\nfor combo in product(*(fallback_lists[k] for k in keys)):\n    combo_kwargs = dict(zip(keys, combo))\n    try:\n        return func(self, **combo_kwargs)\n    except Exception:\n        continue  # Try next combination\n</code></pre> <p>Example: <pre><code>@fallback_params\ndef press_element(self, element: fallback_str, area: fallback_str):\n    pass\n\n# Called with:\npress_element([\"btn1\", \"btn2\"], [\"area1\", \"area2\"])\n\n# Tries:\n# 1. element=\"btn1\", area=\"area1\"\n# 2. element=\"btn1\", area=\"area2\"\n# 3. element=\"btn2\", area=\"area1\"\n# 4. element=\"btn2\", area=\"area2\"\n</code></pre></p>"},{"location":"architecture/components/#error-aggregation","title":"Error Aggregation","text":"<p>If all fallback attempts fail, errors are aggregated:</p> <pre><code>if errors:\n    msg = \"\\n\".join([f\"{c} -&gt; {err}\" for c, err in errors])\n    raise RuntimeError(\n        f\"All fallback attempts failed in {func.__name__}:\\n{msg}\"\n    )\n</code></pre> <p>Error Message Format: <pre><code>All fallback attempts failed in press_element:\n{'element': 'btn1'} -&gt; Element not found\n{'element': 'btn2'} -&gt; Element not found\n{'element': 'btn3'} -&gt; Timeout exceeded\n</code></pre></p>"},{"location":"architecture/components/#integration-with-api-layer","title":"Integration with API Layer","text":"<p>The REST API layer also supports fallback parameters:</p> <pre><code># API request with fallback\n{\n  \"keyword\": \"Press Element\",\n  \"params\": [\"btn1\", \"btn2\", \"btn3\"]  # Positional fallback\n}\n\n# Or named parameters with fallback\n{\n  \"keyword\": \"Press Element\",\n  \"params\": {\n    \"element\": [\"btn1\", \"btn2\"],\n    \"timeout\": \"30\"\n  }\n}\n</code></pre> <p>The API uses the same combination generation logic:</p> <pre><code>async def _execute_keyword_with_fallback(\n    engine: ExecutionEngine,\n    session_id: str,\n    keyword: str,\n    params: Union[List[Union[str, List[str]]], Dict[str, Union[str, List[str]]]],\n    method: Callable[..., Any],\n    session: Session\n) -&gt; Any:\n    # Normalize parameters\n    # Generate combinations\n    # Try each combination\n    # Aggregate errors\n</code></pre>"},{"location":"architecture/components/#use-cases","title":"Use Cases","text":"<p>1. Element Location Fallback: <pre><code># Try multiple element identifiers\npress_element([\n    \"//button[@id='submit']\",      # XPath\n    \"Submit Button\",                # Text\n    \"submit_template.png\"           # Image template\n])\n</code></pre></p> <p>2. Multiple Strategies: <pre><code># Try different approaches\nenter_text([\"username\", \"user_name\", \"//input[@name='user']\"], \"testuser\")\n</code></pre></p> <p>3. Environment-Specific Values: <pre><code># Different values for different environments\nlaunch_app([\n    \"com.example.app.dev\",      # Development\n    \"com.example.app.staging\",  # Staging\n    \"com.example.app.prod\"      # Production\n])\n</code></pre></p>"},{"location":"architecture/components/#best-practices","title":"Best Practices","text":"<ol> <li>Order Matters: Place most likely to succeed values first</li> <li>Limit Combinations: Avoid too many fallback values (exponential growth)</li> <li>Meaningful Errors: Ensure errors provide context for debugging</li> <li>Type Safety: Always use <code>fallback_str</code> type hint</li> <li>Documentation: Document expected fallback behavior</li> </ol> <p>Example: <pre><code>@keyword(\"Press Element\")\n@fallback_params\ndef press_element(\n    self,\n    element: fallback_str,  # Document: \"Tries XPath, text, then image\"\n    timeout: int = 30\n) -&gt; None:\n    \"\"\"\n    Press an element with automatic fallback.\n\n    Args:\n        element: Element identifier(s). Can be:\n            - Single string: One identifier\n            - List of strings: Multiple fallback identifiers\n            Tries each in order until one succeeds.\n        timeout: Maximum time to wait for element\n    \"\"\"\n</code></pre></p>"},{"location":"architecture/components/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Early Exit: Decorator stops on first success</li> <li>Error Handling: Only catches non-critical exceptions</li> <li>Combination Limit: Consider limiting combinations for performance</li> <li>Caching: Results may be cached by strategy layer</li> </ul>"},{"location":"architecture/components/#limitations","title":"Limitations","text":"<ul> <li>Type Restriction: Only works with <code>fallback_str</code> type</li> <li>Exception Handling: SystemExit, KeyboardInterrupt, GeneratorExit are re-raised</li> <li>No Partial Success: All parameters must succeed together</li> <li>Error Visibility: Individual attempt errors are aggregated</li> </ul>"},{"location":"architecture/components/#sessionmanager","title":"SessionManager","text":"<p>Location: <code>optics_framework/common/session_manager.py</code></p> <p>Manages the lifecycle of test execution sessions, including creation, retrieval, and termination with proper resource management and cleanup.</p>"},{"location":"architecture/components/#key-responsibilities_1","title":"Key Responsibilities","text":"<ul> <li>Session creation with unique IDs</li> <li>Session storage and retrieval</li> <li>Resource cleanup on termination</li> <li>Session-scoped configuration management</li> <li>Event manager lifecycle</li> <li>Driver lifecycle management</li> </ul>"},{"location":"architecture/components/#class-structure","title":"Class Structure","text":"<pre><code>class SessionManager(SessionHandler):\n    def __init__(self):\n        self.sessions: Dict[str, Session] = {}\n\n    def create_session(self, config: Config, ...) -&gt; str:\n        \"\"\"Creates a new session with a unique ID.\"\"\"\n\n    def get_session(self, session_id: str) -&gt; Optional[Session]:\n        \"\"\"Retrieves a session by ID.\"\"\"\n\n    def terminate_session(self, session_id: str) -&gt; None:\n        \"\"\"Terminates a session and cleans up resources.\"\"\"\n</code></pre>"},{"location":"architecture/components/#session-lifecycle","title":"Session Lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Creating: create_session()\n    Creating --&gt; Active: Session created\n    Active --&gt; Executing: Test execution\n    Executing --&gt; Active: Execution complete\n    Active --&gt; Terminating: terminate_session()\n    Terminating --&gt; [*]: Cleanup complete\n\n    Active --&gt; Error: Error occurred\n    Error --&gt; Terminating: Cleanup</code></pre>"},{"location":"architecture/components/#session-creation-flow","title":"Session Creation Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant SessionMgr\n    participant Session\n    participant ConfigHandler\n    participant Builder\n    participant Driver\n    participant EventSDK\n\n    Client-&gt;&gt;SessionMgr: create_session(config, ...)\n    SessionMgr-&gt;&gt;SessionMgr: Generate UUID\n    SessionMgr-&gt;&gt;Session: new Session(id, config, ...)\n    Session-&gt;&gt;ConfigHandler: new ConfigHandler(config)\n    Session-&gt;&gt;Session: Extract enabled dependencies\n    Session-&gt;&gt;EventSDK: new EventSDK(config_handler)\n    Session-&gt;&gt;Builder: new OpticsBuilder(session)\n    Session-&gt;&gt;Builder: add_driver(configs)\n    Session-&gt;&gt;Builder: add_element_source(configs)\n    Session-&gt;&gt;Builder: add_text_detection(configs)\n    Session-&gt;&gt;Builder: add_image_detection(configs)\n    Session-&gt;&gt;Builder: get_driver()\n    Builder-&gt;&gt;Driver: Create driver instance\n    Driver--&gt;&gt;Builder: driver instance\n    Builder--&gt;&gt;Session: driver\n    Session-&gt;&gt;Session: Setup event queue\n    Session--&gt;&gt;SessionMgr: Session ready\n    SessionMgr--&gt;&gt;Client: session_id</code></pre>"},{"location":"architecture/components/#session-class","title":"Session Class","text":"<p>Each <code>Session</code> instance contains:</p> <p>Core Attributes:</p> <ul> <li><code>session_id</code>: Unique identifier (UUID)</li> <li><code>config_handler</code>: Configuration handler instance</li> <li><code>config</code>: Configuration object</li> <li><code>test_cases</code>: Test case data structure</li> <li><code>modules</code>: Reusable module definitions</li> <li><code>elements</code>: Element definitions and values</li> <li><code>apis</code>: API endpoint definitions</li> <li><code>templates</code>: Image template mappings</li> </ul> <p>Component Instances:</p> <ul> <li><code>optics</code>: OpticsBuilder instance</li> <li><code>driver</code>: Driver instance (via fallback)</li> <li><code>event_sdk</code>: Event tracking SDK</li> <li><code>event_queue</code>: Async queue for execution events</li> </ul>"},{"location":"architecture/components/#session-initialization","title":"Session Initialization","text":"<p>During session creation, the following occurs:</p> <ol> <li> <p>Configuration Setup: <pre><code>self.config_handler = ConfigHandler(config)\nself.config = self.config_handler.config\n</code></pre></p> </li> <li> <p>Dependency Extraction:</p> </li> <li> <p>Extract enabled driver configurations</p> </li> <li>Extract enabled element source configurations</li> <li>Extract enabled text detection configurations</li> <li> <p>Extract enabled image detection configurations</p> </li> <li> <p>Component Initialization: <pre><code>self.event_sdk = EventSDK(self.config_handler)\nself.optics = OpticsBuilder(self)\nself.optics.add_driver(enabled_driver_configs)\nself.optics.add_element_source(enabled_element_configs)\nself.optics.add_text_detection(enabled_text_configs)\nself.optics.add_image_detection(enabled_image_configs)\n</code></pre></p> </li> <li> <p>Driver Initialization: <pre><code>self.driver = self.optics.get_driver()\n</code></pre></p> </li> <li> <p>Event Queue Setup: <pre><code>self.event_queue = asyncio.Queue()\n</code></pre></p> </li> </ol>"},{"location":"architecture/components/#session-state-transitions","title":"Session State Transitions","text":"<p>Creating State:</p> <ul> <li>Session ID generated</li> <li>Configuration loaded</li> <li>Components initialized</li> <li>Driver connection established</li> </ul> <p>Active State:</p> <ul> <li>Session ready for execution</li> <li>Driver connected</li> <li>Event queue ready</li> <li>All components initialized</li> </ul> <p>Executing State:</p> <ul> <li>Test cases being executed</li> <li>Events being published</li> <li>Driver performing actions</li> </ul> <p>Terminating State:</p> <ul> <li>Driver termination initiated</li> <li>Event manager cleanup</li> <li>JUnit handler cleanup</li> <li>Session removal from registry</li> </ul>"},{"location":"architecture/components/#session-termination","title":"Session Termination","text":"<p>Session termination performs comprehensive cleanup:</p> <pre><code>def terminate_session(self, session_id: str) -&gt; None:\n    session = self.sessions.pop(session_id, None)\n    if session and session.driver:\n        session.driver.terminate()  # Close driver connection\n    cleanup_junit(session_id)  # Cleanup JUnit reports\n    get_event_manager_registry().remove_session(session_id)  # Remove event manager\n</code></pre> <p>Cleanup Steps:</p> <ol> <li>Remove from Registry: Remove session from sessions dictionary</li> <li>Driver Termination: Call <code>driver.terminate()</code> to close connections</li> <li>JUnit Cleanup: Cleanup JUnit report handlers</li> <li>Event Manager Cleanup: Remove event manager for session</li> </ol>"},{"location":"architecture/components/#resource-management","title":"Resource Management","text":"<p>Driver Resources:</p> <ul> <li>WebDriver connections</li> <li>Appium sessions</li> <li>Browser instances</li> <li>Device connections</li> </ul> <p>Event Resources:</p> <ul> <li>Event queues</li> <li>Event subscribers</li> <li>JUnit handlers</li> </ul> <p>File Resources:</p> <ul> <li>Log files</li> <li>Screenshot files</li> <li>Execution output</li> </ul>"},{"location":"architecture/components/#session-isolation","title":"Session Isolation","text":"<p>Sessions are isolated from each other:</p> <ul> <li>Separate Configuration: Each session has its own configuration</li> <li>Separate Drivers: Each session has its own driver instance</li> <li>Separate Event Queues: Each session has its own event queue</li> <li>Separate State: Test cases, elements, modules are session-scoped</li> </ul>"},{"location":"architecture/components/#concurrency-considerations","title":"Concurrency Considerations","text":"<p>Current Implementation:</p> <ul> <li>Sessions are stored in a dictionary (not thread-safe for writes)</li> <li>Each session has its own driver instance</li> <li>Event queues are per-session</li> </ul> <p>Best Practices:</p> <ul> <li>Create separate sessions for concurrent execution</li> <li>Don't share sessions between threads</li> <li>Terminate sessions when done</li> </ul>"},{"location":"architecture/components/#session-retrieval","title":"Session Retrieval","text":"<pre><code>def get_session(self, session_id: str) -&gt; Optional[Session]:\n    \"\"\"Retrieves a session by ID, or None if not found.\"\"\"\n    return self.sessions.get(session_id)\n</code></pre> <p>Usage:</p> <ul> <li>Returns <code>None</code> if session doesn't exist</li> <li>Returns <code>Session</code> instance if found</li> <li>No locking required (read-only operation)</li> </ul>"},{"location":"architecture/components/#session-validation","title":"Session Validation","text":"<p>During session creation, validation occurs:</p> <pre><code>if not enabled_driver_configs:\n    raise OpticsError(Code.E0501, message=\"No enabled drivers found\")\n</code></pre> <p>Validations:</p> <ul> <li>At least one driver must be enabled</li> <li>Configuration must be valid</li> <li>Dependencies must be properly configured</li> </ul>"},{"location":"architecture/components/#error-recovery","title":"Error Recovery","text":"<p>Session Creation Errors:</p> <ul> <li>Configuration errors are raised immediately</li> <li>Driver initialization errors are propagated</li> <li>Partial initialization is cleaned up</li> </ul> <p>Session Termination Errors:</p> <ul> <li>Driver termination errors are logged but don't stop cleanup</li> <li>Event manager cleanup errors are logged</li> <li>Session is always removed from registry</li> </ul>"},{"location":"architecture/components/#session-persistence","title":"Session Persistence","text":"<p>Current Implementation:</p> <ul> <li>Sessions are stored in memory only</li> <li>No persistence to disk</li> <li>Sessions are lost on process termination</li> </ul> <p>Future Considerations:</p> <ul> <li>Session serialization for persistence</li> <li>Session recovery on restart</li> <li>Session state snapshots</li> </ul>"},{"location":"architecture/components/#best-practices_1","title":"Best Practices","text":"<ol> <li>Always Terminate Sessions: Call <code>terminate_session()</code> when done</li> <li>One Session Per Test Run: Create a new session for each test run</li> <li>Reuse Sessions Within Run: Reuse session for multiple test cases in same run</li> <li>Handle Termination Errors: Wrap termination in try/except</li> <li>Check Session Existence: Verify session exists before use</li> </ol>"},{"location":"architecture/components/#troubleshooting","title":"Troubleshooting","text":"<p>Session Not Found:</p> <ul> <li>Verify session ID is correct</li> <li>Check session hasn't been terminated</li> <li>Ensure session was created successfully</li> </ul> <p>Driver Not Initialized:</p> <ul> <li>Check at least one driver is enabled</li> <li>Verify driver configuration is correct</li> <li>Review driver initialization logs</li> </ul> <p>Resource Leaks:</p> <ul> <li>Ensure <code>terminate_session()</code> is called</li> <li>Check for exception handling that skips cleanup</li> <li>Review driver termination logs</li> </ul>"},{"location":"architecture/components/#opticsbuilder","title":"OpticsBuilder","text":"<p>Location: <code>optics_framework/common/optics_builder.py</code></p> <p>Implements the Builder pattern to construct complex component hierarchies with proper dependency injection.</p>"},{"location":"architecture/components/#key-responsibilities_2","title":"Key Responsibilities","text":"<ul> <li>Configuration normalization</li> <li>Component instantiation through factories</li> <li>Dependency management between components</li> <li>Lazy instantiation of components</li> </ul>"},{"location":"architecture/components/#builder-flow","title":"Builder Flow","text":"<pre><code>graph LR\n    A[OpticsBuilder] --&gt; B[add_driver]\n    A --&gt; C[add_element_source]\n    A --&gt; D[add_image_detection]\n    A --&gt; E[add_text_detection]\n    B --&gt; F[instantiate_driver]\n    C --&gt; G[instantiate_element_source]\n    D --&gt; H[instantiate_image_detection]\n    E --&gt; I[instantiate_text_detection]\n    F --&gt; J[DeviceFactory]\n    G --&gt; K[ElementSourceFactory]\n    H --&gt; L[ImageFactory]\n    I --&gt; M[TextFactory]</code></pre>"},{"location":"architecture/components/#key-methods_1","title":"Key Methods","text":"<pre><code>def add_driver(self, config: Union[str, List[Union[str, Dict]]]) -&gt; \"OpticsBuilder\"\n    \"\"\"Add driver configuration.\"\"\"\n\ndef add_element_source(self, config: Union[str, List[Union[str, Dict]]]) -&gt; \"OpticsBuilder\"\n    \"\"\"Add element source configuration.\"\"\"\n\ndef build(self, cls: Type[T]) -&gt; T:\n    \"\"\"Build an instance of the specified class using stored configurations.\"\"\"\n</code></pre>"},{"location":"architecture/components/#usage-example","title":"Usage Example","text":"<p>Basic Builder Usage: <pre><code>from optics_framework.common.optics_builder import OpticsBuilder\n\n# Create builder\nbuilder = OpticsBuilder(session)\n\n# Add components\nbuilder.add_driver([{\"appium\": {\"enabled\": True, \"url\": \"...\"}}])\nbuilder.add_element_source([{\"appium_find_element\": {\"enabled\": True}}])\nbuilder.add_text_detection([{\"easyocr\": {\"enabled\": True}}])\nbuilder.add_image_detection([{\"templatematch\": {\"enabled\": True}}])\n\n# Get components\ndriver = builder.get_driver()\nelement_source = builder.get_element_source()\ntext_detection = builder.get_text_detection()\nimage_detection = builder.get_image_detection()\n</code></pre></p> <p>Fluent API: <pre><code># Builder supports method chaining\nbuilder = (OpticsBuilder(session)\n    .add_driver([{\"appium\": {\"enabled\": True}}])\n    .add_element_source([{\"appium_find_element\": {\"enabled\": True}}])\n    .add_text_detection([{\"easyocr\": {\"enabled\": True}}])\n)\n</code></pre></p> <p>Building API Classes: <pre><code># Build API classes with dependencies\naction_keyword = builder.build(ActionKeyword)\n# ActionKeyword receives driver, element_source, strategy_manager, etc.\n\nverifier = builder.build(Verifier)\n# Verifier receives builder components\n</code></pre></p>"},{"location":"architecture/components/#dependency-injection","title":"Dependency Injection","text":"<p>The builder automatically injects dependencies:</p> <ul> <li>Element sources receive matching drivers</li> <li>Image detection receives project path and templates</li> <li>Text detection receives execution output path</li> </ul> <p>Example - Element Source Injection: <pre><code># Element source automatically receives matching driver\nbuilder.add_driver([{\"appium\": {\"enabled\": True}}])\nbuilder.add_element_source([{\"appium_find_element\": {\"enabled\": True}}])\n\n# When element source is created:\n# ElementSourceFactory matches appium_find_element with appium driver\n# Injects driver into element source constructor\nelement_source = builder.get_element_source()\n# element_source.driver is the Appium driver instance\n</code></pre></p> <p>Example - Vision Model Injection: <pre><code># Image detection receives project path and templates\nbuilder.add_image_detection([{\n    \"templatematch\": {\n        \"enabled\": True,\n        \"project_path\": \"/path/to/project\",\n        \"execution_output_path\": \"/path/to/output\"\n    }\n}])\n\n# Template data is automatically discovered and injected\nimage_detection = builder.get_image_detection()\n# image_detection has access to templates from project_path\n</code></pre></p>"},{"location":"architecture/components/#confighandler","title":"ConfigHandler","text":"<p>Location: <code>optics_framework/common/config_handler.py</code></p> <p>Handles configuration parsing, validation, and access with support for hierarchical configuration and precedence rules.</p>"},{"location":"architecture/components/#key-responsibilities_3","title":"Key Responsibilities","text":"<ul> <li>Configuration file parsing (JSON/YAML)</li> <li>Configuration validation using Pydantic</li> <li>Dependency configuration management</li> <li>Enabled/disabled state tracking</li> <li>Configuration hierarchy and precedence</li> <li>Configuration merging</li> </ul>"},{"location":"architecture/components/#configuration-structure","title":"Configuration Structure","text":"<pre><code>class Config(BaseModel):\n    # Driver and element sources\n    driver_sources: List[Dict[str, DependencyConfig]]\n    elements_sources: List[Dict[str, DependencyConfig]]\n    image_detection: Optional[List[Dict[str, DependencyConfig]]]\n    text_detection: Optional[List[Dict[str, DependencyConfig]]]\n\n    # Paths\n    project_path: Optional[str]\n    execution_output_path: Optional[str]\n\n    # Logging\n    console: bool = True\n    file_log: bool = False\n    json_log: bool = False\n    json_path: Optional[str] = None\n    log_level: str = \"INFO\"\n    log_path: Optional[str] = None\n\n    # Execution\n    include: Optional[List[str]] = None\n    exclude: Optional[List[str]] = None\n    halt_duration: float = 0.1\n    max_attempts: int = 3\n\n    # Events\n    event_attributes_json: Optional[str] = None\n</code></pre>"},{"location":"architecture/components/#dependencyconfig","title":"DependencyConfig","text":"<p>Each dependency has its own configuration:</p> <pre><code>class DependencyConfig(BaseModel):\n    enabled: bool  # Whether this dependency is enabled\n    url: Optional[str] = None  # Connection URL (for drivers)\n    capabilities: Dict[str, Any] = {}  # Dependency-specific settings\n</code></pre>"},{"location":"architecture/components/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>Configuration is loaded from multiple sources with precedence:</p> <pre><code>graph TB\n    A[Default Config] --&gt; B[Global Config]\n    B --&gt; C[Project Config]\n    C --&gt; D[Final Config]\n\n    A1[Hardcoded Defaults] --&gt; A\n    B1[~/.optics/global_config.yaml] --&gt; B\n    C1[Project config.yaml] --&gt; C</code></pre> <p>Precedence Order (highest to lowest):</p> <ol> <li>Project Config - Project-specific configuration</li> <li>Global Config - User's global configuration (<code>~/.optics/global_config.yaml</code>)</li> <li>Default Config - Framework defaults</li> </ol>"},{"location":"architecture/components/#configuration-loading","title":"Configuration Loading","text":"<pre><code>def load(self) -&gt; Config:\n    default_config = Config()  # Framework defaults\n    global_config = self._load_yaml(self.global_config_path)  # Global config\n    project_config = self.config  # Project config\n\n    # Merge with precedence: project &gt; global &gt; default\n    merged = deep_merge(default_config, global_config)\n    self.config = deep_merge(merged, project_config)\n    return self.config\n</code></pre>"},{"location":"architecture/components/#configuration-merging","title":"Configuration Merging","text":"<p>The <code>deep_merge()</code> function recursively merges configurations:</p> <pre><code>def deep_merge(c1: Config, c2: Config) -&gt; Config:\n    \"\"\"Merge c2 into c1, with c2 taking precedence.\"\"\"\n    # Recursively merge dictionaries\n    # c2 values override c1 values\n</code></pre> <p>Merge Rules:</p> <ul> <li>Dictionary values are merged recursively</li> <li>List values are replaced (not merged)</li> <li>Scalar values are replaced</li> <li><code>None</code> values don't override existing values</li> </ul>"},{"location":"architecture/components/#default-configuration","title":"Default Configuration","text":"<p>If no configuration is provided, defaults are set:</p> <p>Driver Sources:</p> <ul> <li>appium (enabled=False)</li> <li>selenium (enabled=False)</li> <li>ble (enabled=False)</li> </ul> <p>Element Sources:</p> <ul> <li>appium_find_element (enabled=False)</li> <li>appium_page_source (enabled=False)</li> <li>appium_screenshot (enabled=False)</li> <li>camera_screenshot (enabled=False)</li> <li>selenium_find_element (enabled=False)</li> <li>selenium_screenshot (enabled=False)</li> </ul> <p>Text Detection:</p> <ul> <li>easyocr (enabled=False)</li> <li>pytesseract (enabled=False)</li> <li>google_vision (enabled=False)</li> <li>remote_ocr (enabled=False)</li> </ul> <p>Image Detection:</p> <ul> <li>templatematch (enabled=False)</li> <li>remote_oir (enabled=False)</li> </ul>"},{"location":"architecture/components/#enabled-configuration-tracking","title":"Enabled Configuration Tracking","text":"<p>ConfigHandler precomputes enabled dependencies:</p> <pre><code>def _precompute_enabled_configs(self) -&gt; None:\n    \"\"\"Precompute enabled configuration names for each dependency type.\"\"\"\n    for key in self.DEPENDENCY_KEYS:\n        dependencies = getattr(self.config, key, [])\n        self._enabled_configs[key] = [\n            name for item in dependencies\n            for name, details in item.items()\n            if details.enabled\n        ]\n</code></pre> <p>This allows efficient lookup of enabled dependencies without iterating through all configurations.</p>"},{"location":"architecture/components/#configuration-access","title":"Configuration Access","text":"<pre><code># Get enabled dependencies\nenabled_drivers = config_handler.get(\"driver_sources\")  # Returns list of enabled driver names\n\n# Get specific dependency config\ndriver_config = config_handler.get_dependency_config(\"driver_sources\", \"appium\")\n# Returns: {\"url\": \"...\", \"capabilities\": {...}}\n\n# Get any config value\nlog_level = config_handler.get(\"log_level\", \"INFO\")\n</code></pre>"},{"location":"architecture/components/#configuration-validation","title":"Configuration Validation","text":"<p>Configuration is validated using Pydantic:</p> <ul> <li>Type checking for all fields</li> <li>Required field validation</li> <li>Default value application</li> <li>Model validation on initialization</li> </ul> <p>Example: <pre><code>try:\n    config = Config(**config_dict)\nexcept ValidationError as e:\n    raise OpticsError(Code.E0503, message=f\"Configuration validation failed: {e}\")\n</code></pre></p>"},{"location":"architecture/components/#configuration-update","title":"Configuration Update","text":"<p>Configurations can be updated dynamically:</p> <pre><code>config_handler.update_config({\n    \"log_level\": \"DEBUG\",\n    \"driver_sources\": [{\"appium\": {\"enabled\": True, \"url\": \"...\"}}]\n})\n</code></pre> <p>The update merges new values into existing configuration.</p>"},{"location":"architecture/components/#configuration-file-format","title":"Configuration File Format","text":"<p>YAML Format: <pre><code>driver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\n      capabilities:\n        platformName: \"Android\"\n        deviceName: \"emulator-5554\"\n\nelements_sources:\n  - appium_find_element:\n      enabled: true\n\ntext_detection:\n  - easyocr:\n      enabled: true\n      capabilities:\n        languages: [\"en\"]\n\nproject_path: \"/path/to/project\"\nexecution_output_path: \"/path/to/output\"\nlog_level: \"INFO\"\n</code></pre></p>"},{"location":"architecture/components/#configuration-examples","title":"Configuration Examples","text":"<p>Minimal Configuration: <pre><code>driver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\n</code></pre></p> <p>Full Configuration: <pre><code>driver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\n      capabilities:\n        platformName: \"Android\"\n        appPackage: \"com.example.app\"\n  - selenium:\n      enabled: false\n\nelements_sources:\n  - appium_find_element:\n      enabled: true\n  - appium_screenshot:\n      enabled: true\n\ntext_detection:\n  - easyocr:\n      enabled: true\n      capabilities:\n        languages: [\"en\"]\n        gpu: true\n\nimage_detection:\n  - templatematch:\n      enabled: true\n\nproject_path: \"/path/to/project\"\nexecution_output_path: \"/path/to/output\"\nlog_level: \"DEBUG\"\nfile_log: true\nlog_path: \"/path/to/logs\"\nevent_attributes_json: \"/path/to/events.json\"\nmax_attempts: 5\nhalt_duration: 0.2\n</code></pre></p>"},{"location":"architecture/components/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>Use global config for environment-specific settings:</p> <p>Global Config (<code>~/.optics/global_config.yaml</code>): <pre><code># Development environment\nlog_level: \"DEBUG\"\nfile_log: true\n\n# Production environment\n# log_level: \"INFO\"\n# file_log: false\n</code></pre></p> <p>Project Config: <pre><code># Project-specific settings\ndriver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\n</code></pre></p>"},{"location":"architecture/components/#configuration-precedence-examples","title":"Configuration Precedence Examples","text":"<p>Example 1: Log Level</p> <ul> <li>Default: <code>INFO</code></li> <li>Global: <code>DEBUG</code></li> <li>Project: <code>WARNING</code></li> <li>Result: <code>WARNING</code> (project overrides)</li> </ul> <p>Example 2: Driver URL</p> <ul> <li>Default: <code>None</code></li> <li>Global: <code>http://localhost:4723</code></li> <li>Project: <code>http://remote:4723</code></li> <li>Result: <code>http://remote:4723</code> (project overrides)</li> </ul> <p>Example 3: Capabilities Merge</p> <ul> <li>Default: <code>{}</code></li> <li>Global: <code>{platformName: \"Android\"}</code></li> <li>Project: <code>{deviceName: \"emulator\"}</code></li> <li>Result: <code>{platformName: \"Android\", deviceName: \"emulator\"}</code> (merged)</li> </ul>"},{"location":"architecture/components/#configuration-validation-rules","title":"Configuration Validation Rules","text":"<ol> <li>Required Fields: None (all fields have defaults)</li> <li>Type Validation: All fields validated by Pydantic</li> <li>Dependency Validation: Enabled dependencies must have valid configuration</li> <li>Path Validation: Paths are validated on access (not on load)</li> </ol>"},{"location":"architecture/components/#best-practices_2","title":"Best Practices","text":"<ol> <li>Use Global Config for Environment Settings: Store environment-specific settings in global config</li> <li>Use Project Config for Project Settings: Store project-specific settings in project config</li> <li>Enable Only Needed Dependencies: Disable unused dependencies for better performance</li> <li>Use Capabilities for Driver Settings: Store driver-specific settings in capabilities</li> <li>Validate Configuration Early: Check configuration during initialization</li> </ol>"},{"location":"architecture/components/#troubleshooting_1","title":"Troubleshooting","text":"<p>Configuration Not Loading:</p> <ul> <li>Check file path is correct</li> <li>Verify YAML syntax is valid</li> <li>Check file permissions</li> </ul> <p>Dependencies Not Enabled:</p> <ul> <li>Verify <code>enabled: true</code> in configuration</li> <li>Check dependency name is correct</li> <li>Review enabled configs: <code>config_handler.get(\"driver_sources\")</code></li> </ul> <p>Configuration Not Applied:</p> <ul> <li>Check precedence order (project &gt; global &gt; default)</li> <li>Verify configuration was saved</li> <li>Check for merge conflicts</li> </ul>"},{"location":"architecture/components/#factory-system","title":"Factory System","text":""},{"location":"architecture/components/#genericfactory","title":"GenericFactory","text":"<p>Location: <code>optics_framework/common/base_factory.py</code></p> <p>Base factory class that provides dynamic module discovery and instantiation capabilities with automatic registration, caching, and fallback support.</p>"},{"location":"architecture/components/#key-features","title":"Key Features","text":"<ul> <li>Automatic module discovery within packages</li> <li>Dynamic class loading and instantiation</li> <li>Interface-based implementation detection</li> <li>Instance caching for performance</li> <li>Support for extra dependencies (e.g., driver injection)</li> <li>Lazy module loading</li> <li>Fallback instance management</li> </ul>"},{"location":"architecture/components/#module-discovery-algorithm","title":"Module Discovery Algorithm","text":"<p>The factory uses a recursive discovery algorithm:</p> <pre><code>graph TB\n    A[register_package] --&gt; B[Load Package]\n    B --&gt; C[Iterate Modules]\n    C --&gt; D{Is Package?}\n    D --&gt;|Yes| E[Recurse into Package]\n    D --&gt;|No| F[Register Module]\n    E --&gt; C\n    F --&gt; G[Store Module Path]\n    G --&gt; C</code></pre> <p>Discovery Process:</p> <ol> <li>Package Loading: Load the package using <code>importlib.import_module()</code></li> <li>Module Iteration: Use <code>pkgutil.iter_modules()</code> to iterate through modules</li> <li>Recursive Discovery: For subpackages, recursively discover modules</li> <li>Path Registration: Store module paths in registry for later use</li> </ol> <pre><code>@classmethod\ndef register_package(cls, package: str) -&gt; None:\n    \"\"\"Registers all modules within the specified package.\"\"\"\n    package_obj = cls._load_package(package)\n    if package_obj:\n        cls._register_submodules(package_obj.__path__, package)\n\n@classmethod\ndef _register_submodules(cls, package_paths, base_package: str) -&gt; None:\n    \"\"\"Recursively registers all submodules in a package.\"\"\"\n    for _, module_name, is_pkg in pkgutil.iter_modules(package_paths):\n        full_module_name = f\"{base_package}.{module_name}\"\n        cls._registry.module_paths[module_name] = full_module_name\n        if is_pkg:\n            cls._register_subpackage(full_module_name)\n</code></pre>"},{"location":"architecture/components/#module-registry","title":"Module Registry","text":"<p>The factory maintains a registry of discovered modules:</p> <pre><code>class ModuleRegistry(BaseModel, Generic[S]):\n    module_paths: Dict[str, str]  # name -&gt; full_module_path\n    instances: Dict[str, S]  # name -&gt; cached_instance\n</code></pre> <p>Registry Structure: - <code>module_paths</code>: Maps module names to full import paths - <code>instances</code>: Caches instantiated objects for reuse</p>"},{"location":"architecture/components/#instance-creation","title":"Instance Creation","text":"<p>The factory provides multiple methods for instance creation:</p>"},{"location":"architecture/components/#dynamic-instance-creation","title":"Dynamic Instance Creation","text":"<pre><code>@classmethod\ndef create_instance_dynamic(\n    cls,\n    config_dict: dict,\n    interface: Type[T],\n    package: str,\n    extra_kwargs: dict|None = None,\n) -&gt; T:\n    \"\"\"Unified instance creation supporting config and extra dependencies.\"\"\"\n</code></pre> <p>Process:</p> <ol> <li>Extract name and config from <code>config_dict</code></li> <li>Check if module is registered, load if not</li> <li>Import module dynamically</li> <li>Locate implementation class</li> <li>Inspect constructor signature</li> <li>Instantiate with config and extra kwargs</li> <li>Cache instance</li> </ol> <p>Example: <pre><code>driver = DeviceFactory.create_instance_dynamic(\n    {\"appium\": {\"enabled\": True, \"url\": \"...\"}},\n    DriverInterface,\n    \"optics_framework.engines.drivers\",\n    extra_kwargs={\"event_sdk\": event_sdk}\n)\n</code></pre></p>"},{"location":"architecture/components/#instance-creation-with-caching","title":"Instance Creation with Caching","text":"<pre><code>@classmethod\ndef _create_or_retrieve(cls, config_dict: dict, interface: Type[T], package: str) -&gt; T:\n    \"\"\"Creates a new instance or retrieves a cached one.\"\"\"\n</code></pre> <p>Caching Strategy:</p> <ul> <li>Check if instance exists in cache</li> <li>If cached, return existing instance</li> <li>If not cached, create new instance and cache it</li> <li>Cache key is the module name</li> </ul> <p>Benefits:</p> <ul> <li>Reduces instantiation overhead</li> <li>Ensures singleton behavior per module name</li> <li>Improves performance for repeated access</li> </ul>"},{"location":"architecture/components/#lazy-module-loading","title":"Lazy Module Loading","text":"<p>Modules are loaded on-demand:</p> <pre><code>@classmethod\ndef _load_module(cls, name: str, package: str) -&gt; None:\n    \"\"\"Loads a specific module dynamically.\"\"\"\n    full_module_name = f\"{package}.{name}\"\n    importlib.import_module(full_module_name)\n    cls._registry.module_paths[name] = full_module_name\n</code></pre> <p>When Lazy Loading Occurs:</p> <ul> <li>Module not found in registry during instantiation</li> <li>First access to a module</li> <li>Dynamic module discovery</li> </ul> <p>Benefits:</p> <ul> <li>Faster startup time</li> <li>Only loads modules that are actually used</li> <li>Reduces memory footprint</li> </ul>"},{"location":"architecture/components/#interface-based-detection","title":"Interface-Based Detection","text":"<p>The factory locates implementations by checking interface inheritance:</p> <pre><code>@staticmethod\ndef _locate_implementation(module: ModuleType, interface: Type[T]) -&gt; Optional[Type[T]]:\n    \"\"\"Locates a class in the module that implements the given interface.\"\"\"\n    for _, obj in inspect.getmembers(module, inspect.isclass):\n        if issubclass(obj, interface) and obj is not interface:\n            return obj\n    return None\n</code></pre> <p>Detection Rules:</p> <ol> <li>Iterate through all classes in module</li> <li>Check if class is subclass of interface</li> <li>Exclude the interface itself</li> <li>Return first matching class</li> </ol>"},{"location":"architecture/components/#constructor-signature-inspection","title":"Constructor Signature Inspection","text":"<p>The factory inspects constructor signatures to determine parameters:</p> <pre><code>sig = inspect.signature(implementation.__init__)\nkwargs = {}\nif \"config\" in sig.parameters:\n    kwargs[\"config\"] = config\nif extra_kwargs:\n    for k, v in extra_kwargs.items():\n        if k in sig.parameters:\n            kwargs[k] = v\ninstance = implementation(**kwargs)\n</code></pre> <p>Parameter Injection:</p> <ul> <li><code>config</code>: Injected if constructor accepts it</li> <li><code>extra_kwargs</code>: Injected if constructor accepts them</li> <li>Graceful fallback if config causes TypeError</li> </ul>"},{"location":"architecture/components/#fallback-instance-creation","title":"Fallback Instance Creation","text":"<p>When multiple configurations are provided, factory creates fallback instances:</p> <pre><code>@classmethod\ndef _create_fallback(cls, name: List[dict], interface: Type[T], package: str) -&gt; T:\n    \"\"\"Creates a fallback instance from a list of config dicts.\"\"\"\n    instances = []\n    for config_dict in name:\n        instances.append(cls._create_or_retrieve(config_dict, interface, package))\n    return InstanceFallback(instances)\n</code></pre> <p>Fallback Flow:</p> <ol> <li>Create instance for each configuration</li> <li>Wrap instances in <code>InstanceFallback</code></li> <li>Fallback tries each instance until one succeeds</li> </ol>"},{"location":"architecture/components/#instancefallback","title":"InstanceFallback","text":"<p>Manages multiple instances with automatic fallback:</p> <pre><code>class InstanceFallback(BaseModel, Generic[T]):\n    instances: List[T]\n    current_instance: Optional[T]\n</code></pre> <p>Fallback Mechanism: <pre><code>def __getattr__(self, attr):\n    def fallback_method(*args, **kwargs):\n        for instance in self.instances:\n            try:\n                method = getattr(instance, attr)\n                return method(*args, **kwargs)\n            except Exception as e:\n                continue  # Try next instance\n        raise AttributeError(\"All instances failed\")\n    return fallback_method\n</code></pre></p> <p>Usage: <pre><code># If Appium fails, automatically tries Selenium\nfallback_driver.press_element(element)\n</code></pre></p>"},{"location":"architecture/components/#factory-registration-timing","title":"Factory Registration Timing","text":"<p>Factories register packages at different times:</p> <p>DeviceFactory:</p> <ul> <li>Registers <code>optics_framework.engines.drivers</code> on first use</li> </ul> <p>ElementSourceFactory:</p> <ul> <li>Registers <code>optics_framework.engines.elementsources</code> on first use</li> </ul> <p>ImageFactory:</p> <ul> <li>Registers <code>optics_framework.engines.vision_models.image_models</code> on first use</li> </ul> <p>TextFactory:</p> <ul> <li>Registers <code>optics_framework.engines.vision_models.ocr_models</code> on first use</li> </ul>"},{"location":"architecture/components/#error-handling","title":"Error Handling","text":"<p>The factory handles various error scenarios:</p> <p>Module Not Found: <pre><code>except KeyError as exc:\n    raise OpticsError(Code.E0601, message=f\"Unknown module: '{name}'\")\n</code></pre></p> <p>No Implementation Found: <pre><code>if not implementation:\n    raise OpticsError(Code.E0603, message=f\"No implementation found\")\n</code></pre></p> <p>Import Errors: <pre><code>except ModuleNotFoundError as e:\n    raise OpticsError(Code.X0604, message=f\"Import error: {e}\")\n</code></pre></p>"},{"location":"architecture/components/#performance-considerations_1","title":"Performance Considerations","text":"<ol> <li>Instance Caching: Reduces instantiation overhead</li> <li>Lazy Loading: Only loads modules when needed</li> <li>Registry Lookup: Fast O(1) module path lookup</li> <li>Signature Caching: Pydantic caches signature inspection</li> </ol>"},{"location":"architecture/components/#cache-management","title":"Cache Management","text":"<pre><code>@classmethod\ndef clear_instances(cls) -&gt; None:\n    \"\"\"Clears all cached instances.\"\"\"\n    cls._registry.instances.clear()\n</code></pre> <p>When to Clear:</p> <ul> <li>Between test runs</li> <li>When configuration changes</li> <li>During cleanup</li> </ul>"},{"location":"architecture/components/#factory-lifecycle","title":"Factory Lifecycle","text":"<pre><code>sequenceDiagram\n    participant Factory\n    participant Registry\n    participant Module\n    participant Instance\n\n    Factory-&gt;&gt;Registry: Check if registered\n    alt Not Registered\n        Factory-&gt;&gt;Module: Discover modules\n        Module--&gt;&gt;Factory: Module paths\n        Factory-&gt;&gt;Registry: Register paths\n    end\n    Factory-&gt;&gt;Registry: Check cache\n    alt Not Cached\n        Factory-&gt;&gt;Module: Import module\n        Factory-&gt;&gt;Module: Locate implementation\n        Factory-&gt;&gt;Instance: Create instance\n        Factory-&gt;&gt;Registry: Cache instance\n    end\n    Registry--&gt;&gt;Factory: Return instance</code></pre>"},{"location":"architecture/components/#best-practices_3","title":"Best Practices","text":"<ol> <li>Register Packages Early: Register packages during initialization</li> <li>Use Caching: Leverage instance caching for performance</li> <li>Handle Errors: Always handle factory errors gracefully</li> <li>Clear Cache When Needed: Clear cache between test runs</li> <li>Use Fallback: Configure multiple instances for resilience</li> </ol>"},{"location":"architecture/components/#troubleshooting_2","title":"Troubleshooting","text":"<p>Module Not Found:</p> <ul> <li>Verify module is in correct package directory</li> <li>Check module name matches file name</li> <li>Ensure module implements correct interface</li> </ul> <p>No Implementation Found:</p> <ul> <li>Verify class extends interface</li> <li>Check class is not the interface itself</li> <li>Ensure class is imported in module</li> </ul> <p>Import Errors:</p> <ul> <li>Check module dependencies are installed</li> <li>Verify import paths are correct</li> <li>Review module initialization code</li> </ul>"},{"location":"architecture/components/#devicefactory","title":"DeviceFactory","text":"<p>Location: <code>optics_framework/common/factories.py</code></p> <p>Factory for creating driver instances.</p>"},{"location":"architecture/components/#default-package","title":"Default Package","text":"<pre><code>DEFAULT_PACKAGE = \"optics_framework.engines.drivers\"\n</code></pre>"},{"location":"architecture/components/#usage","title":"Usage","text":"<pre><code>driver = DeviceFactory.get_driver(\n    [{\"appium\": {\"enabled\": True, \"url\": \"...\", \"capabilities\": {...}}}],\n    event_sdk=event_sdk\n)\n</code></pre>"},{"location":"architecture/components/#elementsourcefactory","title":"ElementSourceFactory","text":"<p>Location: <code>optics_framework/common/factories.py</code></p> <p>Factory for creating element source instances with automatic driver matching.</p>"},{"location":"architecture/components/#key-features_1","title":"Key Features","text":"<ul> <li>Automatically matches element sources with compatible drivers</li> <li>Uses <code>REQUIRED_DRIVER_TYPE</code> attribute for matching</li> <li>Injects matched driver into element source constructor</li> </ul>"},{"location":"architecture/components/#driver-matching-logic","title":"Driver Matching Logic","text":"<pre><code>@classmethod\ndef _find_matching_driver(cls, implementation, driver_instances):\n    \"\"\"Find a driver instance that matches the required driver type.\"\"\"\n    required_type = getattr(implementation, \"REQUIRED_DRIVER_TYPE\", None)\n    # Matches by NAME attribute\n</code></pre>"},{"location":"architecture/components/#imagefactory-and-textfactory","title":"ImageFactory and TextFactory","text":"<p>Location: <code>optics_framework/common/factories.py</code></p> <p>Factories for vision model instantiation.</p> <ul> <li>ImageFactory: <code>optics_framework.engines.vision_models.image_models</code></li> <li>TextFactory: <code>optics_framework.engines.vision_models.ocr_models</code></li> </ul>"},{"location":"architecture/components/#instancefallback_1","title":"InstanceFallback","text":"<p>Location: <code>optics_framework/common/base_factory.py</code></p> <p>Wraps multiple implementations and provides automatic fallback when methods fail.</p>"},{"location":"architecture/components/#fallback-mechanism","title":"Fallback Mechanism","text":"<pre><code>class InstanceFallback(BaseModel, Generic[T]):\n    instances: List[T]\n    current_instance: Optional[T]\n\n    def __getattr__(self, attr):\n        \"\"\"Tries each instance until one succeeds.\"\"\"\n        for instance in self.instances:\n            try:\n                return getattr(instance, attr)(*args, **kwargs)\n            except Exception:\n                continue\n        raise AttributeError(\"All instances failed\")\n</code></pre>"},{"location":"architecture/components/#usage-pattern","title":"Usage Pattern","text":"<p>When multiple drivers are configured, they're wrapped in <code>InstanceFallback</code>: <pre><code># If Appium fails, automatically tries Selenium\nfallback_driver.press_element(element)\n</code></pre></p>"},{"location":"architecture/components/#interfaces","title":"Interfaces","text":""},{"location":"architecture/components/#driverinterface","title":"DriverInterface","text":"<p>Location: <code>optics_framework/common/driver_interface.py</code></p> <p>Abstract interface for action drivers that execute user actions.</p>"},{"location":"architecture/components/#key-methods_2","title":"Key Methods","text":"<ul> <li><code>launch_app()</code> - Launch applications</li> <li><code>press_coordinates()</code> - Press at absolute coordinates</li> <li><code>press_element()</code> - Press UI elements</li> <li><code>enter_text()</code> - Text input</li> <li><code>swipe()</code> / <code>scroll()</code> - Gesture actions</li> <li><code>get_text_element()</code> - Extract text</li> <li><code>terminate()</code> - Cleanup</li> </ul>"},{"location":"architecture/components/#implementations","title":"Implementations","text":"<ul> <li><code>AppiumDriver</code> - Mobile app automation</li> <li><code>SeleniumDriver</code> - Web browser automation</li> <li><code>PlaywrightDriver</code> - Modern web automation</li> <li><code>BLEDriver</code> - Non-intrusive BLE mouse/keyboard</li> </ul>"},{"location":"architecture/components/#elementsourceinterface","title":"ElementSourceInterface","text":"<p>Location: <code>optics_framework/common/elementsource_interface.py</code></p> <p>Abstract interface for element detection and screen capture.</p>"},{"location":"architecture/components/#key-methods_3","title":"Key Methods","text":"<ul> <li><code>capture()</code> - Capture current screen state</li> <li><code>locate()</code> - Locate elements (XPath, text, etc.)</li> <li><code>assert_elements()</code> - Verify element presence</li> <li><code>get_interactive_elements()</code> - Get clickable elements</li> </ul>"},{"location":"architecture/components/#implementations_1","title":"Implementations","text":"<ul> <li><code>AppiumFindElement</code> - Appium-based element location</li> <li><code>SeleniumFindElement</code> - Selenium-based element location</li> <li><code>PlaywrightFindElement</code> - Playwright-based element location</li> <li><code>AppiumScreenshot</code> / <code>SeleniumScreenshot</code> / <code>PlaywrightScreenshot</code> - Screenshot capture</li> <li><code>CameraScreenshot</code> - External camera capture</li> <li><code>AppiumPageSource</code> / <code>SeleniumPageSource</code> / <code>PlaywrightPageSource</code> - Page source extraction</li> </ul>"},{"location":"architecture/components/#imageinterface","title":"ImageInterface","text":"<p>Location: <code>optics_framework/common/image_interface.py</code></p> <p>Abstract interface for image template matching.</p>"},{"location":"architecture/components/#key-methods_4","title":"Key Methods","text":"<ul> <li><code>element_exist()</code> - Check if image exists in frame</li> <li><code>find_element()</code> - Locate image with detailed info</li> <li><code>assert_elements()</code> - Verify multiple images</li> </ul>"},{"location":"architecture/components/#implementations_2","title":"Implementations","text":"<ul> <li><code>TemplateMatch</code> - OpenCV template matching</li> <li><code>RemoteOIR</code> - Remote object image recognition service</li> </ul>"},{"location":"architecture/components/#textinterface","title":"TextInterface","text":"<p>Location: <code>optics_framework/common/text_interface.py</code></p> <p>Abstract interface for OCR and text detection.</p>"},{"location":"architecture/components/#key-methods_5","title":"Key Methods","text":"<ul> <li><code>element_exist()</code> - Check if text exists</li> <li><code>find_element()</code> - Locate text with bounding box</li> <li><code>detect_text()</code> - Full text detection with confidence</li> </ul>"},{"location":"architecture/components/#implementations_3","title":"Implementations","text":"<ul> <li><code>EasyOCR</code> - EasyOCR library</li> <li><code>GoogleVision</code> - Google Cloud Vision API</li> <li><code>PyTesseract</code> - Tesseract OCR</li> <li><code>RemoteOCR</code> - Remote OCR service</li> </ul>"},{"location":"architecture/components/#api-modules","title":"API Modules","text":""},{"location":"architecture/components/#actionkeyword","title":"ActionKeyword","text":"<p>Location: <code>optics_framework/api/action_keyword.py</code></p> <p>High-level API for executing user actions with self-healing.</p>"},{"location":"architecture/components/#key-features_2","title":"Key Features","text":"<ul> <li>Self-healing through <code>@with_self_healing</code> decorator</li> <li>Automatic strategy selection</li> <li>Area of Interest (AOI) support</li> <li>Screenshot capture on actions</li> </ul>"},{"location":"architecture/components/#self-healing-decorator","title":"Self-Healing Decorator","text":"<pre><code>@with_self_healing\ndef press_element(self, element: str, ..., *, located: Any = None):\n    \"\"\"Automatically tries multiple strategies until one succeeds.\"\"\"\n</code></pre>"},{"location":"architecture/components/#key-methods_6","title":"Key Methods","text":"<ul> <li><code>press_element()</code> - Press with AOI support</li> <li><code>press_by_coordinates()</code> - Absolute coordinates</li> <li><code>press_by_percentage()</code> - Percentage coordinates</li> <li><code>swipe()</code> / <code>scroll()</code> - Gestures</li> <li><code>enter_text()</code> - Text input</li> <li><code>press_keycode()</code> - Hardware keys</li> </ul>"},{"location":"architecture/components/#appmanagement","title":"AppManagement","text":"<p>Location: <code>optics_framework/api/app_management.py</code></p> <p>Manages application lifecycle.</p>"},{"location":"architecture/components/#key-methods_7","title":"Key Methods","text":"<ul> <li><code>launch_app()</code> - Launch with identifier/activity</li> <li><code>launch_other_app()</code> - Launch different app</li> <li><code>start_appium_session()</code> - Start Appium session</li> <li><code>close_and_terminate_app()</code> - Cleanup</li> <li><code>force_terminate_app()</code> - Force kill</li> <li><code>get_app_version()</code> - Version info</li> </ul>"},{"location":"architecture/components/#verifier","title":"Verifier","text":"<p>Location: <code>optics_framework/api/verifier.py</code></p> <p>Provides assertion and validation capabilities.</p>"},{"location":"architecture/components/#key-methods_8","title":"Key Methods","text":"<ul> <li><code>validate_element()</code> - Verify single element</li> <li><code>validate_screen()</code> - Verify multiple elements</li> <li><code>assert_presence()</code> - Assert with rules (any/all)</li> <li><code>assert_images_vision()</code> - Vision-based image assertion</li> <li><code>assert_texts_vision()</code> - Vision-based text assertion</li> <li><code>get_interactive_elements()</code> - Get UI elements</li> <li><code>capture_screenshot()</code> - Screenshot capture</li> <li><code>capture_pagesource()</code> - Page source capture</li> </ul>"},{"location":"architecture/components/#flowcontrol","title":"FlowControl","text":"<p>Location: <code>optics_framework/api/flow_control.py</code></p> <p>Manages control flow and data operations.</p>"},{"location":"architecture/components/#key-methods_9","title":"Key Methods","text":"<ul> <li><code>condition()</code> - Conditional execution</li> <li><code>evaluate()</code> - Expression evaluation</li> <li><code>read_data()</code> - Read from CSV/API/list</li> <li><code>run_loop()</code> - Loop execution</li> <li><code>invoke_api()</code> - REST API calls</li> <li><code>date_evaluate()</code> - Date calculations</li> </ul>"},{"location":"architecture/components/#component-interactions","title":"Component Interactions","text":""},{"location":"architecture/components/#initialization-flow","title":"Initialization Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Optics\n    participant SessionMgr\n    participant Session\n    participant Builder\n    participant Factory\n\n    User-&gt;&gt;Optics: setup(config)\n    Optics-&gt;&gt;SessionMgr: create_session()\n    SessionMgr-&gt;&gt;Session: new Session(config)\n    Session-&gt;&gt;Builder: new OpticsBuilder()\n    Session-&gt;&gt;Builder: add_driver(config)\n    Builder-&gt;&gt;Factory: DeviceFactory.get_driver()\n    Factory--&gt;&gt;Builder: driver instance\n    Session-&gt;&gt;Builder: add_element_source(config)\n    Builder-&gt;&gt;Factory: ElementSourceFactory.get_driver()\n    Factory--&gt;&gt;Builder: element_source instance\n    Builder--&gt;&gt;Session: configured builder\n    Session--&gt;&gt;SessionMgr: session ready</code></pre>"},{"location":"architecture/components/#action-execution-flow","title":"Action Execution Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant ActionKW\n    participant StrategyMgr\n    participant Strategy\n    participant ElementSource\n    participant Driver\n\n    User-&gt;&gt;ActionKW: press_element(element)\n    ActionKW-&gt;&gt;StrategyMgr: locate(element)\n    StrategyMgr-&gt;&gt;Strategy: try strategies\n    Strategy-&gt;&gt;ElementSource: locate/capture\n    ElementSource--&gt;&gt;Strategy: coordinates\n    Strategy--&gt;&gt;StrategyMgr: location\n    StrategyMgr--&gt;&gt;ActionKW: coordinates\n    ActionKW-&gt;&gt;Driver: press_coordinates(x, y)\n    Driver--&gt;&gt;ActionKW: success</code></pre>"},{"location":"architecture/components/#extension-points","title":"Extension Points","text":""},{"location":"architecture/components/#adding-a-new-driver","title":"Adding a New Driver","text":"<ol> <li>Create class in <code>optics_framework/engines/drivers/</code></li> <li>Implement <code>DriverInterface</code></li> <li>Factory automatically discovers it</li> </ol>"},{"location":"architecture/components/#adding-a-new-element-source","title":"Adding a New Element Source","text":"<ol> <li>Create class in <code>optics_framework/engines/elementsources/</code></li> <li>Implement <code>ElementSourceInterface</code></li> <li>Set <code>REQUIRED_DRIVER_TYPE</code> if driver-dependent</li> <li>Factory automatically matches with drivers</li> </ol>"},{"location":"architecture/components/#adding-a-new-vision-model","title":"Adding a New Vision Model","text":"<ol> <li>Create class in <code>optics_framework/engines/vision_models/</code></li> <li>Implement <code>ImageInterface</code> or <code>TextInterface</code></li> <li>Factory automatically discovers it</li> </ol>"},{"location":"architecture/components/#adding-a-new-keyword","title":"Adding a New Keyword","text":"<ol> <li>Add method to appropriate API class</li> <li>Decorate with <code>@keyword(\"Keyword Name\")</code></li> <li>Optionally add <code>@fallback_params</code> for fallback support</li> <li>Register in <code>KeywordRegistry</code></li> </ol>"},{"location":"architecture/components/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview - High-level architecture</li> <li>Engines - Engine implementations</li> <li>Strategies - Strategy pattern and self-healing</li> <li>Execution - Execution flow and data models</li> <li>Error Handling - Error handling system</li> <li>Event System - EventSDK integration</li> <li>Logging - Logging architecture</li> <li>Architecture Decisions - Design decisions and rationale</li> <li>REST API Usage - REST API endpoints</li> <li>API Reference - Python API documentation</li> </ul>"},{"location":"architecture/decisions/","title":"Architecture Decision Records (ADRs)","text":"<p>This document records the key architectural decisions made in the Optics Framework, including the rationale, alternatives considered, and trade-offs. ADRs help understand why the framework is designed the way it is and provide context for future changes.</p>"},{"location":"architecture/decisions/#what-are-adrs","title":"What are ADRs?","text":"<p>Architecture Decision Records (ADRs) are documents that capture important architectural decisions made during the development of the framework. Each ADR describes:</p> <ul> <li>Context: The situation and requirements</li> <li>Decision: What was decided</li> <li>Rationale: Why this decision was made</li> <li>Alternatives: Other options considered</li> <li>Consequences: Impact and trade-offs</li> </ul>"},{"location":"architecture/decisions/#adr-format","title":"ADR Format","text":"<p>Each ADR follows this structure:</p> <pre><code>## ADR-XXX: [Title]\n\n**Status:** [Proposed | Accepted | Deprecated | Superseded]\n\n**Context:**\n[The situation and requirements]\n\n**Decision:**\n[What was decided]\n\n**Rationale:**\n[Why this decision was made]\n\n**Alternatives Considered:**\n[Other options that were evaluated]\n\n**Consequences:**\n[Positive and negative impacts]\n</code></pre>"},{"location":"architecture/decisions/#key-architectural-decisions","title":"Key Architectural Decisions","text":""},{"location":"architecture/decisions/#adr-001-linked-list-structure-for-test-execution-hierarchy","title":"ADR-001: Linked List Structure for Test Execution Hierarchy","text":"<p>Status: Accepted</p> <p>Context: The framework needs to represent test execution hierarchy (TestSuite \u2192 TestCase \u2192 Module \u2192 Keyword) in a way that supports:</p> <ul> <li>Sequential execution</li> <li>Dynamic modification</li> <li>State tracking per node</li> <li>Memory efficiency</li> </ul> <p>Decision: Use a linked list structure with node classes (TestCaseNode, ModuleNode, KeywordNode) instead of nested lists or trees.</p> <p>Rationale:</p> <ol> <li>Sequential Execution: Linked lists naturally represent sequential execution flow</li> <li>Memory Efficiency: No array overhead, only stores necessary links</li> <li>Dynamic Structure: Easy to add/remove nodes during execution</li> <li>State Tracking: Each node can track its own execution state independently</li> <li>Traversal Simplicity: Simple forward traversal matches execution flow</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Nested Lists/Dictionaries:</p> </li> <li> <p>Pros: Simple structure, easy to serialize</p> </li> <li>Cons: Less memory efficient, harder to modify during execution</li> <li> <p>Rejected: Doesn't support dynamic modification well</p> </li> <li> <p>Tree Structure:</p> </li> <li> <p>Pros: Hierarchical representation</p> </li> <li>Cons: More complex, overhead for parent/child relationships</li> <li> <p>Rejected: Overkill for sequential execution</p> </li> <li> <p>Array/List with Indices:</p> </li> <li> <p>Pros: Simple indexing</p> </li> <li>Cons: Reallocation overhead, less flexible</li> <li>Rejected: Doesn't support dynamic structure well</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Efficient sequential execution</li> <li>\u2705 Low memory overhead</li> <li>\u2705 Easy to modify structure</li> <li>\u2705 Natural state tracking</li> <li>\u26a0\ufe0f No random access (must traverse)</li> <li>\u26a0\ufe0f More complex serialization if needed</li> </ul> <p>Implementation: <pre><code>class TestCaseNode(Node):\n    modules_head: Optional[ModuleNode] = None\n    next: Optional['TestCaseNode'] = None\n</code></pre></p>"},{"location":"architecture/decisions/#adr-002-factory-pattern-with-dynamic-discovery","title":"ADR-002: Factory Pattern with Dynamic Discovery","text":"<p>Status: Accepted</p> <p>Context: The framework needs to support multiple drivers, element sources, and vision models that can be added without modifying core code. Components should be discoverable and instantiable based on configuration.</p> <p>Decision: Use a factory pattern with dynamic module discovery and automatic registration. Factories scan package directories, discover implementations, and instantiate them based on configuration.</p> <p>Rationale:</p> <ol> <li>Extensibility: New engines can be added without core code changes</li> <li>Automatic Discovery: No manual registration required</li> <li>Interface-Based: Components discovered by interface implementation</li> <li>Configuration-Driven: Selection based on configuration, not code</li> <li>Lazy Loading: Modules loaded only when needed</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Manual Registration:</p> </li> <li> <p>Pros: Explicit control, no discovery overhead</p> </li> <li>Cons: Requires code changes for new engines</li> <li> <p>Rejected: Less extensible</p> </li> <li> <p>Plugin System:</p> </li> <li> <p>Pros: Standard plugin architecture</p> </li> <li>Cons: More complex, requires plugin infrastructure</li> <li> <p>Rejected: Overkill for current needs</p> </li> <li> <p>Dependency Injection Container:</p> </li> <li> <p>Pros: Standard DI pattern</p> </li> <li>Cons: More complex, requires container setup</li> <li>Rejected: Too heavyweight</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Highly extensible</li> <li>\u2705 No code changes for new engines</li> <li>\u2705 Automatic discovery</li> <li>\u2705 Interface-based selection</li> <li>\u26a0\ufe0f Discovery overhead on first use</li> <li>\u26a0\ufe0f Requires consistent naming conventions</li> </ul> <p>Implementation: <pre><code>class GenericFactory:\n    @classmethod\n    def register_package(cls, package: str) -&gt; None:\n        # Recursively discover modules\n        # Register module paths\n</code></pre></p>"},{"location":"architecture/decisions/#adr-003-strategy-pattern-for-element-location","title":"ADR-003: Strategy Pattern for Element Location","text":"<p>Status: Accepted</p> <p>Context: Elements can be located using multiple methods (XPath, text, OCR, image matching). The framework needs to try multiple strategies automatically until one succeeds (self-healing).</p> <p>Decision: Use the Strategy pattern with a StrategyManager that tries multiple location strategies in priority order until one succeeds.</p> <p>Rationale:</p> <ol> <li>Self-Healing: Automatic fallback to alternative methods</li> <li>Flexibility: Easy to add new location strategies</li> <li>Priority-Based: Fastest strategies tried first</li> <li>Separation of Concerns: Each strategy is independent</li> <li>Extensibility: New strategies can be added easily</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Single Method with Internal Fallback:</p> </li> <li> <p>Pros: Simpler implementation</p> </li> <li>Cons: Harder to extend, less flexible</li> <li> <p>Rejected: Not extensible enough</p> </li> <li> <p>Chain of Responsibility:</p> </li> <li> <p>Pros: Standard pattern for fallback</p> </li> <li>Cons: More complex, less explicit</li> <li> <p>Rejected: Strategy pattern is clearer</p> </li> <li> <p>Template Method:</p> </li> <li> <p>Pros: Code reuse</p> </li> <li>Cons: Less flexible, harder to extend</li> <li>Rejected: Doesn't support multiple independent strategies well</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Self-healing test automation</li> <li>\u2705 Easy to add new strategies</li> <li>\u2705 Clear priority ordering</li> <li>\u2705 Independent strategy implementations</li> <li>\u26a0\ufe0f Multiple strategy attempts may be slower</li> <li>\u26a0\ufe0f Requires strategy coordination</li> </ul> <p>Implementation: <pre><code>class StrategyManager:\n    def locate(self, element: str, index: int = 0):\n        for strategy in self.locator_strategies:\n            try:\n                result = strategy.locate(element, index)\n                if result is not None:\n                    yield LocateResult(result, strategy)\n            except Exception:\n                continue\n</code></pre></p>"},{"location":"architecture/decisions/#adr-004-fallback-parameter-system","title":"ADR-004: Fallback Parameter System","text":"<p>Status: Accepted</p> <p>Context: Keywords need to support multiple fallback values for parameters (e.g., try multiple element identifiers). This should be automatic and transparent to users.</p> <p>Decision: Implement a <code>@fallback_params</code> decorator that automatically tries all combinations of fallback parameter values until one succeeds.</p> <p>Rationale:</p> <ol> <li>User-Friendly: Simple API, automatic fallback</li> <li>Flexible: Supports multiple fallback parameters</li> <li>Transparent: Works automatically without user intervention</li> <li>Error Aggregation: Collects errors from all attempts</li> <li>Type-Safe: Uses type hints for detection</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Manual Fallback in Keywords:</p> </li> <li> <p>Pros: Explicit control</p> </li> <li>Cons: Code duplication, error-prone</li> <li> <p>Rejected: Too much boilerplate</p> </li> <li> <p>Separate Fallback Keyword:</p> </li> <li> <p>Pros: Explicit fallback</p> </li> <li>Cons: More verbose, less intuitive</li> <li> <p>Rejected: Not user-friendly</p> </li> <li> <p>Configuration-Based Fallback:</p> </li> <li> <p>Pros: Centralized configuration</p> </li> <li>Cons: Less flexible, harder to use</li> <li>Rejected: Too rigid</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Simple API for users</li> <li>\u2705 Automatic fallback handling</li> <li>\u2705 Supports multiple fallback parameters</li> <li>\u2705 Error aggregation for debugging</li> <li>\u26a0\ufe0f Exponential growth with multiple fallback params</li> <li>\u26a0\ufe0f May try many combinations</li> </ul> <p>Implementation: <pre><code>@fallback_params\ndef press_element(self, element: fallback_str, ...):\n    # Automatically tries all combinations\n</code></pre></p>"},{"location":"architecture/decisions/#adr-005-queue-based-logging-system","title":"ADR-005: Queue-Based Logging System","text":"<p>Status: Accepted</p> <p>Context: Logging needs to be thread-safe, non-blocking, and support multiple logger instances (internal vs execution). Logging should not slow down test execution.</p> <p>Decision: Use queue-based logging with QueueHandler and background listeners. Separate loggers for internal operations and execution events.</p> <p>Rationale:</p> <ol> <li>Thread-Safe: Queues are thread-safe by design</li> <li>Non-Blocking: Log writes don't block execution</li> <li>Background Processing: Logs processed asynchronously</li> <li>Separation of Concerns: Different loggers for different purposes</li> <li>Performance: Doesn't impact execution speed</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Direct Logging:</p> </li> <li> <p>Pros: Simple, immediate</p> </li> <li>Cons: Blocking, may slow execution</li> <li> <p>Rejected: Performance impact</p> </li> <li> <p>File-Based Only:</p> </li> <li> <p>Pros: Simple</p> </li> <li>Cons: No console output, harder to debug</li> <li> <p>Rejected: Need console output for development</p> </li> <li> <p>Single Logger:</p> </li> <li> <p>Pros: Simpler</p> </li> <li>Cons: Can't separate internal vs execution logs</li> <li>Rejected: Need separation for clarity</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Non-blocking execution</li> <li>\u2705 Thread-safe logging</li> <li>\u2705 Better performance</li> <li>\u2705 Separated log streams</li> <li>\u26a0\ufe0f More complex implementation</li> <li>\u26a0\ufe0f Queue management overhead</li> </ul> <p>Implementation: <pre><code>execution_queue_handler = QueueHandler(self.execution_log_queue)\nself.execution_logger.addHandler(self.execution_queue_handler)\n</code></pre></p>"},{"location":"architecture/decisions/#adr-006-instance-caching-in-factories","title":"ADR-006: Instance Caching in Factories","text":"<p>Status: Accepted</p> <p>Context: Factory instantiation can be expensive. The same components may be requested multiple times. Need to balance performance with memory usage.</p> <p>Decision: Cache factory instances by module name. Return cached instance if available, otherwise create and cache new instance.</p> <p>Rationale:</p> <ol> <li>Performance: Reduces instantiation overhead</li> <li>Singleton Behavior: Ensures one instance per module name</li> <li>Memory Efficiency: Reuses instances instead of creating duplicates</li> <li>Simple: Easy to implement and understand</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>No Caching:</p> </li> <li> <p>Pros: Simple, always fresh instances</p> </li> <li>Cons: Performance overhead, potential duplicates</li> <li> <p>Rejected: Too slow for repeated access</p> </li> <li> <p>Weak Reference Caching:</p> </li> <li> <p>Pros: Automatic cleanup</p> </li> <li>Cons: More complex, instances may be garbage collected</li> <li> <p>Rejected: Too complex for current needs</p> </li> <li> <p>LRU Cache:</p> </li> <li> <p>Pros: Bounded memory usage</p> </li> <li>Cons: More complex, may evict needed instances</li> <li>Rejected: Overkill, instances should persist</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Faster instantiation after first use</li> <li>\u2705 Singleton behavior per module</li> <li>\u2705 Reduced memory allocation</li> <li>\u26a0\ufe0f Instances persist in memory</li> <li>\u26a0\ufe0f Manual cache clearing needed</li> </ul> <p>Implementation: <pre><code>if name in cls._registry.instances:\n    return cls._registry.instances[name]\n# Create and cache\n</code></pre></p>"},{"location":"architecture/decisions/#adr-007-context-variables-for-test-context","title":"ADR-007: Context Variables for Test Context","text":"<p>Status: Accepted</p> <p>Context: Components need access to current test case name without explicit parameter passing. This should work across async operations and threads.</p> <p>Decision: Use Python's <code>contextvars</code> module to provide thread-local and async-safe test context.</p> <p>Rationale:</p> <ol> <li>Async-Safe: Automatically propagated to async tasks</li> <li>Thread-Safe: Each thread has its own context</li> <li>No Parameter Passing: Access context without explicit parameters</li> <li>Standard Library: Uses standard Python feature</li> <li>Isolation: Context isolated per execution context</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Thread-Local Storage:</p> </li> <li> <p>Pros: Simple</p> </li> <li>Cons: Not async-safe, doesn't propagate to async tasks</li> <li> <p>Rejected: Doesn't work with async</p> </li> <li> <p>Explicit Parameter Passing:</p> </li> <li> <p>Pros: Explicit, clear</p> </li> <li>Cons: Verbose, pollutes method signatures</li> <li> <p>Rejected: Too verbose</p> </li> <li> <p>Global Variable:</p> </li> <li> <p>Pros: Simple access</p> </li> <li>Cons: Not thread-safe, race conditions</li> <li>Rejected: Not safe for concurrent execution</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Async-safe context propagation</li> <li>\u2705 Thread-safe</li> <li>\u2705 Clean API (no parameter passing)</li> <li>\u2705 Standard library solution</li> <li>\u26a0\ufe0f Requires Python 3.7+</li> <li>\u26a0\ufe0f Context must be set explicitly</li> </ul> <p>Implementation: <pre><code>from contextvars import ContextVar\ncurrent_test_case: ContextVar[str] = ContextVar(\"current_test_case\", default=None)\n</code></pre></p>"},{"location":"architecture/decisions/#adr-008-self-healing-decorator-pattern","title":"ADR-008: Self-Healing Decorator Pattern","text":"<p>Status: Accepted</p> <p>Context: Action keywords need automatic element location with fallback strategies. This should be transparent to keyword implementations and handle errors gracefully.</p> <p>Decision: Use a <code>@with_self_healing</code> decorator that wraps action methods to provide automatic element location, strategy fallback, and error handling.</p> <p>Rationale:</p> <ol> <li>Separation of Concerns: Location logic separated from action logic</li> <li>Reusability: Same decorator for all action methods</li> <li>Transparency: Keyword implementations don't need location logic</li> <li>Error Handling: Centralized error handling and aggregation</li> <li>Screenshot Management: Automatic screenshot capture and saving</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Location in Each Keyword:</p> </li> <li> <p>Pros: Explicit control</p> </li> <li>Cons: Code duplication, error-prone</li> <li> <p>Rejected: Too much duplication</p> </li> <li> <p>Base Class with Location:</p> </li> <li> <p>Pros: Code reuse</p> </li> <li>Cons: Inheritance complexity, less flexible</li> <li> <p>Rejected: Decorator is more flexible</p> </li> <li> <p>Separate Location Service:</p> </li> <li> <p>Pros: Explicit service</p> </li> <li>Cons: More verbose, requires manual calls</li> <li>Rejected: Decorator is cleaner</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Clean keyword implementations</li> <li>\u2705 Reusable location logic</li> <li>\u2705 Automatic error handling</li> <li>\u2705 Screenshot management</li> <li>\u26a0\ufe0f Decorator complexity</li> <li>\u26a0\ufe0f May hide location failures</li> </ul> <p>Implementation: <pre><code>@with_self_healing\ndef press_element(self, element: str, ..., *, located: Any = None):\n    # located parameter provided by decorator\n</code></pre></p>"},{"location":"architecture/decisions/#adr-009-percentage-based-aoi-coordinates","title":"ADR-009: Percentage-Based AOI Coordinates","text":"<p>Status: Accepted</p> <p>Context: Area of Interest (AOI) needs to work across different screen sizes and resolutions. Absolute pixel coordinates won't work for different devices.</p> <p>Decision: Use percentage-based coordinates (0-100) for AOI parameters. Convert to pixel coordinates based on screenshot dimensions.</p> <p>Rationale:</p> <ol> <li>Screen Size Agnostic: Works on any screen size</li> <li>Device Independent: Same percentages work on different devices</li> <li>Intuitive: Easy to understand (50% = half screen)</li> <li>Flexible: Supports any screen resolution</li> <li>Portable: Test cases work across devices</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Absolute Pixel Coordinates:</p> </li> <li> <p>Pros: Precise control</p> </li> <li>Cons: Device-specific, doesn't scale</li> <li> <p>Rejected: Not portable</p> </li> <li> <p>Normalized Coordinates (0-1):</p> </li> <li> <p>Pros: Standard normalization</p> </li> <li>Cons: Less intuitive than percentages</li> <li> <p>Rejected: Percentages are more intuitive</p> </li> <li> <p>Relative Coordinates:</p> </li> <li> <p>Pros: Relative to element</p> </li> <li>Cons: More complex, requires reference element</li> <li>Rejected: Too complex</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Works on any screen size</li> <li>\u2705 Device-independent</li> <li>\u2705 Intuitive percentage values</li> <li>\u2705 Portable tests</li> <li>\u26a0\ufe0f Less precise than pixels</li> <li>\u26a0\ufe0f Conversion overhead</li> </ul> <p>Implementation: <pre><code>def calculate_aoi_bounds(screenshot_shape, aoi_x, aoi_y, aoi_width, aoi_height):\n    # Convert percentages to pixels\n    x1 = int(width * (aoi_x / 100))\n    y1 = int(height * (aoi_y / 100))\n</code></pre></p>"},{"location":"architecture/decisions/#adr-010-screenshot-streaming-with-deduplication","title":"ADR-010: Screenshot Streaming with Deduplication","text":"<p>Status: Accepted</p> <p>Context: Timeout-based element location requires continuous screenshot capture. Need to avoid processing duplicate frames and manage memory efficiently.</p> <p>Decision: Use queue-based screenshot streaming with SSIM-based deduplication. Capture screenshots in background thread, deduplicate using structural similarity, store in filtered queue.</p> <p>Rationale:</p> <ol> <li>Non-Blocking: Capture doesn't block execution</li> <li>Deduplication: Reduces processing of similar frames</li> <li>Memory Management: Bounded queues prevent memory issues</li> <li>Efficiency: Only process unique frames</li> <li>Background Processing: Doesn't slow down execution</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>No Deduplication:</p> </li> <li> <p>Pros: Simple</p> </li> <li>Cons: Processes many duplicate frames</li> <li> <p>Rejected: Too inefficient</p> </li> <li> <p>Hash-Based Deduplication:</p> </li> <li> <p>Pros: Fast comparison</p> </li> <li>Cons: Doesn't handle minor variations</li> <li> <p>Rejected: SSIM is more robust</p> </li> <li> <p>Fixed Interval Capture:</p> </li> <li> <p>Pros: Predictable</p> </li> <li>Cons: May miss changes, inefficient</li> <li>Rejected: Less efficient than streaming</li> </ol> <p>Consequences: - \u2705 Efficient frame processing - \u2705 Non-blocking capture - \u2705 Memory bounded - \u2705 Handles screen changes - \u26a0\ufe0f SSIM computation overhead - \u26a0\ufe0f Queue management complexity</p> <p>Implementation: <pre><code>class ScreenshotStream:\n    def process_screenshot_queue(self):\n        similarity = ssim(gray_last_frame, gray_frame)\n        if similarity &gt;= 0.75:\n            # Skip duplicate\n</code></pre></p>"},{"location":"architecture/decisions/#adr-011-multiple-logger-instances","title":"ADR-011: Multiple Logger Instances","text":"<p>Status: Accepted</p> <p>Context: Framework needs to separate internal debugging logs from execution event logs. Different log levels and formats are needed for different purposes.</p> <p>Decision: Use two separate logger instances: <code>internal_logger</code> for framework operations and <code>execution_logger</code> for test execution events.</p> <p>Rationale:</p> <ol> <li>Separation of Concerns: Different logs for different purposes</li> <li>Different Formats: Internal logs can be more verbose</li> <li>Different Levels: Can set different log levels</li> <li>User Experience: Execution logs are user-facing</li> <li>Debugging: Internal logs help with framework debugging</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Single Logger:</p> </li> <li> <p>Pros: Simpler</p> </li> <li>Cons: Can't separate concerns, mixed output</li> <li> <p>Rejected: Need separation</p> </li> <li> <p>Logger Hierarchy:</p> </li> <li> <p>Pros: Standard logging hierarchy</p> </li> <li>Cons: More complex, propagation issues</li> <li> <p>Rejected: Two loggers are sufficient</p> </li> <li> <p>Custom Logging System:</p> </li> <li> <p>Pros: Full control</p> </li> <li>Cons: More complex, reinventing wheel</li> <li>Rejected: Standard logging is better</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Clear separation of logs</li> <li>\u2705 Different formats and levels</li> <li>\u2705 Better user experience</li> <li>\u2705 Easier debugging</li> <li>\u26a0\ufe0f More complex configuration</li> <li>\u26a0\ufe0f Two loggers to manage</li> </ul> <p>Implementation: <pre><code>internal_logger = logging.getLogger(\"optics.internal\")\nexecution_logger = logging.getLogger(\"optics.execution\")\n</code></pre></p>"},{"location":"architecture/decisions/#adr-012-instancefallback-wrapper","title":"ADR-012: InstanceFallback Wrapper","text":"<p>Status: Accepted</p> <p>Context: When multiple drivers or element sources are configured, the framework should automatically try each one until one succeeds. This provides resilience and fallback capabilities.</p> <p>Decision: Wrap multiple instances in an <code>InstanceFallback</code> class that automatically tries each instance on method calls until one succeeds.</p> <p>Rationale:</p> <ol> <li>Automatic Fallback: No manual fallback logic needed</li> <li>Transparent: Works like a single instance</li> <li>Resilient: Continues working if one instance fails</li> <li>Simple API: Users don't need to handle fallback</li> <li>Flexible: Supports any number of instances</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Manual Fallback in Code:</p> </li> <li> <p>Pros: Explicit control</p> </li> <li>Cons: Code duplication, error-prone</li> <li> <p>Rejected: Too much boilerplate</p> </li> <li> <p>Proxy Pattern:</p> </li> <li> <p>Pros: Standard pattern</p> </li> <li>Cons: More complex, less transparent</li> <li> <p>Rejected: InstanceFallback is simpler</p> </li> <li> <p>Configuration-Based Selection:</p> </li> <li> <p>Pros: Explicit selection</p> </li> <li>Cons: No automatic fallback</li> <li>Rejected: Need automatic fallback</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Automatic fallback</li> <li>\u2705 Transparent usage</li> <li>\u2705 Resilient to failures</li> <li>\u2705 Simple API</li> <li>\u26a0\ufe0f May hide failures</li> <li>\u26a0\ufe0f Performance impact if many instances</li> </ul> <p>Implementation: <pre><code>class InstanceFallback:\n    def __getattr__(self, attr):\n        for instance in self.instances:\n            try:\n                return getattr(instance, attr)(*args, **kwargs)\n            except Exception:\n                continue\n</code></pre></p>"},{"location":"architecture/decisions/#adr-013-yaml-and-csv-dual-format-support","title":"ADR-013: YAML and CSV Dual Format Support","text":"<p>Status: Accepted</p> <p>Context: Users have different preferences for test data format. Some prefer CSV (spreadsheet-friendly), others prefer YAML (more structured). Framework should support both.</p> <p>Decision: Support both CSV and YAML formats for test cases, modules, and elements. Use content-based file discovery to identify file types.</p> <p>Rationale:</p> <ol> <li>User Choice: Supports different user preferences</li> <li>Flexibility: Users can choose best format for their needs</li> <li>Content-Based: Files identified by content, not just extension</li> <li>Merging: Multiple files of same type are merged</li> <li>Backward Compatible: Supports existing CSV-based projects</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>CSV Only:</p> </li> <li> <p>Pros: Simpler, one format</p> </li> <li>Cons: Less flexible, harder for complex data</li> <li> <p>Rejected: Too limiting</p> </li> <li> <p>YAML Only:</p> </li> <li> <p>Pros: More structured, better for complex data</p> </li> <li>Cons: Less spreadsheet-friendly</li> <li> <p>Rejected: CSV is important for many users</p> </li> <li> <p>JSON Support:</p> </li> <li> <p>Pros: Standard format</p> </li> <li>Cons: Less human-readable, another format to support</li> <li>Rejected: YAML is more readable</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Flexible format choice</li> <li>\u2705 Content-based discovery</li> <li>\u2705 File merging support</li> <li>\u2705 Backward compatible</li> <li>\u26a0\ufe0f More complex file reading</li> <li>\u26a0\ufe0f Two formats to maintain</li> </ul> <p>Implementation: <pre><code>class CSVDataReader(DataReader):\n    def read_test_cases(self, source: str) -&gt; TestCases:\n        # Read CSV\n\nclass YAMLDataReader(DataReader):\n    def read_test_cases(self, source: str) -&gt; TestCases:\n        # Read YAML\n</code></pre></p>"},{"location":"architecture/decisions/#adr-014-session-based-architecture","title":"ADR-014: Session-Based Architecture","text":"<p>Status: Accepted</p> <p>Context: Framework needs to support multiple concurrent test executions, each with its own configuration, state, and resources. Need isolation between executions.</p> <p>Decision: Use session-based architecture where each test execution has its own session with isolated configuration, drivers, and state.</p> <p>Rationale:</p> <ol> <li>Isolation: Each session is independent</li> <li>Concurrency: Supports multiple concurrent executions</li> <li>Resource Management: Clear lifecycle for resources</li> <li>Configuration: Per-session configuration</li> <li>State Management: Session-scoped state</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Global State:</p> </li> <li> <p>Pros: Simpler</p> </li> <li>Cons: No isolation, race conditions</li> <li> <p>Rejected: Not safe for concurrent execution</p> </li> <li> <p>Thread-Local Storage:</p> </li> <li> <p>Pros: Automatic isolation</p> </li> <li>Cons: Not async-safe, less explicit</li> <li> <p>Rejected: Sessions are more explicit</p> </li> <li> <p>Context Manager:</p> </li> <li> <p>Pros: Automatic cleanup</p> </li> <li>Cons: Less flexible, harder to share</li> <li>Rejected: Sessions need more flexibility</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Session isolation</li> <li>\u2705 Concurrent execution support</li> <li>\u2705 Clear resource lifecycle</li> <li>\u2705 Per-session configuration</li> <li>\u26a0\ufe0f Session management overhead</li> <li>\u26a0\ufe0f Need to pass session_id</li> </ul> <p>Implementation: <pre><code>class SessionManager:\n    def create_session(self, config, ...) -&gt; str:\n        session_id = str(uuid4())\n        session = Session(session_id, config, ...)\n        self.sessions[session_id] = session\n        return session_id\n</code></pre></p>"},{"location":"architecture/decisions/#adr-015-builder-pattern-for-component-construction","title":"ADR-015: Builder Pattern for Component Construction","text":"<p>Status: Accepted</p> <p>Context: Complex component hierarchies need to be constructed with proper dependency injection. Components have dependencies on each other (e.g., element sources need drivers).</p> <p>Decision: Use Builder pattern (OpticsBuilder) to construct component hierarchies with automatic dependency injection.</p> <p>Rationale:</p> <ol> <li>Complex Construction: Handles complex component setup</li> <li>Dependency Injection: Automatically injects dependencies</li> <li>Fluent API: Method chaining for readability</li> <li>Validation: Can validate configuration during construction</li> <li>Flexibility: Supports different component combinations</li> </ol> <p>Alternatives Considered:</p> <ol> <li> <p>Direct Instantiation:</p> </li> <li> <p>Pros: Simple, explicit</p> </li> <li>Cons: Manual dependency management, error-prone</li> <li> <p>Rejected: Too error-prone</p> </li> <li> <p>Factory Methods:</p> </li> <li> <p>Pros: Encapsulates creation</p> </li> <li>Cons: Less flexible, harder to extend</li> <li> <p>Rejected: Builder is more flexible</p> </li> <li> <p>Dependency Injection Container:</p> </li> <li> <p>Pros: Standard DI pattern</p> </li> <li>Cons: More complex, requires container</li> <li>Rejected: Builder is simpler for this use case</li> </ol> <p>Consequences:</p> <ul> <li>\u2705 Handles complex construction</li> <li>\u2705 Automatic dependency injection</li> <li>\u2705 Fluent API</li> <li>\u2705 Configuration validation</li> <li>\u26a0\ufe0f More complex than direct instantiation</li> <li>\u26a0\ufe0f Builder state management</li> </ul> <p>Implementation: <pre><code>builder = OpticsBuilder(session)\nbuilder.add_driver(config)\nbuilder.add_element_source(config)\ndriver = builder.get_driver()\n</code></pre></p>"},{"location":"architecture/decisions/#historical-context","title":"Historical Context","text":""},{"location":"architecture/decisions/#framework-evolution","title":"Framework Evolution","text":"<p>The Optics Framework has evolved through several key phases:</p> <p>Phase 1: Initial Design (Early Development)</p> <ul> <li>Focus on basic automation capabilities</li> <li>Single driver support (Appium)</li> <li>Simple element location (XPath only)</li> <li>CSV-based test cases</li> </ul> <p>Phase 2: Vision Integration</p> <ul> <li>Added OCR and image matching capabilities</li> <li>Multiple location strategies</li> <li>Self-healing mechanism</li> <li>Template-based image location</li> </ul> <p>Phase 3: Extensibility</p> <ul> <li>Factory pattern for dynamic discovery</li> <li>Multiple driver support</li> <li>Plugin architecture for engines</li> <li>Strategy pattern for location</li> </ul> <p>Phase 4: API and CLI</p> <ul> <li>REST API layer</li> <li>CLI interface</li> <li>Session management</li> <li>Event system</li> </ul> <p>Phase 5: Advanced Features</p> <ul> <li>Fallback parameters</li> <li>AOI support</li> <li>Screenshot streaming</li> <li>Performance optimizations</li> </ul>"},{"location":"architecture/decisions/#design-principles-evolution","title":"Design Principles Evolution","text":"<p>Early Principles:</p> <ul> <li>Simplicity</li> <li>Ease of use</li> <li>CSV-based (no code)</li> </ul> <p>Current Principles:</p> <ul> <li>Modularity</li> <li>Extensibility</li> <li>Resilience (self-healing)</li> <li>a bit more focus on Performance</li> <li>Separation of concerns</li> </ul>"},{"location":"architecture/decisions/#key-design-influences","title":"Key Design Influences","text":"<ol> <li>Robot Framework: Keyword-based approach, library pattern</li> <li>Selenium/Appium: Driver abstraction, element location</li> <li>Factory Pattern: Dynamic component creation</li> <li>Strategy Pattern: Multiple location methods</li> <li>Builder Pattern: Complex object construction</li> </ol>"},{"location":"architecture/decisions/#breaking-changes-and-migrations","title":"Breaking Changes and Migrations","text":"<p>None documented yet - Framework is still in active development.</p> <p>Future ADRs should document:</p> <ul> <li>Breaking changes</li> <li>Migration guides</li> <li>Deprecation notices</li> <li>Version compatibility</li> </ul>"},{"location":"architecture/decisions/#contributing-adrs","title":"Contributing ADRs","text":"<p>When making significant architectural decisions:</p> <ol> <li>Create ADR: Document the decision using the ADR format</li> <li>Number Sequentially: Use ADR-XXX format</li> <li>Update This Document: Add to the list above</li> <li>Review: Get team review before implementation</li> <li>Status Tracking: Update status as decision evolves</li> </ol>"},{"location":"architecture/decisions/#adr-status-values","title":"ADR Status Values","text":"<ul> <li>Proposed: Decision under consideration</li> <li>Accepted: Decision made and implemented</li> <li>Deprecated: Decision replaced by newer ADR</li> <li>Superseded: Decision replaced by ADR-XXX</li> </ul>"},{"location":"architecture/decisions/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview - High-level architecture</li> <li>Components - Component implementations</li> <li>Strategies - Strategy pattern implementation</li> <li>Execution - Execution architecture</li> <li>Extending - Extension guidelines</li> </ul>"},{"location":"architecture/engines/","title":"Engine Implementations","text":"<p>This document details the engine implementations in the Optics Framework, including drivers, element sources, and vision models.</p>"},{"location":"architecture/engines/#drivers","title":"Drivers","text":"<p>Drivers are responsible for executing user actions on target applications or devices. All drivers implement the <code>DriverInterface</code> and are located in <code>optics_framework/engines/drivers/</code>.</p>"},{"location":"architecture/engines/#appium-driver","title":"Appium Driver","text":"<p>Location: <code>optics_framework/engines/drivers/appium.py</code></p> <p>The Appium driver provides mobile app automation capabilities for both Android and iOS.</p>"},{"location":"architecture/engines/#key-features","title":"Key Features","text":"<ul> <li>Native mobile app automation</li> <li>Support for Android (UiAutomator2) and iOS (XCUITest)</li> <li>Gesture support (swipe, scroll, tap)</li> <li>Hardware key simulation</li> <li>App lifecycle management</li> </ul>"},{"location":"architecture/engines/#configuration","title":"Configuration","text":"<pre><code>driver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\n      capabilities:\n        platformName: \"Android\"\n        deviceName: \"emulator-5554\"\n        appPackage: \"com.example.app\"\n        appActivity: \".MainActivity\"\n</code></pre>"},{"location":"architecture/engines/#key-methods","title":"Key Methods","text":"<ul> <li><code>launch_app()</code> - Launch with package/activity</li> <li><code>press_coordinates()</code> - Tap at absolute coordinates</li> <li><code>press_element()</code> - Tap UI elements</li> <li><code>swipe()</code> / <code>swipe_percentage(x%, y%, direction, length%)</code> - Swipe gestures (percentages as integers 0-100)</li> <li><code>scroll()</code> - Scroll actions</li> <li><code>enter_text()</code> - Text input</li> <li><code>press_keycode()</code> - Hardware key codes</li> <li><code>get_app_version()</code> - App version info</li> </ul>"},{"location":"architecture/engines/#special-features","title":"Special Features","text":"<ul> <li>Mobile-specific keycodes (BACK, HOME, MENU, etc.)</li> <li>Mobile type command support</li> <li>UI helper integration for element interaction</li> </ul>"},{"location":"architecture/engines/#selenium-driver","title":"Selenium Driver","text":"<p>Location: <code>optics_framework/engines/drivers/selenium.py</code></p> <p>The Selenium driver provides web browser automation capabilities.</p>"},{"location":"architecture/engines/#key-features_1","title":"Key Features","text":"<ul> <li>Cross-browser support (Chrome, Firefox, Edge, Safari)</li> <li>Web element interaction</li> <li>JavaScript execution</li> <li>Window and frame management</li> </ul>"},{"location":"architecture/engines/#configuration_1","title":"Configuration","text":"<pre><code>driver_sources:\n  - selenium:\n      enabled: true\n      url: \"http://localhost:4444\"\n      capabilities:\n        browserName: \"chrome\"\n        version: \"latest\"\n</code></pre>"},{"location":"architecture/engines/#key-methods_1","title":"Key Methods","text":"<ul> <li><code>launch_app()</code> - Navigate to URL</li> <li><code>press_element()</code> - Click web elements</li> <li><code>enter_text()</code> - Form input</li> <li><code>execute_script()</code> - JavaScript execution</li> <li><code>get_text_element()</code> - Extract text from elements</li> </ul>"},{"location":"architecture/engines/#playwright-driver","title":"Playwright Driver","text":"<p>Location: <code>optics_framework/engines/drivers/playwright.py</code></p> <p>The Playwright driver provides modern web automation with better reliability.</p>"},{"location":"architecture/engines/#key-features_2","title":"Key Features","text":"<ul> <li>Modern browser automation</li> <li>Auto-waiting for elements</li> <li>Network interception</li> <li>Multi-browser support</li> </ul>"},{"location":"architecture/engines/#configuration_2","title":"Configuration","text":"<pre><code>driver_sources:\n  - playwright:\n      enabled: true\n      capabilities:\n        browser: \"chromium\"\n        headless: false\n</code></pre>"},{"location":"architecture/engines/#ble-driver","title":"BLE Driver","text":"<p>Location: <code>optics_framework/engines/drivers/ble.py</code></p> <p>The BLE (Bluetooth Low Energy) driver provides non-intrusive automation for production devices.</p>"},{"location":"architecture/engines/#key-features_3","title":"Key Features","text":"<ul> <li>Non-intrusive mouse and keyboard control</li> <li>Serial communication via BLE</li> <li>Coordinate mapping (pixels to mickeys)</li> <li>Production-safe automation</li> </ul>"},{"location":"architecture/engines/#use-cases","title":"Use Cases","text":"<ul> <li>Production app monitoring</li> <li>Devices without USB debugging</li> <li>DRM-protected applications</li> <li>Smart TV automation</li> </ul>"},{"location":"architecture/engines/#configuration_3","title":"Configuration","text":"<pre><code>driver_sources:\n  - ble:\n      enabled: true\n      capabilities:\n        device_id: \"BLE_DEVICE_ID\"\n        port: \"/dev/ttyUSB0\"\n        pixel_width: 1920\n        pixel_height: 1080\n        mickeys_width: 32767\n        mickeys_height: 32767\n        x_invert: 1\n        y_invert: 1\n</code></pre>"},{"location":"architecture/engines/#key-methods_2","title":"Key Methods","text":"<ul> <li><code>press_coordinates()</code> - Mouse click at coordinates</li> <li><code>press_percentage_coordinates()</code> - Percentage-based clicks</li> <li><code>swipe()</code> - Mouse drag gestures</li> <li><code>enter_text_using_keyboard()</code> - Keyboard input</li> <li><code>press_keycode()</code> - Special key codes</li> </ul>"},{"location":"architecture/engines/#coordinate-mapping","title":"Coordinate Mapping","text":"<p>The BLE driver maps screen coordinates to mouse movements (mickeys): - Pixel coordinates \u2192 Mickey coordinates - Supports coordinate inversion - Configurable mapping ratios</p>"},{"location":"architecture/engines/#element-sources","title":"Element Sources","text":"<p>Element sources are responsible for detecting and locating UI elements. They implement <code>ElementSourceInterface</code> and are located in <code>optics_framework/engines/elementsources/</code>.</p>"},{"location":"architecture/engines/#screenshot-based-sources","title":"Screenshot-Based Sources","text":""},{"location":"architecture/engines/#appiumscreenshot","title":"AppiumScreenshot","text":"<p>Location: <code>optics_framework/engines/elementsources/appium_screenshot.py</code></p> <p>Captures screenshots from Appium sessions.</p> <ul> <li>Uses Appium's screenshot capability</li> <li>Returns NumPy arrays for image processing</li> <li>Supports interactive element detection</li> </ul>"},{"location":"architecture/engines/#seleniumscreenshot","title":"SeleniumScreenshot","text":"<p>Location: <code>optics_framework/engines/elementsources/selenium_screenshot.py</code></p> <p>Captures screenshots from Selenium browser sessions.</p> <ul> <li>Browser screenshot capture</li> <li>Full page or viewport screenshots</li> <li>Base64 encoding support</li> </ul>"},{"location":"architecture/engines/#playwrightscreenshot","title":"PlaywrightScreenshot","text":"<p>Location: <code>optics_framework/engines/elementsources/playwright_screenshot.py</code></p> <p>Captures screenshots from Playwright sessions.</p> <ul> <li>High-quality screenshots</li> <li>Multiple screenshot formats</li> <li>Element-specific screenshots</li> </ul>"},{"location":"architecture/engines/#camerascreenshot","title":"CameraScreenshot","text":"<p>Location: <code>optics_framework/engines/elementsources/camera_screenshot.py</code></p> <p>Captures screenshots from external cameras or capture cards.</p> <ul> <li>External camera support</li> <li>Video capture card support</li> <li>Production monitoring use case</li> </ul>"},{"location":"architecture/engines/#page-source-based-sources","title":"Page Source-Based Sources","text":""},{"location":"architecture/engines/#appiumpagesource","title":"AppiumPageSource","text":"<p>Location: <code>optics_framework/engines/elementsources/appium_page_source.py</code></p> <p>Extracts and parses Appium page source XML.</p> <ul> <li>XML-based element location</li> <li>XPath support</li> <li>Element hierarchy navigation</li> <li>Interactive element detection</li> </ul>"},{"location":"architecture/engines/#seleniumpagesource","title":"SeleniumPageSource","text":"<p>Location: <code>optics_framework/engines/elementsources/selenium_page_source.py</code></p> <p>Extracts and parses Selenium page source HTML.</p> <ul> <li>HTML DOM parsing</li> <li>CSS selector support</li> <li>Element attribute extraction</li> </ul>"},{"location":"architecture/engines/#playwrightpagesource","title":"PlaywrightPageSource","text":"<p>Location: <code>optics_framework/engines/elementsources/playwright_page_source.py</code></p> <p>Extracts and parses Playwright page source.</p> <ul> <li>Modern DOM API</li> <li>Accessibility tree support</li> <li>Element state detection</li> </ul>"},{"location":"architecture/engines/#find-element-sources","title":"Find Element Sources","text":""},{"location":"architecture/engines/#appiumfindelement","title":"AppiumFindElement","text":"<p>Location: <code>optics_framework/engines/elementsources/appium_find_element.py</code></p> <p>Direct element location using Appium's find element methods.</p> <ul> <li>Multiple locator strategies</li> <li>Element interaction</li> <li>Element state checking</li> </ul>"},{"location":"architecture/engines/#seleniumfindelement","title":"SeleniumFindElement","text":"<p>Location: <code>optics_framework/engines/elementsources/selenium_find_element.py</code></p> <p>Direct element location using Selenium's find element methods.</p> <ul> <li>WebDriver locator strategies</li> <li>Element waiting</li> <li>Element interaction</li> </ul>"},{"location":"architecture/engines/#playwrightfindelement","title":"PlaywrightFindElement","text":"<p>Location: <code>optics_framework/engines/elementsources/playwright_find_element.py</code></p> <p>Direct element location using Playwright's locator API.</p> <ul> <li>Auto-waiting for elements</li> <li>Multiple locator types</li> <li>Element state queries</li> </ul>"},{"location":"architecture/engines/#element-source-selection","title":"Element Source Selection","text":"<p>Element sources are automatically matched with compatible drivers:</p> <pre><code># Element source declares required driver type\nREQUIRED_DRIVER_TYPE = \"appium\"\n\n# Factory automatically matches with Appium driver\nElementSourceFactory.get_driver(config, driver_fallback)\n</code></pre>"},{"location":"architecture/engines/#vision-models","title":"Vision Models","text":"<p>Vision models provide image and text detection capabilities. They are located in <code>optics_framework/engines/vision_models/</code>.</p>"},{"location":"architecture/engines/#image-detection-models","title":"Image Detection Models","text":""},{"location":"architecture/engines/#templatematch","title":"TemplateMatch","text":"<p>Location: <code>optics_framework/engines/vision_models/image_models/templatematch.py</code></p> <p>OpenCV-based template matching using SIFT and FLANN.</p>"},{"location":"architecture/engines/#key-features_4","title":"Key Features","text":"<ul> <li>SIFT feature detection</li> <li>FLANN-based matching</li> <li>Confidence thresholding</li> <li>Multiple match support (index-based)</li> <li>Template loading from project directory</li> </ul>"},{"location":"architecture/engines/#configuration_4","title":"Configuration","text":"<pre><code>image_detection:\n  - templatematch:\n      enabled: true\n      project_path: \"/path/to/project\"\n      execution_output_path: \"/path/to/output\"\n</code></pre>"},{"location":"architecture/engines/#methods","title":"Methods","text":"<ul> <li><code>find_element()</code> - Locate template in image</li> <li><code>element_exist()</code> - Check if template exists</li> <li><code>assert_elements()</code> - Verify multiple templates</li> </ul>"},{"location":"architecture/engines/#algorithm","title":"Algorithm","text":"<ol> <li>Load template image from project directory</li> <li>Convert input and template to grayscale</li> <li>Detect SIFT keypoints and descriptors</li> <li>Match descriptors using FLANN</li> <li>Filter matches by distance ratio</li> <li>Calculate homography for geometric verification</li> <li>Return center coordinates of matched template</li> </ol>"},{"location":"architecture/engines/#remoteoir","title":"RemoteOIR","text":"<p>Location: <code>optics_framework/engines/vision_models/image_models/remote_oir.py</code></p> <p>Remote Object Image Recognition service integration.</p>"},{"location":"architecture/engines/#key-features_5","title":"Key Features","text":"<ul> <li>Remote service-based matching</li> <li>API integration</li> <li>High-accuracy matching</li> <li>Cloud-based processing</li> </ul>"},{"location":"architecture/engines/#configuration_5","title":"Configuration","text":"<pre><code>image_detection:\n  - remote_oir:\n      enabled: true\n      url: \"https://api.example.com/oir\"\n      api_key: \"your-api-key\"\n</code></pre>"},{"location":"architecture/engines/#ocrtext-detection-models","title":"OCR/Text Detection Models","text":""},{"location":"architecture/engines/#easyocr","title":"EasyOCR","text":"<p>Location: <code>optics_framework/engines/vision_models/ocr_models/easyocr.py</code></p> <p>EasyOCR library integration for text detection.</p>"},{"location":"architecture/engines/#key-features_6","title":"Key Features","text":"<ul> <li>Multi-language support</li> <li>High accuracy</li> <li>Bounding box detection</li> <li>Confidence scores</li> </ul>"},{"location":"architecture/engines/#configuration_6","title":"Configuration","text":"<pre><code>text_detection:\n  - easyocr:\n      enabled: true\n      languages: [\"en\"]\n      gpu: true\n</code></pre>"},{"location":"architecture/engines/#methods_1","title":"Methods","text":"<ul> <li><code>detect_text()</code> - Full text detection</li> <li><code>find_element()</code> - Locate specific text</li> <li><code>element_exist()</code> - Check text presence</li> </ul>"},{"location":"architecture/engines/#googlevision","title":"GoogleVision","text":"<p>Location: <code>optics_framework/engines/vision_models/ocr_models/googlevision.py</code></p> <p>Google Cloud Vision API integration.</p>"},{"location":"architecture/engines/#key-features_7","title":"Key Features","text":"<ul> <li>Cloud-based OCR</li> <li>High accuracy</li> <li>Document text detection</li> <li>Handwriting recognition</li> </ul>"},{"location":"architecture/engines/#configuration_7","title":"Configuration","text":"<pre><code>text_detection:\n  - googlevision:\n      enabled: true\n      credentials_path: \"/path/to/credentials.json\"\n      project_id: \"your-project-id\"\n</code></pre>"},{"location":"architecture/engines/#pytesseract","title":"PyTesseract","text":"<p>Location: <code>optics_framework/engines/vision_models/ocr_models/pytesseract.py</code></p> <p>Tesseract OCR engine integration.</p>"},{"location":"architecture/engines/#key-features_8","title":"Key Features","text":"<ul> <li>Open-source OCR</li> <li>Multiple language support</li> <li>Configurable OCR modes</li> <li>Page segmentation modes</li> </ul>"},{"location":"architecture/engines/#configuration_8","title":"Configuration","text":"<pre><code>text_detection:\n  - pytesseract:\n      enabled: true\n      lang: \"eng\"\n      config: \"--psm 6\"\n</code></pre>"},{"location":"architecture/engines/#remoteocr","title":"RemoteOCR","text":"<p>Location: <code>optics_framework/engines/vision_models/ocr_models/remote_ocr.py</code></p> <p>Remote OCR service integration.</p>"},{"location":"architecture/engines/#key-features_9","title":"Key Features","text":"<ul> <li>Remote service-based OCR</li> <li>API integration</li> <li>Custom OCR engines</li> <li>Scalable processing</li> </ul>"},{"location":"architecture/engines/#configuration_9","title":"Configuration","text":"<pre><code>text_detection:\n  - remote_ocr:\n      enabled: true\n      url: \"https://api.example.com/ocr\"\n      api_key: \"your-api-key\"\n</code></pre>"},{"location":"architecture/engines/#engine-discovery-and-loading","title":"Engine Discovery and Loading","text":"<p>Engines are automatically discovered by the factory system:</p> <pre><code>graph LR\n    A[Factory] --&gt; B[Scan Package]\n    B --&gt; C[Discover Modules]\n    C --&gt; D[Load Classes]\n    D --&gt; E[Check Interface]\n    E --&gt; F[Register]\n    F --&gt; G[Instantiate on Demand]</code></pre>"},{"location":"architecture/engines/#discovery-process","title":"Discovery Process","text":"<ol> <li>Factory scans package directory (<code>engines/drivers/</code>, etc.)</li> <li>Discovers all Python modules</li> <li>Imports modules dynamically</li> <li>Inspects classes for interface implementation</li> <li>Registers implementations in module registry</li> <li>Instantiates on demand based on configuration</li> </ol>"},{"location":"architecture/engines/#configuration-based-selection","title":"Configuration-Based Selection","text":"<p>Engines are selected based on configuration:</p> <pre><code>driver_sources:\n  - appium: {...}      # First priority\n  - selenium: {...}     # Fallback\n</code></pre> <p>The factory creates <code>InstanceFallback</code> wrapper that tries each in order.</p>"},{"location":"architecture/engines/#extension-guide","title":"Extension Guide","text":""},{"location":"architecture/engines/#adding-a-new-driver","title":"Adding a New Driver","text":"<ol> <li>Create file in <code>optics_framework/engines/drivers/your_driver.py</code></li> <li>Implement <code>DriverInterface</code></li> <li>Set class attributes:    <pre><code>DEPENDENCY_TYPE = \"driver_sources\"\nNAME = \"your_driver\"\n</code></pre></li> <li>Factory automatically discovers it</li> </ol>"},{"location":"architecture/engines/#adding-a-new-element-source","title":"Adding a New Element Source","text":"<ol> <li>Create file in <code>optics_framework/engines/elementsources/your_source.py</code></li> <li>Implement <code>ElementSourceInterface</code></li> <li>If driver-dependent, set:    <pre><code>REQUIRED_DRIVER_TYPE = \"appium\"  # or \"selenium\", \"playwright\", etc.\n</code></pre></li> <li>Factory automatically matches with compatible driver</li> </ol>"},{"location":"architecture/engines/#adding-a-new-vision-model","title":"Adding a New Vision Model","text":"<ol> <li>Create file in appropriate subdirectory:</li> <li><code>image_models/</code> for image detection</li> <li><code>ocr_models/</code> for text detection</li> <li>Implement <code>ImageInterface</code> or <code>TextInterface</code></li> <li>Factory automatically discovers it</li> </ol>"},{"location":"architecture/engines/#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling: Always handle driver initialization failures gracefully</li> <li>Resource Cleanup: Implement proper cleanup in <code>terminate()</code> methods</li> <li>Configuration Validation: Validate configuration in <code>__init__</code></li> <li>Logging: Use <code>internal_logger</code> for debug information</li> <li>Event Tracking: Integrate with <code>EventSDK</code> for action tracking</li> <li>Fallback Support: Design for graceful degradation</li> </ol>"},{"location":"architecture/engines/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Screenshot Caching: Element sources may cache screenshots</li> <li>Connection Pooling: Drivers should reuse connections when possible</li> <li>Lazy Loading: Engines are loaded on demand, not at startup</li> <li>Parallel Execution: Multiple engines can run in parallel for fallback</li> </ul>"},{"location":"architecture/engines/#related-documentation","title":"Related Documentation","text":"<ul> <li>Components - Component architecture and factory system</li> <li>Strategies - Strategy pattern and element location</li> <li>Execution - Test execution</li> <li>Extending - Creating custom engines</li> <li>Error Handling - Error codes and handling</li> <li>Architecture Decisions - Factory pattern and engine design decisions</li> <li>Factory System - Dynamic module discovery</li> </ul>"},{"location":"architecture/error_handling/","title":"Error Handling System","text":"<p>The Optics Framework uses a structured error handling system that provides consistent error codes, categories, and error propagation across all layers. This document explains the error handling architecture, error codes, and how errors flow through the system.</p>"},{"location":"architecture/error_handling/#overview","title":"Overview","text":"<p>The error handling system consists of:</p> <ol> <li>Error Codes - Structured error identifiers with categories</li> <li>OpticsError - Custom exception class with metadata</li> <li>Error Registry - Centralized error code definitions</li> <li>Error Propagation - How errors flow through layers</li> <li>Error Recovery - Fallback and retry mechanisms</li> </ol>"},{"location":"architecture/error_handling/#error-code-structure","title":"Error Code Structure","text":"<p>Location: <code>optics_framework/common/error.py</code></p>"},{"location":"architecture/error_handling/#error-code-format","title":"Error Code Format","text":"<p>Error codes follow a structured format:</p> <pre><code>[Severity][Category][Number]\n</code></pre>"},{"location":"architecture/error_handling/#severity-prefixes","title":"Severity Prefixes","text":"<ul> <li>E - Error (default severity)</li> <li>W - Warning (non-fatal)</li> <li>X - Exception (critical/unhandled)</li> </ul>"},{"location":"architecture/error_handling/#categories","title":"Categories","text":"<p>Error codes are organized by category:</p> <ul> <li>01 - Driver issues</li> <li>02 - Element location issues</li> <li>03 - Screenshot issues</li> <li>04 - Keyword execution issues</li> <li>05 - Config/File issues</li> <li>06 - Module/Factory issues</li> <li>07 - Test case issues</li> <li>08 - General issues</li> </ul>"},{"location":"architecture/error_handling/#examples","title":"Examples","text":"<pre><code>E0101 - Driver not initialized (Error, Driver category)\nW0104 - Driver config incomplete (Warning, Driver category)\nX0201 - Element not found after all fallbacks (Exception, Element category)\nE0402 - Keyword not found (Error, Keyword category)\n</code></pre>"},{"location":"architecture/error_handling/#error-registry","title":"Error Registry","text":"<p>The error registry (<code>ERROR_REGISTRY</code>) contains all defined error codes with their specifications:</p> <pre><code>ERROR_REGISTRY = {\n    \"E0101\": ErrorSpec(\n        code=Code.E0101,\n        default_message=\"Driver not initialized\",\n        category=Category.DRIVER,\n        default_status=500,\n    ),\n    \"E0201\": ErrorSpec(\n        code=Code.E0201,\n        default_message=\"Element not found\",\n        category=Category.ELEMENT,\n        default_status=404,\n    ),\n    # ... more error codes\n}\n</code></pre>"},{"location":"architecture/error_handling/#errorspec-structure","title":"ErrorSpec Structure","text":"<p>Each error specification includes:</p> <ul> <li>code: Error code enum value</li> <li>default_message: Default error message</li> <li>category: Error category (Driver, Element, etc.)</li> <li>default_status: HTTP status code (for API responses)</li> <li>meta: Optional metadata</li> </ul>"},{"location":"architecture/error_handling/#opticserror-exception","title":"OpticsError Exception","text":"<p>The <code>OpticsError</code> class is the primary exception type used throughout the framework.</p>"},{"location":"architecture/error_handling/#creating-opticserror","title":"Creating OpticsError","text":"<pre><code>from optics_framework.common.error import OpticsError, Code\n\n# Using error code\nraise OpticsError(Code.E0101, message=\"Custom message\", details={\"driver\": \"appium\"})\n\n# Using string code\nraise OpticsError(\"E0101\", message=\"Driver initialization failed\")\n\n# With details\nraise OpticsError(\n    Code.E0201,\n    message=\"Element not found\",\n    details={\"element\": \"submit_button\", \"strategies_tried\": [\"xpath\", \"ocr\"]},\n    cause=original_exception\n)\n</code></pre>"},{"location":"architecture/error_handling/#opticserror-attributes","title":"OpticsError Attributes","text":"<ul> <li>code: Error code (Code enum or string)</li> <li>category: Error category</li> <li>status_code: HTTP status code</li> <li>message: Human-readable message</li> <li>details: Additional error context</li> <li>meta: Optional metadata</li> <li>cause: Original exception (if any)</li> </ul>"},{"location":"architecture/error_handling/#error-logging","title":"Error Logging","text":"<p>OpticsError includes rich logging capabilities:</p> <pre><code>error = OpticsError(Code.E0101, message=\"Driver failed\")\nerror.log()  # Prints formatted error with rich formatting\nerror.log(use_rich=False)  # Uses standard logging\n</code></pre>"},{"location":"architecture/error_handling/#error-categories","title":"Error Categories","text":""},{"location":"architecture/error_handling/#driver-errors-01xx","title":"Driver Errors (01xx)","text":"<p>Driver-related errors:</p> <ul> <li>E0101: Driver not initialized</li> <li>E0102: Failed to start session</li> <li>E0103: Failed to end session</li> <li>E0104: Driver config incomplete</li> <li>W0104: Driver config incomplete (warning)</li> </ul> <p>Example: <pre><code>if not self.driver:\n    raise OpticsError(Code.E0101, message=\"Appium driver not initialized\")\n</code></pre></p>"},{"location":"architecture/error_handling/#element-errors-02xx","title":"Element Errors (02xx)","text":"<p>Element location errors:</p> <ul> <li>E0201: Element not found</li> <li>X0201: Element not found after all fallbacks</li> <li>E0202: Unsupported operation for element source</li> <li>W0203: Element format mismatch</li> <li>E0204: Timeout locating element</li> <li>E0205: Invalid element type</li> </ul> <p>Example: <pre><code>if not element:\n    raise OpticsError(\n        Code.E0201,\n        message=f\"Element '{element_id}' not found\",\n        details={\"strategies\": [\"xpath\", \"ocr\", \"image\"]}\n    )\n</code></pre></p>"},{"location":"architecture/error_handling/#screenshot-errors-03xx","title":"Screenshot Errors (03xx)","text":"<p>Screenshot-related errors:</p> <ul> <li>E0301: Screenshot disabled</li> <li>W0302: Fallback to next camera supported driver</li> <li>E0303: Screenshot empty/black</li> </ul> <p>Example: <pre><code>if screenshot is None or is_black_screen(screenshot):\n    raise OpticsError(Code.E0303, message=\"Screenshot is empty or black\")\n</code></pre></p>"},{"location":"architecture/error_handling/#keyword-errors-04xx","title":"Keyword Errors (04xx)","text":"<p>Keyword execution errors:</p> <ul> <li>E0401: Action failed</li> <li>X0401: Action failed with exception</li> <li>E0402: Keyword not found</li> <li>E0403: Invalid keyword parameters</li> <li>W0404: Keyword deprecated</li> </ul> <p>Example: <pre><code>if keyword not in registry:\n    raise OpticsError(\n        Code.E0402,\n        message=f\"Keyword '{keyword}' not found\",\n        details={\"available_keywords\": list(registry.keys())}\n    )\n</code></pre></p>"},{"location":"architecture/error_handling/#config-errors-05xx","title":"Config Errors (05xx)","text":"<p>Configuration and file errors:</p> <ul> <li>E0501: Missing required files</li> <li>X0502: File read exception</li> <li>E0503: Config parser error (important param)</li> <li>W0503: Config parser warning (can be ignored)</li> </ul> <p>Example: <pre><code>if not os.path.exists(config_path):\n    raise OpticsError(\n        Code.E0501,\n        message=f\"Configuration file not found: {config_path}\",\n        details={\"path\": config_path}\n    )\n</code></pre></p>"},{"location":"architecture/error_handling/#modulefactory-errors-06xx","title":"Module/Factory Errors (06xx)","text":"<p>Module and factory errors:</p> <ul> <li>E0601: Module not found</li> <li>W0602: No valid instances, ignoring it</li> <li>E0603: Factory init failed</li> <li>X0604: Import related problem</li> </ul> <p>Example: <pre><code>try:\n    module = importlib.import_module(module_name)\nexcept ImportError as e:\n    raise OpticsError(\n        Code.X0604,\n        message=f\"Failed to import module: {module_name}\",\n        cause=e\n    )\n</code></pre></p>"},{"location":"architecture/error_handling/#test-case-errors-07xx","title":"Test Case Errors (07xx)","text":"<p>Test case execution errors:</p> <ul> <li>E0701: Execution failed</li> <li>E0702: Test case not found</li> <li>E0703: Parameter resolution failed</li> <li>E0704: Test case timeout</li> <li>W0705: Test case skipped</li> </ul> <p>Example: <pre><code>if test_case_id not in session.test_cases:\n    raise OpticsError(\n        Code.E0702,\n        message=f\"Test case '{test_case_id}' not found\",\n        details={\"session_id\": session.session_id}\n    )\n</code></pre></p>"},{"location":"architecture/error_handling/#general-errors-08xx","title":"General Errors (08xx)","text":"<p>General framework errors:</p> <ul> <li>E0801: Unexpected error</li> <li>E0802: Unhandled exception</li> </ul> <p>Example: <pre><code>except Exception as e:\n    raise OpticsError(\n        Code.E0802,\n        message=\"Unhandled exception occurred\",\n        cause=e,\n        details={\"context\": \"keyword_execution\"}\n    )\n</code></pre></p>"},{"location":"architecture/error_handling/#error-propagation-flow","title":"Error Propagation Flow","text":"<p>Errors propagate through the framework layers:</p> <pre><code>graph TB\n    A[Driver Layer] --&gt;|OpticsError| B[Strategy Layer]\n    B --&gt;|OpticsError| C[API Layer]\n    C --&gt;|OpticsError| D[Execution Layer]\n    D --&gt;|OpticsError| E[Event System]\n    E --&gt;|Log/Report| F[User/CLI]\n\n    B --&gt;|Fallback| G[Next Strategy]\n    G --&gt;|Success| H[Continue]\n    G --&gt;|OpticsError| I[All Failed]</code></pre>"},{"location":"architecture/error_handling/#propagation-rules","title":"Propagation Rules","text":"<ol> <li>Driver Layer: Raises OpticsError for driver-specific issues</li> <li>Strategy Layer: Catches errors, tries fallback strategies</li> <li>API Layer: Wraps errors with context, propagates to execution</li> <li>Execution Layer: Handles errors, publishes events, continues or stops</li> <li>Event System: Logs errors, publishes error events</li> </ol>"},{"location":"architecture/error_handling/#error-context-preservation","title":"Error Context Preservation","text":"<p>Errors preserve context as they propagate:</p> <pre><code>try:\n    element = strategy.locate(element_id)\nexcept OpticsError as e:\n    # Add context\n    raise OpticsError(\n        e.code,\n        message=f\"Failed to locate element in {strategy.__class__.__name__}\",\n        details={**e.details, \"strategy\": strategy.__class__.__name__},\n        cause=e\n    )\n</code></pre>"},{"location":"architecture/error_handling/#error-recovery-mechanisms","title":"Error Recovery Mechanisms","text":""},{"location":"architecture/error_handling/#1-strategy-fallback","title":"1. Strategy Fallback","text":"<p>When element location fails, try next strategy:</p> <pre><code>for strategy in strategies:\n    try:\n        result = strategy.locate(element)\n        return result\n    except OpticsError as e:\n        if e.code == Code.E0201:  # Element not found\n            continue  # Try next strategy\n        raise  # Re-raise other errors\n</code></pre>"},{"location":"architecture/error_handling/#2-driver-fallback","title":"2. Driver Fallback","text":"<p>When driver fails, try next driver:</p> <pre><code>for driver in driver_fallback.instances:\n    try:\n        driver.press_element(element)\n        return\n    except OpticsError as e:\n        if e.code in [Code.E0101, Code.E0102]:  # Driver errors\n            continue  # Try next driver\n        raise\n</code></pre>"},{"location":"architecture/error_handling/#3-retry-logic","title":"3. Retry Logic","text":"<p>Some operations include retry logic:</p> <pre><code>max_retries = 3\nfor attempt in range(max_retries):\n    try:\n        return operation()\n    except OpticsError as e:\n        if attempt &lt; max_retries - 1:\n            time.sleep(2 ** attempt)  # Exponential backoff\n            continue\n        raise\n</code></pre>"},{"location":"architecture/error_handling/#4-graceful-degradation","title":"4. Graceful Degradation","text":"<p>Some errors are warnings that allow execution to continue:</p> <pre><code>try:\n    screenshot = element_source.capture()\nexcept OpticsError as e:\n    if e.code == Code.W0302:  # Warning\n        # Try fallback screenshot source\n        screenshot = fallback_source.capture()\n    else:\n        raise\n</code></pre>"},{"location":"architecture/error_handling/#error-handling-in-api-layer","title":"Error Handling in API Layer","text":"<p>The REST API converts OpticsError to HTTP responses:</p> <pre><code>from optics_framework.common.error import OpticsError\n\ntry:\n    result = execute_keyword(keyword, params)\nexcept OpticsError as e:\n    return JSONResponse(\n        status_code=e.status_code,\n        content=e.to_payload(include_status=True)\n    )\n</code></pre>"},{"location":"architecture/error_handling/#api-error-response-format","title":"API Error Response Format","text":"<pre><code>{\n  \"type\": \"optics:driver\",\n  \"code\": \"E0101\",\n  \"status\": 500,\n  \"message\": \"Driver not initialized\",\n  \"details\": {\n    \"driver\": \"appium\",\n    \"session_id\": \"abc123\"\n  }\n}\n</code></pre>"},{"location":"architecture/error_handling/#error-handling-best-practices","title":"Error Handling Best Practices","text":""},{"location":"architecture/error_handling/#1-use-appropriate-error-codes","title":"1. Use Appropriate Error Codes","text":"<p>Choose error codes that match the error category:</p> <pre><code># Good\nraise OpticsError(Code.E0201, message=\"Element not found\")\n\n# Bad - wrong category\nraise OpticsError(Code.E0101, message=\"Element not found\")  # Should be E0201\n</code></pre>"},{"location":"architecture/error_handling/#2-include-context-in-details","title":"2. Include Context in Details","text":"<p>Provide useful debugging information:</p> <pre><code>raise OpticsError(\n    Code.E0201,\n    message=\"Element not found\",\n    details={\n        \"element\": element_id,\n        \"strategies_tried\": [\"xpath\", \"ocr\"],\n        \"screenshot_path\": \"/path/to/screenshot.png\"\n    }\n)\n</code></pre>"},{"location":"architecture/error_handling/#3-preserve-original-exceptions","title":"3. Preserve Original Exceptions","text":"<p>Use <code>cause</code> parameter to preserve exception chain:</p> <pre><code>try:\n    driver.connect()\nexcept ConnectionError as e:\n    raise OpticsError(\n        Code.E0102,\n        message=\"Failed to connect to driver\",\n        cause=e\n    )\n</code></pre>"},{"location":"architecture/error_handling/#4-use-warnings-for-non-critical-issues","title":"4. Use Warnings for Non-Critical Issues","text":"<p>Use warning codes for issues that don't stop execution:</p> <pre><code>if config.get(\"optional_setting\") is None:\n    raise OpticsError(\n        Code.W0503,\n        message=\"Optional setting not configured, using default\"\n    )\n</code></pre>"},{"location":"architecture/error_handling/#5-handle-errors-at-appropriate-levels","title":"5. Handle Errors at Appropriate Levels","text":"<p>Handle errors where recovery is possible:</p> <pre><code># Strategy level - try fallback\ntry:\n    return xpath_strategy.locate(element)\nexcept OpticsError:\n    return ocr_strategy.locate(element)  # Fallback\n\n# Execution level - stop execution\ntry:\n    execute_test_case(test_case)\nexcept OpticsError as e:\n    publish_error_event(e)\n    raise  # Stop execution\n</code></pre>"},{"location":"architecture/error_handling/#error-logging_1","title":"Error Logging","text":""},{"location":"architecture/error_handling/#structured-logging","title":"Structured Logging","text":"<p>OpticsError integrates with the logging system:</p> <pre><code>error = OpticsError(Code.E0101, message=\"Driver failed\")\nerror.log()  # Logs with rich formatting\nerror.log(level=logging.WARNING)  # Custom log level\nerror.log(extra={\"session_id\": session_id})  # Additional context\n</code></pre>"},{"location":"architecture/error_handling/#error-log-format","title":"Error Log Format","text":"<pre><code>\u274c E0101 (driver)\nDriver not initialized\n\nDetails: {'driver': 'appium', 'session_id': 'abc123'}\n</code></pre>"},{"location":"architecture/error_handling/#debugging-errors","title":"Debugging Errors","text":""},{"location":"architecture/error_handling/#1-enable-debug-logging","title":"1. Enable Debug Logging","text":"<pre><code>import logging\nlogging.getLogger(\"optics_framework\").setLevel(logging.DEBUG)\n</code></pre>"},{"location":"architecture/error_handling/#2-check-error-details","title":"2. Check Error Details","text":"<pre><code>try:\n    operation()\nexcept OpticsError as e:\n    print(f\"Code: {e.code}\")\n    print(f\"Category: {e.category}\")\n    print(f\"Details: {e.details}\")\n    print(f\"Cause: {e.__cause__}\")\n</code></pre>"},{"location":"architecture/error_handling/#3-error-code-lookup","title":"3. Error Code Lookup","text":"<p>Reference the error registry:</p> <pre><code>from optics_framework.common.error import ERROR_REGISTRY\n\nspec = ERROR_REGISTRY.get(\"E0101\")\nprint(f\"Message: {spec.default_message}\")\nprint(f\"Category: {spec.category}\")\nprint(f\"Status: {spec.default_status}\")\n</code></pre>"},{"location":"architecture/error_handling/#extending-error-handling","title":"Extending Error Handling","text":""},{"location":"architecture/error_handling/#registering-custom-error-codes","title":"Registering Custom Error Codes","text":"<pre><code>from optics_framework.common.error import ErrorSpec, Category, Code, register_error\n\ncustom_code = Code(\"E0901\")  # Custom code\nspec = ErrorSpec(\n    code=custom_code,\n    default_message=\"Custom error\",\n    category=Category.GENERAL,\n    default_status=500\n)\nregister_error(spec)\n</code></pre>"},{"location":"architecture/error_handling/#custom-error-classes","title":"Custom Error Classes","text":"<pre><code>class CustomOpticsError(OpticsError):\n    def __init__(self, custom_field, **kwargs):\n        super().__init__(**kwargs)\n        self.custom_field = custom_field\n</code></pre>"},{"location":"architecture/error_handling/#related-documentation","title":"Related Documentation","text":"<ul> <li>Components - Component error handling</li> <li>Strategies - Strategy fallback mechanisms</li> <li>Execution - Execution error handling</li> <li>API Layer - API error handling</li> <li>Logging - Error logging patterns</li> <li>Architecture Decisions - Error handling design decisions</li> <li>REST API Usage - REST API error responses</li> <li>API Reference - Python API documentation</li> </ul>"},{"location":"architecture/event_system/","title":"Event System and EventSDK","text":"<p>The Optics Framework includes a comprehensive event tracking system that captures execution events and sends them to external services for monitoring and analytics. This document explains how the event system works, including EventSDK integration, event attributes, and submission modes.</p>"},{"location":"architecture/event_system/#overview","title":"Overview","text":"<p>The event system consists of two main components:</p> <ol> <li>EventManager - Internal event system for execution tracking (see Execution)</li> <li>EventSDK - External event tracking SDK for analytics and monitoring</li> </ol> <p>This document focuses on EventSDK, which is used for tracking user actions and sending events to external services.</p>"},{"location":"architecture/event_system/#eventsdk-architecture","title":"EventSDK Architecture","text":"<pre><code>graph TB\n    A[Driver Action] --&gt; B[EventSDK]\n    B --&gt; C{Event Mode}\n    C --&gt;|Real-time| D[Send Immediately]\n    C --&gt;|Batch| E[Buffer Events]\n    E --&gt; F[Send After Execution]\n    B --&gt; G[Event Attributes JSON]\n    G --&gt; H[Form Event Data]\n    H --&gt; I[External API]</code></pre>"},{"location":"architecture/event_system/#eventsdk-component","title":"EventSDK Component","text":"<p>Location: <code>optics_framework/common/eventSDK.py</code></p> <p>The <code>EventSDK</code> class provides event tracking capabilities for monitoring test execution and user actions.</p>"},{"location":"architecture/event_system/#initialization","title":"Initialization","text":"<p>EventSDK is initialized with a <code>ConfigHandler</code> instance:</p> <pre><code>from optics_framework.common.config_handler import ConfigHandler\nfrom optics_framework.common.eventSDK import EventSDK\n\nconfig_handler = ConfigHandler(config)\nevent_sdk = EventSDK(config_handler)\n</code></pre>"},{"location":"architecture/event_system/#key-responsibilities","title":"Key Responsibilities","text":"<ul> <li>Event capture and formatting</li> <li>Event attribute management</li> <li>Real-time and batch event submission</li> <li>Integration with test context</li> <li>Event buffering and retry logic</li> </ul>"},{"location":"architecture/event_system/#event-attributes-configuration","title":"Event Attributes Configuration","text":"<p>EventSDK uses a JSON configuration file to define event attributes and metadata.</p>"},{"location":"architecture/event_system/#configuration-structure","title":"Configuration Structure","text":"<p>The event attributes JSON file should contain:</p> <pre><code>{\n  \"eventUrl\": \"https://api.example.com\",\n  \"testParameters_bearer\": \"your-bearer-token\",\n  \"applicationName\": \"MyApp\",\n  \"appVersion\": \"1.0.0\"\n}\n</code></pre>"},{"location":"architecture/event_system/#configuration-fields","title":"Configuration Fields","text":"<ul> <li>eventUrl: Base URL for the event submission API</li> <li>testParameters_bearer: Bearer token for API authentication</li> <li>applicationName: Name of the application under test</li> <li>appVersion: Version of the application under test</li> </ul>"},{"location":"architecture/event_system/#loading-event-attributes","title":"Loading Event Attributes","text":"<p>EventSDK loads the event attributes JSON file during initialization:</p> <pre><code>def __init__(self, config_handler: ConfigHandler):\n    self.config_handler = config_handler\n    self.event_attributes_json_path = self.config_handler.config.event_attributes_json\n    self.event_attributes_data = self._load_event_attributes_json()\n</code></pre> <p>The file path is specified in the main configuration:</p> <pre><code>event_attributes_json: \"/path/to/event_attributes.json\"\n</code></pre>"},{"location":"architecture/event_system/#event-capture","title":"Event Capture","text":""},{"location":"architecture/event_system/#basic-event-capture","title":"Basic Event Capture","text":"<p>Events are captured using the <code>capture_event()</code> method:</p> <pre><code>event_sdk.capture_event(\n    event_name=\"button_clicked\",\n    button_id=\"submit\",\n    screen=\"login\",\n    timestamp=\"2024-01-01T12:00:00\"\n)\n</code></pre>"},{"location":"architecture/event_system/#event-structure","title":"Event Structure","text":"<p>Each captured event contains:</p> <ol> <li>Event Name: Identifier for the event type</li> <li>Event Attributes: Key-value pairs with event data</li> <li>Mozark Event Attributes: Additional metadata from configuration</li> <li>DateTime: Automatically added timestamp</li> </ol>"},{"location":"architecture/event_system/#automatic-attributes","title":"Automatic Attributes","text":"<p>EventSDK automatically adds the following attributes:</p> <ul> <li><code>dateTime</code>: Current timestamp in ISO format</li> <li><code>testCaseName</code>: Current test case name (from test context)</li> <li><code>applicationName</code>: From event attributes JSON</li> <li><code>applicationVersion</code>: From event attributes JSON</li> </ul>"},{"location":"architecture/event_system/#event-format","title":"Event Format","text":"<p>The final event structure looks like:</p> <pre><code>{\n  \"eventName\": \"button_clicked\",\n  \"eventAttributes\": {\n    \"dateTime\": \"2024-01-01T12:00:00+05:30\",\n    \"testCaseName\": \"test_login\",\n    \"applicationName\": \"MyApp\",\n    \"applicationVersion\": \"1.0.0\",\n    \"button_id\": \"submit\",\n    \"screen\": \"login\"\n  },\n  \"mozarkEventAttributes\": {\n    \"applicationName\": \"MyApp\"\n  }\n}\n</code></pre>"},{"location":"architecture/event_system/#event-submission-modes","title":"Event Submission Modes","text":"<p>EventSDK supports two submission modes:</p>"},{"location":"architecture/event_system/#1-real-time-submission","title":"1. Real-Time Submission","text":"<p>Events are sent immediately as they occur:</p> <pre><code>event_sdk.submit_single_event(\n    event_name=\"action_completed\",\n    event_attributes={\"action\": \"press_element\"},\n    real_time=True,\n    time_interval=1.0  # Send every 1 second\n)\n</code></pre> <p>Characteristics: - Events are sent immediately - Uses threading.Timer for scheduled submission - Suitable for live monitoring - Higher network overhead</p>"},{"location":"architecture/event_system/#2-batch-submission","title":"2. Batch Submission","text":"<p>Events are buffered and sent after execution:</p> <pre><code>event_sdk.submit_single_event(\n    event_name=\"action_completed\",\n    event_attributes={\"action\": \"press_element\"},\n    real_time=False\n)\n</code></pre> <p>Characteristics: - Events are buffered in memory - Sent in batches of 5 events - Lower network overhead - Suitable for post-execution analytics</p>"},{"location":"architecture/event_system/#batch-submission-flow","title":"Batch Submission Flow","text":"<pre><code>sequenceDiagram\n    participant Driver\n    participant EventSDK\n    participant Buffer\n    participant API\n\n    Driver-&gt;&gt;EventSDK: capture_event()\n    EventSDK-&gt;&gt;Buffer: append event\n    Note over Buffer: Buffer events\n    Driver-&gt;&gt;EventSDK: send_all_events()\n    EventSDK-&gt;&gt;Buffer: get batch (5 events)\n    Buffer-&gt;&gt;API: POST /v1/event/batchevent\n    API--&gt;&gt;EventSDK: success\n    EventSDK-&gt;&gt;Buffer: clear sent events</code></pre>"},{"location":"architecture/event_system/#integration-with-drivers","title":"Integration with Drivers","text":"<p>EventSDK is integrated into drivers through the driver interface:</p> <pre><code>class AppiumDriver(DriverInterface):\n    def __init__(self, config, event_sdk: Optional[EventSDK] = None):\n        self.event_sdk = event_sdk\n\n    def press_element(self, element: str, event_name: Optional[str] = None):\n        if self.event_sdk:\n            self.event_sdk.track_action(\"press_element\", event_name)\n        # ... press logic\n</code></pre>"},{"location":"architecture/event_system/#track-action-method","title":"Track Action Method","text":"<p>The <code>track_action()</code> method is a convenience wrapper:</p> <pre><code>def track_action(self, action_type: str, event_name: Optional[str] = None):\n    event_name = event_name or action_type\n    self.capture_event(\n        event_name=event_name,\n        action_type=action_type,\n        timestamp=self.get_current_time_for_events()\n    )\n</code></pre>"},{"location":"architecture/event_system/#test-context-integration","title":"Test Context Integration","text":"<p>EventSDK automatically retrieves the current test case name from test context:</p> <pre><code>def get_test_case_name(self):\n    return test_context.current_test_case.get()\n</code></pre> <p>This allows events to be associated with the test case that triggered them.</p>"},{"location":"architecture/event_system/#event-submission-api","title":"Event Submission API","text":""},{"location":"architecture/event_system/#api-endpoint","title":"API Endpoint","text":"<p>Events are submitted to:</p> <pre><code>POST {eventUrl}/v1/event/batchevent\n</code></pre>"},{"location":"architecture/event_system/#request-format","title":"Request Format","text":"<pre><code>[\n  {\n    \"eventName\": \"button_clicked\",\n    \"eventAttributes\": {...},\n    \"mozarkEventAttributes\": {...}\n  },\n  ...\n]\n</code></pre>"},{"location":"architecture/event_system/#authentication","title":"Authentication","text":"<p>Requests include a Bearer token in the Authorization header:</p> <pre><code>Authorization: Bearer {testParameters_bearer}\n</code></pre>"},{"location":"architecture/event_system/#response-handling","title":"Response Handling","text":"<p>EventSDK includes retry logic for failed submissions:</p> <pre><code>def send_all_events(self):\n    max_retries = 3\n    retry_delay = 2  # seconds\n\n    for attempt in range(max_retries):\n        success = self.send_batch_events(events_to_send)\n        if success:\n            self.all_events.clear()\n            return True\n        time.sleep(retry_delay * attempt)\n\n    # All retries failed\n    self.all_events.clear()\n    return False\n</code></pre>"},{"location":"architecture/event_system/#time-management","title":"Time Management","text":"<p>EventSDK uses a specific timezone (IST - UTC+5:30) for timestamps:</p> <pre><code>def get_current_time_for_events(self):\n    current_utc_time = datetime.now(timezone.utc)\n    desired_timezone = timezone(timedelta(hours=5, minutes=30))\n    current_time_in_desired_timezone = current_utc_time.astimezone(desired_timezone)\n    formatted_time = current_time_in_desired_timezone.strftime(\"%Y-%m-%dT%H:%M:%S.%f%z\")\n    return formatted_time[:-2] + \":\" + formatted_time[-2:]\n</code></pre> <p>This ensures consistent timestamp formatting across all events.</p>"},{"location":"architecture/event_system/#event-printing","title":"Event Printing","text":"<p>Events can be printed to the console using the TreeResultPrinter:</p> <pre><code>def print_event(self, event_data):\n    printer = TreeResultPrinter.get_instance()\n    printer.print_event_log(event_data)\n</code></pre> <p>This is useful for debugging and local development.</p>"},{"location":"architecture/event_system/#best-practices","title":"Best Practices","text":""},{"location":"architecture/event_system/#1-event-naming","title":"1. Event Naming","text":"<p>Use consistent, descriptive event names:</p> <pre><code># Good\nevent_sdk.capture_event(event_name=\"login_button_clicked\", ...)\nevent_sdk.capture_event(event_name=\"form_submission_completed\", ...)\n\n# Bad\nevent_sdk.capture_event(event_name=\"click\", ...)\nevent_sdk.capture_event(event_name=\"done\", ...)\n</code></pre>"},{"location":"architecture/event_system/#2-event-attributes","title":"2. Event Attributes","text":"<p>Include relevant context in event attributes:</p> <pre><code>event_sdk.capture_event(\n    event_name=\"element_pressed\",\n    element_id=\"submit_button\",\n    element_type=\"button\",\n    screen=\"login\",\n    test_case=\"test_user_login\"\n)\n</code></pre>"},{"location":"architecture/event_system/#3-submission-mode-selection","title":"3. Submission Mode Selection","text":"<ul> <li>Use real-time for live monitoring and debugging</li> <li>Use batch for production runs to reduce network overhead</li> </ul>"},{"location":"architecture/event_system/#4-error-handling","title":"4. Error Handling","text":"<p>EventSDK handles errors gracefully:</p> <ul> <li>Failed event submissions are logged but don't stop execution</li> <li>Retry logic ensures events are eventually sent</li> <li>Events are cleared after successful submission or max retries</li> </ul>"},{"location":"architecture/event_system/#5-configuration-management","title":"5. Configuration Management","text":"<ul> <li>Store event attributes JSON securely</li> <li>Use environment variables for sensitive data (bearer tokens)</li> <li>Validate configuration during initialization</li> </ul>"},{"location":"architecture/event_system/#troubleshooting","title":"Troubleshooting","text":""},{"location":"architecture/event_system/#events-not-being-sent","title":"Events Not Being Sent","text":"<p>Problem: Events are captured but not submitted.</p> <p>Solutions:</p> <ol> <li>Check <code>eventUrl</code> is set in event attributes JSON</li> <li>Verify <code>testParameters_bearer</code> is valid</li> <li>Check network connectivity to event API</li> <li>Review execution logs for error messages</li> </ol>"},{"location":"architecture/event_system/#missing-test-case-name","title":"Missing Test Case Name","text":"<p>Problem: <code>testCaseName</code> is None in events.</p> <p>Solutions:</p> <ol> <li>Ensure test context is set before capturing events</li> <li>Verify test case execution is using proper session management</li> <li>Check that <code>test_context.current_test_case</code> is set</li> </ol>"},{"location":"architecture/event_system/#timestamp-issues","title":"Timestamp Issues","text":"<p>Problem: Timestamps are incorrect or missing.</p> <p>Solutions:</p> <ol> <li>Verify system time is correct</li> <li>Check timezone configuration</li> <li>Ensure <code>get_current_time_for_events()</code> is called correctly</li> </ol>"},{"location":"architecture/event_system/#extension-points","title":"Extension Points","text":""},{"location":"architecture/event_system/#custom-event-handlers","title":"Custom Event Handlers","text":"<p>You can extend EventSDK to add custom event processing:</p> <pre><code>class CustomEventSDK(EventSDK):\n    def capture_event(self, event_name, **args):\n        # Custom processing\n        processed_args = self._process_attributes(args)\n        super().capture_event(event_name, **processed_args)\n\n    def _process_attributes(self, args):\n        # Add custom attributes\n        args['custom_field'] = 'custom_value'\n        return args\n</code></pre>"},{"location":"architecture/event_system/#custom-submission-logic","title":"Custom Submission Logic","text":"<p>Override submission methods for custom behavior:</p> <pre><code>class CustomEventSDK(EventSDK):\n    def send_batch_events(self, event_data):\n        # Custom submission logic\n        # e.g., send to multiple endpoints\n        result1 = self._send_to_endpoint1(event_data)\n        result2 = self._send_to_endpoint2(event_data)\n        return result1 and result2\n</code></pre>"},{"location":"architecture/event_system/#related-documentation","title":"Related Documentation","text":"<ul> <li>Execution Architecture - Internal event system (EventManager)</li> <li>Components - Driver integration</li> <li>Test Context - Context variable system</li> <li>Logging - Logging system</li> <li>Configuration - Configuration setup</li> <li>Architecture Decisions - Event system design decisions</li> <li>Extending - Creating custom extensions</li> </ul>"},{"location":"architecture/execution/","title":"Test Execution Architecture","text":"<p>This document explains how test execution works in the Optics Framework, including the execution engine, test runners, event system, and data flow.</p>"},{"location":"architecture/execution/#execution-overview","title":"Execution Overview","text":"<p>The execution system orchestrates test case execution, manages events, and handles results. It supports multiple execution modes and integrates with various test runners.</p> <pre><code>graph TB\n    A[User/CLI] --&gt; B[ExecutionEngine]\n    B --&gt; C{Execution Mode}\n    C --&gt;|batch| D[BatchExecutor]\n    C --&gt;|dry_run| E[DryRunExecutor]\n    C --&gt;|keyword| F[KeywordExecutor]\n    D --&gt; G[TestRunner]\n    E --&gt; G\n    F --&gt; H[KeywordRunner]\n    G --&gt; I[Keyword Execution]\n    H --&gt; I\n    I --&gt; J[EventManager]\n    J --&gt; K[Event Subscribers]</code></pre>"},{"location":"architecture/execution/#executionengine","title":"ExecutionEngine","text":"<p>Location: <code>optics_framework/common/execution.py</code></p> <p>The <code>ExecutionEngine</code> is the main orchestrator for test execution.</p>"},{"location":"architecture/execution/#key-responsibilities","title":"Key Responsibilities","text":"<ul> <li>Execution mode selection</li> <li>Runner instantiation</li> <li>Event management coordination</li> <li>Result collection</li> <li>Error handling</li> </ul>"},{"location":"architecture/execution/#execution-modes","title":"Execution Modes","text":""},{"location":"architecture/execution/#batch-mode","title":"Batch Mode","text":"<p>Executes all test cases in sequence.</p> <pre><code>execution_params = ExecutionParams(\n    session_id=session_id,\n    mode=\"batch\",\n    runner_type=\"test_runner\"\n)\n</code></pre>"},{"location":"architecture/execution/#dry-run-mode","title":"Dry Run Mode","text":"<p>Validates test cases without executing actions.</p> <pre><code>execution_params = ExecutionParams(\n    session_id=session_id,\n    mode=\"dry_run\",\n    runner_type=\"test_runner\"\n)\n</code></pre>"},{"location":"architecture/execution/#keyword-mode","title":"Keyword Mode","text":"<p>Executes a single keyword with parameters.</p> <pre><code>execution_params = ExecutionParams(\n    session_id=session_id,\n    mode=\"keyword\",\n    keyword=\"Press Element\",\n    params=[\"submit_button\"]\n)\n</code></pre>"},{"location":"architecture/execution/#execution-flow","title":"Execution Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Engine as ExecutionEngine\n    participant Executor\n    participant Runner\n    participant Keywords\n    participant Events as EventManager\n\n    User-&gt;&gt;Engine: execute(params)\n    Engine-&gt;&gt;Engine: get_session()\n    Engine-&gt;&gt;Engine: select_executor(mode)\n    Engine-&gt;&gt;Executor: execute(session, runner)\n    Executor-&gt;&gt;Runner: run_all() or run_keyword()\n    Runner-&gt;&gt;Keywords: execute_keyword()\n    Keywords-&gt;&gt;Events: publish_event()\n    Events--&gt;&gt;Runner: event_ack\n    Runner--&gt;&gt;Executor: results\n    Executor--&gt;&gt;Engine: completion\n    Engine--&gt;&gt;User: results</code></pre>"},{"location":"architecture/execution/#executors","title":"Executors","text":"<p>Executors handle different execution modes and coordinate with runners.</p>"},{"location":"architecture/execution/#batchexecutor","title":"BatchExecutor","text":"<p>Location: <code>optics_framework/common/execution.py</code></p> <p>Executes all test cases in a session.</p>"},{"location":"architecture/execution/#flow","title":"Flow","text":"<ol> <li>Validates test cases exist</li> <li>Calls runner's <code>run_all()</code> method</li> <li>Collects results from all test cases</li> <li>Publishes execution completion event</li> <li>Returns aggregated results</li> </ol>"},{"location":"architecture/execution/#dryrunexecutor","title":"DryRunExecutor","text":"<p>Location: <code>optics_framework/common/execution.py</code></p> <p>Validates test cases without executing actions.</p>"},{"location":"architecture/execution/#flow_1","title":"Flow","text":"<ol> <li>Validates test cases exist</li> <li>Calls runner's <code>dry_run_all()</code> method</li> <li>Validates keyword existence and parameters</li> <li>Does not execute actual actions</li> <li>Returns validation results</li> </ol>"},{"location":"architecture/execution/#keywordexecutor","title":"KeywordExecutor","text":"<p>Location: <code>optics_framework/common/execution.py</code></p> <p>Executes a single keyword with parameters.</p>"},{"location":"architecture/execution/#flow_2","title":"Flow","text":"<ol> <li>Validates keyword exists</li> <li>Builds keyword registry</li> <li>Executes keyword with parameters</li> <li>Handles fallback parameters</li> <li>Returns keyword result</li> </ol>"},{"location":"architecture/execution/#test-runners","title":"Test Runners","text":"<p>Runners execute test cases and manage keyword execution.</p>"},{"location":"architecture/execution/#testrunner","title":"TestRunner","text":"<p>Location: <code>optics_framework/common/runner/test_runnner.py</code></p> <p>The main test runner for batch execution.</p>"},{"location":"architecture/execution/#key-features","title":"Key Features","text":"<ul> <li>Test case execution</li> <li>Module execution</li> <li>Keyword execution</li> <li>Data-driven testing support</li> <li>Result collection and reporting</li> </ul>"},{"location":"architecture/execution/#execution-flow_1","title":"Execution Flow","text":"<pre><code>graph TB\n    A[TestRunner] --&gt; B[Execute Test Case]\n    B --&gt; C[Execute Modules]\n    C --&gt; D[Execute Keywords]\n    D --&gt; E[Handle Data Sets]\n    E --&gt; F[Collect Results]\n    F --&gt; G[Update State]\n    G --&gt; H[Publish Events]</code></pre>"},{"location":"architecture/execution/#test-case-execution","title":"Test Case Execution","text":"<pre><code>async def execute_test_case(self, test_case: str):\n    # 1. Get test case node\n    test_case_node = self.test_suite.get_test_case(test_case)\n    if not test_case_node:\n        raise OpticsError(Code.E0702, f\"Test case '{test_case}' not found\")\n\n    # 2. Initialize test case state\n    test_case_node.state = State.RUNNING\n    test_case_node.attempt_count += 1\n\n    # 3. Execute modules in sequence\n    current_module = test_case_node.modules_head\n    while current_module:\n        await self.execute_module(current_module, test_case)\n        current_module = current_module.next\n\n    # 4. Handle data sets (if data-driven)\n    # Data sets are handled at test case level\n\n    # 5. Collect and return results\n    test_case_node.state = State.COMPLETED_PASSED\n    return test_case_result\n</code></pre> <p>Example Execution Flow: <pre><code># Test case structure:\n# TestCaseNode: \"Login Test\"\n#   \u251c\u2500\u2500 ModuleNode: \"Launch Application\"\n#   \u2502   \u2514\u2500\u2500 KeywordNode: \"Launch App\"\n#   \u251c\u2500\u2500 ModuleNode: \"Enter Credentials\"\n#   \u2502   \u251c\u2500\u2500 KeywordNode: \"Press Element\"\n#   \u2502   \u251c\u2500\u2500 KeywordNode: \"Enter Text\"\n#   \u2502   \u2514\u2500\u2500 KeywordNode: \"Press Element\"\n#   \u2514\u2500\u2500 ModuleNode: \"Verify Login\"\n#       \u2514\u2500\u2500 KeywordNode: \"Validate Element\"\n\n# Execution order:\n# 1. Execute \"Launch Application\" module\n# 2. Execute \"Enter Credentials\" module\n# 3. Execute \"Verify Login\" module\n</code></pre></p>"},{"location":"architecture/execution/#module-execution","title":"Module Execution","text":"<pre><code>def execute_module(self, module_node: ModuleNode, test_case_id: str):\n    # 1. Get module definition\n    module_name = module_node.name\n    module_definition = self.session.modules.get_module_definition(module_name)\n\n    # 2. Initialize module state\n    module_node.state = State.RUNNING\n\n    # 3. Execute keywords in sequence\n    current_keyword = module_node.keywords_head\n    while current_keyword:\n        await self.execute_keyword(\n            current_keyword.name,\n            current_keyword.params,\n            module_node.id\n        )\n        current_keyword = current_keyword.next\n\n    # 4. Handle flow control (loops, conditions)\n    # Flow control keywords modify execution flow\n\n    # 5. Return module result\n    module_node.state = State.COMPLETED_PASSED\n    return module_result\n</code></pre> <p>Example Module Execution: <pre><code># Module: \"Enter Credentials\"\n# Keywords:\n#   1. Press Element ${username_field}\n#   2. Enter Text ${username_field} testuser\n#   3. Press Element ${password_field}\n#   4. Enter Text ${password_field} testpass\n#   5. Press Element ${login_button}\n\n# Execution:\n# - Each keyword executed in sequence\n# - Element references resolved from elements.csv\n# - State tracked per keyword\n# - Module state updated on completion\n</code></pre></p>"},{"location":"architecture/execution/#keyword-execution","title":"Keyword Execution","text":"<pre><code>async def execute_keyword(\n    self,\n    keyword_name: str,\n    args: List[str],\n    module_id: str\n):\n    # 1. Look up keyword in registry\n    keyword_slug = \"_\".join(keyword_name.split()).lower()\n    method = self.keyword_registry.get_method(keyword_slug)\n    if not method:\n        raise OpticsError(Code.E0402, f\"Keyword '{keyword_name}' not found\")\n\n    # 2. Resolve parameters (variables, fallbacks)\n    resolved_args = self._resolve_parameters(args, module_id)\n    # Variables: ${element_name} -&gt; actual value\n    # Fallbacks: [\"value1\", \"value2\"] -&gt; try each\n\n    # 3. Execute keyword with fallback support\n    result = await self._try_execute_with_fallback(\n        method, resolved_args, keyword_node, module_node\n    )\n\n    # 4. Handle exceptions\n    # Exceptions caught and converted to OpticsError\n\n    # 5. Publish events\n    await self._send_event(\n        \"keyword\",\n        keyword_node,\n        EventStatus.PASS,\n        parent_id=module_node.id\n    )\n\n    # 6. Return result\n    return result\n</code></pre> <p>Example Keyword Execution: <pre><code># Keyword: \"Press Element submit_button\"\n# Args: [\"submit_button\"]\n\n# 1. Lookup: \"press_element\" in registry\n# 2. Resolve: \"submit_button\" -&gt; element value from elements.csv\n#    - If element has multiple values: try each as fallback\n# 3. Execute: ActionKeyword.press_element(\"submit_button\")\n#    - Self-healing decorator tries multiple strategies\n#    - XPath -&gt; Text -&gt; OCR -&gt; Image\n# 4. Publish: Keyword execution event\n# 5. Return: Success or raise error\n</code></pre></p> <p>Parameter Resolution Example: <pre><code># Test case: \"Press Element ${button_name}\"\n# Elements.csv: button_name = \"submit_button\"\n# Resolved: \"Press Element submit_button\"\n\n# With fallback in elements:\n# Elements.csv: button_name = [\"submit_btn\", \"submit_button\", \"//button[@id='submit']\"]\n# Tries each value until one succeeds\n</code></pre></p>"},{"location":"architecture/execution/#pytestrunner","title":"PytestRunner","text":"<p>Location: <code>optics_framework/common/runner/test_runnner.py</code></p> <p>Integrates with pytest for test execution.</p>"},{"location":"architecture/execution/#key-features_1","title":"Key Features","text":"<ul> <li>Pytest integration</li> <li>Fixture support</li> <li>Test discovery</li> <li>Pytest reporting</li> </ul>"},{"location":"architecture/execution/#usage","title":"Usage","text":"<pre><code># Test cases are automatically converted to pytest tests\npytest.main([\"--optics-session\", session_id])\n</code></pre>"},{"location":"architecture/execution/#keywordrunner","title":"KeywordRunner","text":"<p>Location: <code>optics_framework/common/execution.py</code></p> <p>Minimal runner for single keyword execution.</p>"},{"location":"architecture/execution/#key-features_2","title":"Key Features","text":"<ul> <li>Single keyword execution</li> <li>Parameter handling</li> <li>Result return</li> <li>No test case management</li> </ul>"},{"location":"architecture/execution/#event-system","title":"Event System","text":"<p>The event system provides real-time execution tracking and extensibility.</p>"},{"location":"architecture/execution/#eventmanager","title":"EventManager","text":"<p>Location: <code>optics_framework/common/events.py</code></p> <p>Centralized event management and distribution.</p>"},{"location":"architecture/execution/#key-features_3","title":"Key Features","text":"<ul> <li>Event queuing</li> <li>Subscriber management</li> <li>Async event processing</li> <li>Command handling</li> </ul>"},{"location":"architecture/execution/#event-types","title":"Event Types","text":"<pre><code>class EventStatus(str, Enum):\n    NOT_RUN = \"NOT_RUN\"\n    RUNNING = \"RUNNING\"\n    PASS = \"PASS\"\n    FAIL = \"FAIL\"\n    ERROR = \"ERROR\"\n    SKIPPED = \"SKIPPED\"\n    RETRYING = \"RETRYING\"\n</code></pre>"},{"location":"architecture/execution/#event-structure","title":"Event Structure","text":"<pre><code>class Event(BaseModel):\n    entity_type: str  # \"test_case\", \"module\", \"keyword\"\n    entity_id: str    # Unique identifier\n    name: str         # Human-readable name\n    status: EventStatus\n    message: str\n    parent_id: Optional[str]\n    extra: Dict[str, str]\n    timestamp: float\n    args: Optional[List[Any]]\n    start_time: Optional[float]\n    end_time: Optional[float]\n    elapsed: Optional[float]\n    logs: Optional[List[str]]\n</code></pre>"},{"location":"architecture/execution/#event-flow","title":"Event Flow","text":"<pre><code>sequenceDiagram\n    participant Runner\n    participant EM as EventManager\n    participant Sub1 as Subscriber1\n    participant Sub2 as Subscriber2\n\n    Runner-&gt;&gt;EM: publish_event(event)\n    EM-&gt;&gt;EM: queue_event(event)\n    EM-&gt;&gt;Sub1: on_event(event)\n    EM-&gt;&gt;Sub2: on_event(event)\n    Sub1--&gt;&gt;EM: ack\n    Sub2--&gt;&gt;EM: ack</code></pre>"},{"location":"architecture/execution/#event-subscribers","title":"Event Subscribers","text":"<p>Subscribers receive and process events.</p>"},{"location":"architecture/execution/#juniteventhandler","title":"JUnitEventHandler","text":"<p>Location: <code>optics_framework/common/Junit_eventhandler.py</code></p> <p>Generates JUnit XML reports from events.</p>"},{"location":"architecture/execution/#custom-subscribers","title":"Custom Subscribers","text":"<p>Implement <code>EventSubscriber</code> interface:</p> <pre><code>class CustomSubscriber(EventSubscriber):\n    async def on_event(self, event: Event) -&gt; None:\n        # Process event\n        pass\n</code></pre>"},{"location":"architecture/execution/#event-registration","title":"Event Registration","text":"<pre><code>event_manager = get_event_manager(session_id)\nevent_manager.subscribe(\"custom_subscriber\", CustomSubscriber())\n</code></pre>"},{"location":"architecture/execution/#keyword-registry","title":"Keyword Registry","text":"<p>Location: <code>optics_framework/common/runner/keyword_register.py</code></p> <p>The <code>KeywordRegistry</code> manages keyword registration, discovery, and lookup. It provides a centralized way to map keyword names to their implementation methods.</p>"},{"location":"architecture/execution/#architecture","title":"Architecture","text":"<pre><code>graph TB\n    A[API Classes] --&gt; B[KeywordRegistry]\n    B --&gt; C[keyword_map]\n    C --&gt; D[Method Lookup]\n    D --&gt; E[Test Runner]\n    E --&gt; F[Keyword Execution]\n\n    G[ActionKeyword] --&gt; B\n    H[AppManagement] --&gt; B\n    I[Verifier] --&gt; B\n    J[FlowControl] --&gt; B</code></pre>"},{"location":"architecture/execution/#registration-process","title":"Registration Process","text":"<p>Keywords are registered by passing API class instances to the registry:</p> <pre><code>from optics_framework.common.runner.keyword_register import KeywordRegistry\nfrom optics_framework.api.action_keyword import ActionKeyword\nfrom optics_framework.api.app_management import AppManagement\nfrom optics_framework.api.verifier import Verifier\nfrom optics_framework.api.flow_control import FlowControl\n\nregistry = KeywordRegistry()\n\n# Register API classes\naction_keyword = ActionKeyword(builder)\napp_management = AppManagement(builder)\nverifier = Verifier(builder)\nflow_control = FlowControl(builder)\n\nregistry.register(action_keyword)\nregistry.register(app_management)\nregistry.register(verifier)\nregistry.register(flow_control)\n</code></pre>"},{"location":"architecture/execution/#automatic-discovery","title":"Automatic Discovery","text":"<p>The registry automatically discovers public methods from registered instances:</p> <pre><code>def register(self, instance: object) -&gt; None:\n    \"\"\"\n    Register all public callable methods of an instance.\n\n    - Iterates over all attributes\n    - Registers callable methods (not starting with _)\n    - Warns on duplicate method names\n    \"\"\"\n    for method_name in dir(instance):\n        if not method_name.startswith(\"_\"):\n            method = getattr(instance, method_name)\n            if callable(method):\n                self.keyword_map[method_name] = method\n</code></pre> <p>Registration Rules:</p> <ul> <li>Only public methods (not starting with <code>_</code>)</li> <li>Must be callable</li> <li>Method name becomes the keyword identifier</li> <li>Duplicate names generate warnings</li> </ul>"},{"location":"architecture/execution/#keyword-lookup","title":"Keyword Lookup","text":"<p>Keywords are looked up by converting human-readable names to method names:</p> <pre><code>def get_method(self, func_name: str) -&gt; Optional[Callable[..., object]]:\n    \"\"\"Retrieve a method by its function name.\"\"\"\n    return self.keyword_map.get(func_name)\n</code></pre> <p>Name Conversion: <pre><code># Human-readable name -&gt; Method name\n\"Press Element\" -&gt; \"press_element\"\n\"Enter Text\" -&gt; \"enter_text\"\n\"Validate Element\" -&gt; \"validate_element\"\n\n# Conversion logic\nkeyword_slug = \"_\".join(keyword_name.split()).lower()\nmethod = registry.keyword_map.get(keyword_slug)\n</code></pre></p> <p>Lookup Flow: <pre><code>sequenceDiagram\n    participant Runner\n    participant Registry\n    participant API\n\n    Runner-&gt;&gt;Registry: get_method(\"press_element\")\n    Registry-&gt;&gt;Registry: Lookup in keyword_map\n    alt Found\n        Registry--&gt;&gt;Runner: method reference\n        Runner-&gt;&gt;API: Call method\n    else Not Found\n        Registry--&gt;&gt;Runner: None\n        Runner-&gt;&gt;Runner: Raise KeywordNotFound error\n    end</code></pre></p>"},{"location":"architecture/execution/#keyword-map-structure","title":"Keyword Map Structure","text":"<p>The registry maintains a dictionary mapping method names to callable methods:</p> <pre><code>class KeywordRegistry:\n    def __init__(self):\n        self.keyword_map: Dict[str, Callable[..., object]] = {}\n</code></pre> <p>Example Map: <pre><code>{\n    \"press_element\": &lt;bound method ActionKeyword.press_element&gt;,\n    \"enter_text\": &lt;bound method ActionKeyword.enter_text&gt;,\n    \"launch_app\": &lt;bound method AppManagement.launch_app&gt;,\n    \"validate_element\": &lt;bound method Verifier.validate_element&gt;,\n    \"condition\": &lt;bound method FlowControl.condition&gt;,\n    # ... more keywords\n}\n</code></pre></p>"},{"location":"architecture/execution/#integration-with-test-runner","title":"Integration with Test Runner","text":"<p>The test runner uses the registry to execute keywords:</p> <pre><code># In TestRunner\ndef execute_keyword(self, keyword_name: str, args: List[str], module_id: str):\n    # 1. Convert keyword name to method name\n    keyword_slug = \"_\".join(keyword_name.split()).lower()\n\n    # 2. Lookup method in registry\n    method = self.keyword_registry.get_method(keyword_slug)\n    if not method:\n        raise OpticsError(Code.E0402, f\"Keyword '{keyword_name}' not found\")\n\n    # 3. Resolve parameters\n    resolved_args = self._resolve_parameters(args, module_id)\n\n    # 4. Execute keyword\n    return method(*resolved_args)\n</code></pre>"},{"location":"architecture/execution/#parameter-resolution","title":"Parameter Resolution","text":"<p>The registry works with the test runner to resolve parameters:</p> <p>1. Variable Substitution: <pre><code># Test case: \"Press Element ${button_name}\"\n# Resolved: \"Press Element submit_button\"\n# Where ${button_name} is replaced with actual value\n</code></pre></p> <p>2. Fallback Parameters: <pre><code># Test case: \"Press Element [btn1, btn2, btn3]\"\n# Registry provides method, runner handles fallback logic\n</code></pre></p> <p>3. Type Conversion: <pre><code># String parameters converted to appropriate types\n# Based on method signature inspection\n</code></pre></p>"},{"location":"architecture/execution/#robot-framework-integration","title":"Robot Framework Integration","text":"<p>When Robot Framework is available, keywords are also exposed through the <code>@keyword</code> decorator:</p> <pre><code>from optics_framework.optics import keyword\n\n@keyword(\"Press Element\")\ndef press_element(self, element: str):\n    \"\"\"Press an element.\"\"\"\n    pass\n</code></pre> <p>The registry works independently of Robot Framework, but both systems can coexist:</p> <ul> <li>Registry: For internal test execution</li> <li>Robot Framework: For Robot Framework test files</li> </ul>"},{"location":"architecture/execution/#dynamic-keyword-loading","title":"Dynamic Keyword Loading","text":"<p>Keywords can be registered dynamically:</p> <pre><code># Register custom keywords\nclass CustomKeywords:\n    def custom_action(self, param: str):\n        pass\n\ncustom = CustomKeywords()\nregistry.register(custom)\n\n# Now available as keyword\nmethod = registry.get_method(\"custom_action\")\n</code></pre>"},{"location":"architecture/execution/#error-handling","title":"Error Handling","text":"<p>Keyword Not Found: <pre><code>method = registry.get_method(\"nonexistent_keyword\")\nif method is None:\n    raise OpticsError(\n        Code.E0402,\n        message=f\"Keyword 'nonexistent_keyword' not found\",\n        details={\"available_keywords\": list(registry.keyword_map.keys())}\n    )\n</code></pre></p> <p>Duplicate Registration: <pre><code># Warning logged, but registration continues\n# Last registered method wins\ninternal_logger.warning(\n    f\"Warning: Duplicate method name '{method_name}'\"\n)\n</code></pre></p>"},{"location":"architecture/execution/#best-practices","title":"Best Practices","text":"<ol> <li>Consistent Naming: Use consistent method naming conventions</li> <li>Public Methods Only: Only expose methods intended as keywords</li> <li>Documentation: Document keyword behavior in docstrings</li> <li>Error Handling: Handle errors gracefully in keyword methods</li> <li>Type Hints: Use type hints for better parameter resolution</li> </ol>"},{"location":"architecture/execution/#registry-lifecycle","title":"Registry Lifecycle","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Empty: Initialize\n    Empty --&gt; Registered: register(instance)\n    Registered --&gt; Registered: register(another)\n    Registered --&gt; Lookup: get_method(name)\n    Lookup --&gt; Registered: Continue\n    Registered --&gt; [*]: Execution complete</code></pre>"},{"location":"architecture/execution/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>O(1) Lookup: Dictionary-based lookup is fast</li> <li>Single Registration: Methods registered once per session</li> <li>No Re-scanning: Methods cached after registration</li> <li>Memory Efficient: Only stores method references, not copies</li> </ul>"},{"location":"architecture/execution/#related-components","title":"Related Components","text":"<ul> <li>Test Runner: Uses registry for keyword execution</li> <li>API Classes: Provide keyword implementations</li> <li>Execution Engine: Coordinates registry usage</li> <li>Parameter Resolution: Works with registry for parameter handling</li> </ul>"},{"location":"architecture/execution/#data-models","title":"Data Models","text":"<p>Location: <code>optics_framework/common/models.py</code></p> <p>The framework uses a linked list structure to represent test execution hierarchy and various data structures for managing test artifacts. This design provides efficient sequential execution, dynamic structure modification, and memory-efficient state tracking.</p>"},{"location":"architecture/execution/#why-linked-lists","title":"Why Linked Lists?","text":"<p>The framework uses linked lists for the execution hierarchy because:</p> <ol> <li>Sequential Execution: Natural order for test execution flow</li> <li>Memory Efficiency: No array overhead, only stores necessary links</li> <li>Dynamic Structure: Easy to add/remove nodes during execution</li> <li>State Tracking: Each node tracks its own execution state</li> <li>Flexible Traversal: Can traverse forward through execution flow</li> </ol>"},{"location":"architecture/execution/#node-hierarchy","title":"Node Hierarchy","text":"<p>The execution structure is organized as a linked list:</p> <pre><code>graph TB\n    A[TestSuite] --&gt; B[TestCaseNode]\n    B --&gt; C[ModuleNode]\n    C --&gt; D[KeywordNode]\n    D --&gt; E[KeywordNode]\n    C --&gt; F[ModuleNode]\n    F --&gt; G[KeywordNode]\n    B --&gt; H[TestCaseNode]\n    H --&gt; I[ModuleNode]</code></pre> <p>Structure:</p> <ul> <li>TestSuite: Container for test cases (head pointer)</li> <li>TestCaseNode: Individual test case with modules (linked list)</li> <li>ModuleNode: Reusable module with keywords (linked list)</li> <li>KeywordNode: Individual keyword execution (linked list)</li> </ul>"},{"location":"architecture/execution/#base-node","title":"Base Node","text":"<p>All nodes extend the <code>Node</code> base class:</p> <pre><code>class Node(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid4()))  # Unique identifier (UUID)\n    name: str  # Human-readable name\n    state: State = State.NOT_RUN  # Execution state\n    attempt_count: int = 0  # Number of execution attempts\n    max_attempts: int = 3  # Maximum retry attempts\n    last_failure_reason: Optional[str] = None  # Last failure message\n</code></pre> <p>Node Properties:</p> <ul> <li>id: Unique UUID for each node</li> <li>name: Human-readable identifier</li> <li>state: Current execution state (see State Enum)</li> <li>attempt_count: Tracks retry attempts</li> <li>max_attempts: Maximum retries before giving up</li> <li>last_failure_reason: Stores error message for debugging</li> </ul>"},{"location":"architecture/execution/#state-enum","title":"State Enum","text":"<p>Execution states track the lifecycle of each node:</p> <pre><code>class State(str, Enum):\n    NOT_RUN = \"NOT_RUN\"              # Initial state, not yet executed\n    RUNNING = \"RUNNING\"              # Currently executing\n    COMPLETED_PASSED = \"COMPLETED_PASSED\"  # Execution succeeded\n    COMPLETED_FAILED = \"COMPLETED_FAILED\"  # Execution failed\n    RETRYING = \"RETRYING\"            # Retrying after failure\n    SKIPPED = \"SKIPPED\"              # Skipped execution\n    ERROR = \"ERROR\"                  # Error occurred\n</code></pre> <p>State Transitions: <pre><code>stateDiagram-v2\n    [*] --&gt; NOT_RUN: Node created\n    NOT_RUN --&gt; RUNNING: Execution starts\n    RUNNING --&gt; COMPLETED_PASSED: Success\n    RUNNING --&gt; COMPLETED_FAILED: Failure\n    COMPLETED_FAILED --&gt; RETRYING: Retry enabled\n    RETRYING --&gt; RUNNING: Retry attempt\n    RETRYING --&gt; COMPLETED_FAILED: Max attempts reached\n    NOT_RUN --&gt; SKIPPED: Skip condition\n    RUNNING --&gt; ERROR: Exception occurred\n    COMPLETED_PASSED --&gt; [*]\n    COMPLETED_FAILED --&gt; [*]\n    SKIPPED --&gt; [*]\n    ERROR --&gt; [*]</code></pre></p>"},{"location":"architecture/execution/#testcasenode","title":"TestCaseNode","text":"<p>Represents a test case with linked modules:</p> <pre><code>class TestCaseNode(Node):\n    modules_head: Optional[ModuleNode] = None\n    next: Optional['TestCaseNode'] = None\n</code></pre> <p>Methods:</p> <ul> <li><code>add_module(module)</code>: Add module to test case</li> <li><code>remove_module(module_name)</code>: Remove module by name</li> <li><code>get_module(module_name)</code>: Get module by name</li> </ul> <p>Structure: <pre><code>TestCaseNode\n\u251c\u2500\u2500 ModuleNode (modules_head)\n\u2502   \u251c\u2500\u2500 KeywordNode\n\u2502   \u2514\u2500\u2500 KeywordNode (next)\n\u2514\u2500\u2500 ModuleNode (next)\n    \u2514\u2500\u2500 KeywordNode\n</code></pre></p>"},{"location":"architecture/execution/#modulenode","title":"ModuleNode","text":"<p>Represents a module (reusable keyword sequence) with linked keywords:</p> <pre><code>class ModuleNode(Node):\n    keywords_head: Optional[KeywordNode] = None\n    next: Optional['ModuleNode'] = None\n</code></pre> <p>Methods:</p> <ul> <li><code>add_keyword(keyword)</code>: Add keyword to module</li> <li><code>remove_keyword(keyword_name)</code>: Remove keyword by name</li> <li><code>get_keyword(keyword_name)</code>: Get keyword by name</li> </ul> <p>Structure: <pre><code>ModuleNode\n\u251c\u2500\u2500 KeywordNode (keywords_head)\n\u2502   \u2514\u2500\u2500 KeywordNode (next)\n\u2514\u2500\u2500 KeywordNode (next)\n</code></pre></p>"},{"location":"architecture/execution/#keywordnode","title":"KeywordNode","text":"<p>Represents a keyword execution with parameters:</p> <pre><code>class KeywordNode(Node):\n    params: List[str]  # Keyword parameters\n    method_ref: Optional[Callable]  # Reference to keyword method\n    next: Optional['KeywordNode'] = None\n</code></pre> <p>Structure: <pre><code>KeywordNode\n\u251c\u2500\u2500 name: \"Press Element\"\n\u251c\u2500\u2500 params: [\"submit_button\", \"30\"]\n\u251c\u2500\u2500 method_ref: &lt;function press_element&gt;\n\u2514\u2500\u2500 next: KeywordNode\n</code></pre></p>"},{"location":"architecture/execution/#testsuite","title":"TestSuite","text":"<p>Container for test cases:</p> <pre><code>class TestSuite(BaseModel):\n    test_cases_head: Optional[TestCaseNode] = None\n</code></pre> <p>Methods:</p> <ul> <li><code>add_test_case(test_case)</code>: Add test case to suite</li> <li><code>remove_test_case(test_case_name)</code>: Remove test case by name</li> <li><code>get_test_case(test_case_name)</code>: Get test case by name</li> </ul>"},{"location":"architecture/execution/#linked-list-operations","title":"Linked List Operations","text":"<p>Traversal: <pre><code># Traverse test cases\ncurrent = test_suite.test_cases_head\nwhile current:\n    execute_test_case(current)\n    current = current.next\n\n# Traverse modules in test case\ncurrent = test_case.modules_head\nwhile current:\n    execute_module(current)\n    current = current.next\n\n# Traverse keywords in module\ncurrent = module.keywords_head\nwhile current:\n    execute_keyword(current)\n    current = current.next\n</code></pre></p> <p>Adding Nodes: <pre><code># Add module to test case\ntest_case.add_module(module_node)\n\n# Add keyword to module\nmodule.add_keyword(keyword_node)\n</code></pre></p> <p>Removing Nodes: <pre><code># Remove module by name\ntest_case.remove_module(\"module_name\")\n\n# Remove keyword by name\nmodule.remove_keyword(\"keyword_name\")\n</code></pre></p> <p>Searching: <pre><code># Get module by name\nmodule = test_case.get_module(\"module_name\")\n\n# Get keyword by name\nkeyword = module.get_keyword(\"keyword_name\")\n</code></pre></p>"},{"location":"architecture/execution/#linked-list-benefits","title":"Linked List Benefits","text":"<ol> <li>Sequential Execution: Natural order for execution flow</li> <li>Memory Efficiency: No array overhead, only stores necessary links</li> <li>Dynamic Structure: Easy to add/remove nodes during execution</li> <li>State Tracking: Each node tracks its own execution state independently</li> <li>Flexible Modification: Can modify structure without reallocation</li> <li>Lazy Evaluation: Nodes created only when needed</li> </ol>"},{"location":"architecture/execution/#elementdata","title":"ElementData","text":"<p>Manages element definitions with fallback support:</p> <pre><code>class ElementData(BaseModel):\n    elements: Dict[str, List[str]]  # name -&gt; [value1, value2, ...]\n</code></pre> <p>Key Features:</p> <ul> <li>Multiple values per element (fallback support)</li> <li>Automatic fallback resolution</li> <li>Priority-based value selection</li> </ul> <p>Methods:</p> <ul> <li><code>add_element(name, value)</code>: Add value to element</li> <li><code>remove_element(name)</code>: Remove element</li> <li><code>get_element(name)</code>: Get all values for element</li> <li><code>get_first(name)</code>: Get first (highest priority) value</li> <li><code>resolve_with_fallback(name, resolver)</code>: Try values until one succeeds</li> </ul> <p>Example: <pre><code>element_data = ElementData()\nelement_data.add_element(\"submit_button\", \"//button[@id='submit']\")\nelement_data.add_element(\"submit_button\", \"Submit\")  # Fallback\nelement_data.add_element(\"submit_button\", \"submit_template.png\")  # Another fallback\n\n# Try each value until one succeeds\nelement = element_data.resolve_with_fallback(\n    \"submit_button\",\n    resolver=lambda v: locate_element(v)\n)\n</code></pre></p>"},{"location":"architecture/execution/#moduledata","title":"ModuleData","text":"<p>Manages reusable module definitions:</p> <pre><code>class ModuleData(BaseModel):\n    modules: Dict[str, List[tuple[str, List[str]]]]  # name -&gt; [(keyword, params), ...]\n</code></pre> <p>Structure: <pre><code>{\n    \"login_module\": [\n        (\"Press Element\", [\"username_field\"]),\n        (\"Enter Text\", [\"username\", \"testuser\"]),\n        (\"Press Element\", [\"password_field\"]),\n        (\"Enter Text\", [\"password\", \"testpass\"]),\n        (\"Press Element\", [\"login_button\"])\n    ]\n}\n</code></pre></p> <p>Methods:</p> <ul> <li><code>add_module_definition(name, definition)</code>: Add module definition</li> <li><code>remove_module_definition(name)</code>: Remove module</li> <li><code>get_module_definition(name)</code>: Get module definition</li> </ul>"},{"location":"architecture/execution/#apidata-and-apicollection","title":"ApiData and ApiCollection","text":"<p>Manages API endpoint definitions:</p> <pre><code>class ApiCollection(BaseModel):\n    name: str\n    base_url: str\n    global_headers: Dict[str, str]\n    apis: Dict[str, ApiDefinition]\n\nclass ApiDefinition(BaseModel):\n    name: str\n    endpoint: str\n    request: RequestDefinition\n    expected_result: Optional[ExpectedResultDefinition]\n</code></pre> <p>Structure: <pre><code>api_collection = ApiCollection(\n    name=\"user_api\",\n    base_url=\"https://api.example.com\",\n    global_headers={\"Authorization\": \"Bearer token\"},\n    apis={\n        \"get_user\": ApiDefinition(\n            name=\"get_user\",\n            endpoint=\"/users/{id}\",\n            request=RequestDefinition(method=\"GET\"),\n            expected_result=ExpectedResultDefinition(expected_status=200)\n        )\n    }\n)\n</code></pre></p>"},{"location":"architecture/execution/#templatedata","title":"TemplateData","text":"<p>Manages image template mappings:</p> <pre><code>class TemplateData(BaseModel):\n    templates: Dict[str, str]  # name -&gt; file_path\n</code></pre> <p>Methods: - <code>add_template(name, path)</code>: Add template mapping - <code>remove_template(name)</code>: Remove template - <code>get_template_path(name)</code>: Get template file path</p> <p>Example: <pre><code>template_data = TemplateData()\ntemplate_data.add_template(\"submit_button\", \"/path/to/submit.png\")\ntemplate_data.add_template(\"login_form\", \"/path/to/login.png\")\n</code></pre></p>"},{"location":"architecture/execution/#data-driven-testing","title":"Data-Driven Testing","text":""},{"location":"architecture/execution/#datareader","title":"DataReader","text":"<p>Location: <code>optics_framework/common/runner/data_reader.py</code></p> <p>Handles data reading from various sources.</p>"},{"location":"architecture/execution/#supported-sources","title":"Supported Sources","text":"<ul> <li>CSV files</li> <li>API endpoints</li> <li>Lists/arrays</li> <li>Variables</li> </ul>"},{"location":"architecture/execution/#data-flow","title":"Data Flow","text":"<pre><code>graph LR\n    A[Test Case] --&gt; B[Data Sets]\n    B --&gt; C[DataReader]\n    C --&gt; D[CSV/API/List]\n    D --&gt; E[Variables]\n    E --&gt; F[Keyword Execution]</code></pre>"},{"location":"architecture/execution/#execution-with-data-sets","title":"Execution with Data Sets","text":"<pre><code># For each data set\nfor data_set in test_case.data_sets:\n    # Set variables\n    session.elements.update(data_set)\n    # Execute test case\n    execute_test_case(test_case)\n</code></pre>"},{"location":"architecture/execution/#element-fallback-resolution","title":"Element Fallback Resolution","text":"<p>The <code>ElementData.resolve_with_fallback()</code> method provides automatic fallback:</p> <pre><code>def resolve_with_fallback(\n    self,\n    name: str,\n    resolver: Callable[[str], Any],\n    on_error: Optional[Callable[[Exception, str], None]] = None,\n    max_attempts: Optional[int] = None,\n) -&gt; Any:\n    \"\"\"Try each value until one succeeds.\"\"\"\n    values = self.get_element(name)\n    for v in values:\n        try:\n            return resolver(v)\n        except Exception as e:\n            if on_error:\n                on_error(e, v)\n            continue\n    raise OpticsError(Code.X0201, \"All values failed\")\n</code></pre> <p>Usage: <pre><code>element = session.elements.resolve_with_fallback(\n    \"submit_button\",\n    resolver=lambda v: strategy_manager.locate(v),\n    on_error=lambda e, v: logger.warning(f\"Failed {v}: {e}\"),\n    max_attempts=3\n)\n</code></pre></p>"},{"location":"architecture/execution/#result-collection","title":"Result Collection","text":""},{"location":"architecture/execution/#result-printers","title":"Result Printers","text":"<p>Location: <code>optics_framework/common/runner/printers.py</code></p> <p>Collect and format execution results.</p>"},{"location":"architecture/execution/#treeresultprinter","title":"TreeResultPrinter","text":"<p>Hierarchical result display:</p> <ul> <li>Test case results</li> <li>Module results</li> <li>Keyword results</li> <li>Nested structure</li> </ul>"},{"location":"architecture/execution/#nullresultprinter","title":"NullResultPrinter","text":"<p>No-op printer for programmatic use.</p>"},{"location":"architecture/execution/#result-structure","title":"Result Structure","text":"<pre><code>class TestCaseResult:\n    name: str\n    status: State\n    modules: List[ModuleResult]\n    elapsed: float\n\nclass ModuleResult:\n    name: str\n    status: State\n    keywords: List[KeywordResult]\n    elapsed: float\n\nclass KeywordResult:\n    name: str\n    status: State\n    args: List[str]\n    elapsed: float\n    error: Optional[str]\n</code></pre>"},{"location":"architecture/execution/#session-lifecycle-during-execution","title":"Session Lifecycle During Execution","text":""},{"location":"architecture/execution/#session-creation","title":"Session Creation","text":"<pre><code>sequenceDiagram\n    participant CLI\n    participant Helper\n    participant SessionMgr\n    participant Session\n    participant Builder\n\n    CLI-&gt;&gt;Helper: execute(project)\n    Helper-&gt;&gt;Helper: load_config()\n    Helper-&gt;&gt;Helper: load_test_cases()\n    Helper-&gt;&gt;SessionMgr: create_session()\n    SessionMgr-&gt;&gt;Session: new Session()\n    Session-&gt;&gt;Builder: new OpticsBuilder()\n    Builder--&gt;&gt;Session: configured\n    Session--&gt;&gt;SessionMgr: session_id\n    SessionMgr--&gt;&gt;Helper: session_id</code></pre>"},{"location":"architecture/execution/#execution-phase","title":"Execution Phase","text":"<ol> <li>Initialization: Load test cases, modules, elements</li> <li>Setup: Create session, initialize drivers</li> <li>Execution: Run test cases</li> <li>Cleanup: Terminate drivers, close sessions</li> </ol>"},{"location":"architecture/execution/#session-termination","title":"Session Termination","text":"<pre><code>def terminate_session(self, session_id: str):\n    session = self.sessions.pop(session_id)\n    if session.driver:\n        session.driver.terminate()\n    cleanup_junit(session_id)\n    get_event_manager_registry().remove_session(session_id)\n</code></pre>"},{"location":"architecture/execution/#error-handling_1","title":"Error Handling","text":""},{"location":"architecture/execution/#error-types","title":"Error Types","text":"<ul> <li>OpticsError: Framework-specific errors with error codes</li> <li>Exception: General Python exceptions</li> <li>AssertionError: Test assertion failures</li> </ul>"},{"location":"architecture/execution/#error-flow","title":"Error Flow","text":"<pre><code>graph TB\n    A[Keyword Execution] --&gt; B{Error?}\n    B --&gt;|OpticsError| C[Log Error]\n    B --&gt;|Exception| D[Wrap Exception]\n    C --&gt; E[Publish FAIL Event]\n    D --&gt; E\n    E --&gt; F{Continue?}\n    F --&gt;|Yes| G[Next Keyword]\n    F --&gt;|No| H[Stop Execution]</code></pre>"},{"location":"architecture/execution/#error-recovery","title":"Error Recovery","text":"<ul> <li>Keyword Level: Try fallback parameters</li> <li>Module Level: Continue with next keyword</li> <li>Test Case Level: Continue with next test case</li> <li>Session Level: Terminate and cleanup</li> </ul>"},{"location":"architecture/execution/#performance-considerations_1","title":"Performance Considerations","text":""},{"location":"architecture/execution/#async-execution","title":"Async Execution","text":"<ul> <li>Event processing is async</li> <li>Non-blocking event publishing</li> <li>Parallel event handling</li> </ul>"},{"location":"architecture/execution/#resource-management","title":"Resource Management","text":"<ul> <li>Driver connection pooling</li> <li>Screenshot caching</li> <li>Lazy component instantiation</li> </ul>"},{"location":"architecture/execution/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Batch Operations: Execute multiple test cases in one session</li> <li>Connection Reuse: Reuse driver connections</li> <li>Caching: Cache screenshots and page sources</li> <li>Parallel Execution: Run independent test cases in parallel</li> </ol>"},{"location":"architecture/execution/#test-context","title":"Test Context","text":"<p>Location: <code>optics_framework/common/test_context.py</code></p> <p>Test context provides thread-local and async-safe storage for execution context information using Python's <code>contextvars</code> module. This allows components to access the current test case name without explicit parameter passing.</p>"},{"location":"architecture/execution/#context-variables","title":"Context Variables","text":"<p>The framework uses Python's <code>contextvars</code> module for context management:</p> <pre><code>from contextvars import ContextVar\n\ncurrent_test_case: ContextVar[str] = ContextVar(\"current_test_case\", default=None)\n</code></pre> <p>Why Context Variables?</p> <ul> <li>Thread-Safe: Each thread/async task has its own context</li> <li>Async-Safe: Automatically propagated to async tasks</li> <li>No Parameter Passing: Access context without explicit parameters</li> <li>Isolation: Context isolated per execution context</li> </ul>"},{"location":"architecture/execution/#setting-test-context","title":"Setting Test Context","text":"<p>Test context is set during test case execution:</p> <pre><code>from optics_framework.common import test_context\n\n# Set current test case\ntest_context.current_test_case.set(\"test_login\")\n\n# Access current test case\ntest_case_name = test_context.current_test_case.get()\n# Returns: \"test_login\" or None if not set\n</code></pre> <p>When Context is Set:</p> <ul> <li>At the start of test case execution</li> <li>Before each test case in a suite</li> <li>Automatically by test runner</li> </ul> <p>When Context is Cleared:</p> <ul> <li>After test case completion</li> <li>On test case failure</li> <li>On exception handling</li> </ul>"},{"location":"architecture/execution/#usage-in-components","title":"Usage in Components","text":"<p>Components can access test context without explicit parameters:</p> <pre><code>from optics_framework.common import test_context\n\nclass EventSDK:\n    def get_test_case_name(self):\n        \"\"\"Get current test case name from context.\"\"\"\n        return test_context.current_test_case.get()\n\n    def capture_event(self, event_name, **args):\n        \"\"\"Capture event with test case context.\"\"\"\n        test_case = self.get_test_case_name()\n        # Include test case in event attributes\n        args['testCaseName'] = test_case\n        # ... capture event\n</code></pre> <p>Benefits:</p> <ul> <li>No need to pass test case name through call stack</li> <li>Automatic context propagation</li> <li>Cleaner API signatures</li> <li>Consistent context access</li> </ul>"},{"location":"architecture/execution/#context-propagation","title":"Context Propagation","text":"<p>Context variables are automatically propagated to:</p> <ul> <li>Async Tasks: Context copied to new async tasks</li> <li>Thread Pools: Context available in thread pool workers</li> <li>Nested Function Calls: Context available in all nested calls</li> <li>Event Handlers: Context available in event subscribers</li> </ul> <p>Example: <pre><code># Context set in main thread\ntest_context.current_test_case.set(\"test_login\")\n\n# Context automatically available in async task\nasync def async_operation():\n    test_case = test_context.current_test_case.get()\n    # Returns: \"test_login\"\n</code></pre></p>"},{"location":"architecture/execution/#context-isolation","title":"Context Isolation","text":"<p>Each execution context has its own context variables:</p> <pre><code># Context 1\ntest_context.current_test_case.set(\"test_1\")\n# ... execution ...\n\n# Context 2 (different thread/async task)\ntest_context.current_test_case.set(\"test_2\")\n# ... execution ...\n\n# Each context maintains its own value\n</code></pre> <p>Use Cases:</p> <ul> <li>Parallel test execution</li> <li>Async operations</li> <li>Event handling</li> <li>Logging and tracking</li> </ul>"},{"location":"architecture/execution/#integration-with-eventsdk","title":"Integration with EventSDK","text":"<p>EventSDK uses test context to automatically include test case name in events:</p> <pre><code>class EventSDK:\n    def get_test_case_name(self):\n        return test_context.current_test_case.get()\n\n    def capture_event(self, event_name, **args):\n        test_case = self.get_test_case_name()\n        if test_case:\n            args['testCaseName'] = test_case\n        # ... capture event\n</code></pre> <p>Event Structure:</p> <pre><code>{\n  \"eventName\": \"button_clicked\",\n  \"eventAttributes\": {\n    \"testCaseName\": \"test_login\",  // From context\n    \"button_id\": \"submit\"\n  }\n}\n</code></pre>"},{"location":"architecture/execution/#best-practices_1","title":"Best Practices","text":"<ol> <li>Set Context Early: Set context at the start of test case execution</li> <li>Clear on Completion: Clear context after test case completes</li> <li>Handle None: Always check if context is None before using</li> <li>Don't Modify: Don't modify context from multiple threads simultaneously</li> <li>Use for Metadata: Use context for metadata, not for control flow</li> </ol>"},{"location":"architecture/execution/#execution-tracer","title":"Execution Tracer","text":"<p>Location: <code>optics_framework/common/execution_tracer.py</code></p> <p>The execution tracer provides structured logging for strategy attempts during element location, helping debug self-healing behavior and understand why certain strategies succeed or fail.</p>"},{"location":"architecture/execution/#purpose","title":"Purpose","text":"<p>Execution tracer logs comprehensive information about strategy attempts:</p> <ul> <li>Strategy Class: Which strategy is being tried</li> <li>Element: Element being located</li> <li>Status: Success or failure status</li> <li>Duration: How long the attempt took</li> <li>Error Messages: Error details (if any)</li> </ul>"},{"location":"architecture/execution/#architecture_1","title":"Architecture","text":"<pre><code>graph TB\n    A[Strategy] --&gt; B[ExecutionTracer]\n    B --&gt; C[execution_logger]\n    C --&gt; D[Log Output]\n\n    E[XPathStrategy] --&gt; B\n    F[TextDetectionStrategy] --&gt; B\n    G[ImageDetectionStrategy] --&gt; B</code></pre>"},{"location":"architecture/execution/#implementation","title":"Implementation","text":"<p>ExecutionTracer Class: <pre><code>class ExecutionTracer:\n    @staticmethod\n    def log_attempt(\n        strategy,\n        element: str,\n        status: str,\n        duration: Optional[float] = None,\n        error: Optional[str] = None\n    ):\n        \"\"\"\n        Log structured strategy attempt information.\n\n        Args:\n            strategy: Strategy class instance\n            element: Element being located\n            status: \"success\" or \"failed\"\n            duration: Duration in seconds\n            error: Error message if failed\n        \"\"\"\n</code></pre></p>"},{"location":"architecture/execution/#usage_1","title":"Usage","text":"<p>Logging Successful Attempt: <pre><code>from optics_framework.common.execution_tracer import execution_tracer\n\nexecution_tracer.log_attempt(\n    strategy=XPathStrategy,\n    element=\"submit_button\",\n    status=\"success\",\n    duration=0.15,\n    error=None\n)\n</code></pre></p> <p>Logging Failed Attempt: <pre><code>execution_tracer.log_attempt(\n    strategy=TextDetectionStrategy,\n    element=\"submit_button\",\n    status=\"failed\",\n    duration=2.5,\n    error=\"Element not found in OCR results\"\n)\n</code></pre></p>"},{"location":"architecture/execution/#log-format","title":"Log Format","text":"<p>Tracer logs are formatted as structured messages:</p> <p>Success: <pre><code>Trying XPathStrategy on 'submit_button' ... SUCCESS, duration: 0.15s\n</code></pre></p> <p>Failure: <pre><code>Trying TextDetectionStrategy on 'submit_button' ... FAILED (error: Element not found), duration: 2.50s\n</code></pre></p> <p>Format Components:</p> <ul> <li>Strategy class name</li> <li>Element identifier</li> <li>Status (SUCCESS/FAILED)</li> <li>Duration (if provided)</li> <li>Error message (if failed)</li> </ul>"},{"location":"architecture/execution/#integration-with-strategies","title":"Integration with Strategies","text":"<p>Strategies use the tracer to log their attempts:</p> <pre><code>class TextDetectionStrategy(LocatorStrategy):\n    def locate(self, element: str, index: int = 0):\n        start_time = time.time()\n        try:\n            result = self._locate_with_ocr(element)\n            duration = time.time() - start_time\n            execution_tracer.log_attempt(\n                self, element, \"success\", duration\n            )\n            return result\n        except Exception as e:\n            duration = time.time() - start_time\n            execution_tracer.log_attempt(\n                self, element, \"failed\", duration, str(e)\n            )\n            raise\n</code></pre> <p>Automatic Logging:</p> <ul> <li>Strategies automatically log attempts</li> <li>Duration calculated automatically</li> <li>Errors captured and logged</li> <li>No manual logging required in most cases</li> </ul>"},{"location":"architecture/execution/#element-name-handling","title":"Element Name Handling","text":"<p>The tracer handles different element formats:</p> <pre><code>element_str = str(element)\nif isinstance(element, list) and len(element) == 1:\n    element_str = str(element[0])\n</code></pre> <p>Examples:</p> <ul> <li>Single string: <code>\"submit_button\"</code> \u2192 <code>\"submit_button\"</code></li> <li>List with one item: <code>[\"submit_button\"]</code> \u2192 <code>\"submit_button\"</code></li> <li>List with multiple: <code>[\"btn1\", \"btn2\"]</code> \u2192 <code>\"['btn1', 'btn2']\"</code></li> </ul>"},{"location":"architecture/execution/#integration-with-logging-system","title":"Integration with Logging System","text":"<p>The tracer uses the execution logger:</p> <pre><code>from optics_framework.common.logging_config import execution_logger\n\nexecution_logger.info(log_line)\n</code></pre> <p>Logger Configuration:</p> <ul> <li>Uses <code>optics.execution</code> logger</li> <li>Logs at INFO level</li> <li>Formatted for user visibility</li> <li>Integrated with execution output</li> </ul>"},{"location":"architecture/execution/#benefits","title":"Benefits","text":"<p>1. Debugging:</p> <ul> <li>See which strategies are tried</li> <li>Understand why strategies fail</li> <li>Track strategy selection order</li> <li>Identify strategy conflicts</li> </ul> <p>2. Performance Analysis:</p> <ul> <li>Identify slow strategies</li> <li>Compare strategy performance</li> <li>Optimize strategy ordering</li> <li>Measure location time</li> </ul> <p>3. Observability:</p> <ul> <li>Track self-healing behavior</li> <li>Monitor strategy success rates</li> <li>Understand fallback patterns</li> <li>Analyze element location patterns</li> </ul> <p>4. Troubleshooting:</p> <ul> <li>Understand element location failures</li> <li>Debug strategy selection issues</li> <li>Identify configuration problems</li> <li>Track down performance issues</li> </ul>"},{"location":"architecture/execution/#example-output","title":"Example Output","text":"<p>Complete Execution Trace: <pre><code>Trying XPathStrategy on 'submit_button' ... FAILED (error: Element not found), duration: 0.05s\nTrying TextElementStrategy on 'submit_button' ... FAILED (error: Element not found), duration: 0.10s\nTrying TextDetectionStrategy on 'submit_button' ... SUCCESS, duration: 2.15s\n</code></pre></p> <p>Analysis:</p> <ul> <li>XPath failed quickly (0.05s) - element not in DOM</li> <li>TextElement failed quickly (0.10s) - element not accessible</li> <li>TextDetection succeeded (2.15s) - found via OCR</li> </ul>"},{"location":"architecture/execution/#best-practices_2","title":"Best Practices","text":"<ol> <li>Always Log: Log both success and failure</li> <li>Include Duration: Measure and log execution time</li> <li>Capture Errors: Include error messages for failures</li> <li>Use Consistently: Use tracer in all strategies</li> <li>Review Logs: Regularly review tracer logs for insights</li> </ol>"},{"location":"architecture/execution/#related-components_1","title":"Related Components","text":"<ul> <li>Strategies: Use tracer to log attempts</li> <li>Execution Logger: Receives tracer logs</li> <li>Self-Healing: Tracer helps understand self-healing behavior</li> <li>Debugging: Tracer essential for debugging location issues</li> </ul>"},{"location":"architecture/execution/#extension-points","title":"Extension Points","text":""},{"location":"architecture/execution/#custom-runners","title":"Custom Runners","text":"<p>Extend <code>Runner</code> base class:</p> <pre><code>class CustomRunner(Runner):\n    async def run_all(self):\n        # Custom execution logic\n        pass\n</code></pre>"},{"location":"architecture/execution/#custom-executors","title":"Custom Executors","text":"<p>Implement <code>Executor</code> interface:</p> <pre><code>class CustomExecutor(Executor):\n    async def execute(self, session: Session, runner: Runner):\n        # Custom execution logic\n        pass\n</code></pre>"},{"location":"architecture/execution/#custom-event-handlers","title":"Custom Event Handlers","text":"<p>Implement <code>EventSubscriber</code>:</p> <pre><code>class CustomEventHandler(EventSubscriber):\n    async def on_event(self, event: Event):\n        # Custom event handling\n        pass\n</code></pre>"},{"location":"architecture/execution/#debugging-execution","title":"Debugging Execution","text":""},{"location":"architecture/execution/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>import logging\nlogging.getLogger(\"optics_framework.common.execution\").setLevel(logging.DEBUG)\n</code></pre>"},{"location":"architecture/execution/#event-monitoring","title":"Event Monitoring","text":"<pre><code># Subscribe to all events\nevent_manager.subscribe(\"debug\", DebugSubscriber())\n</code></pre>"},{"location":"architecture/execution/#result-inspection","title":"Result Inspection","text":"<pre><code># Access results from runner\nresults = runner.result_printer.test_state\nfor test_case_id, result in results.items():\n    print(f\"{test_case_id}: {result.status}\")\n</code></pre>"},{"location":"architecture/execution/#execution-tracer-logging","title":"Execution Tracer Logging","text":"<p>Execution tracer logs are automatically written to <code>execution_logger</code>:</p> <pre><code>import logging\nlogging.getLogger(\"optics.execution\").setLevel(logging.INFO)\n# Tracer logs will appear in execution logs\n</code></pre>"},{"location":"architecture/execution/#related-documentation","title":"Related Documentation","text":"<ul> <li>Components - Component architecture</li> <li>Strategies - Strategy pattern and self-healing</li> <li>Error Handling - Error handling</li> <li>Event System - Event system</li> <li>Logging - Logging system and execution tracer</li> <li>Architecture Decisions - Design decisions for execution architecture</li> <li>Keyword Registry - Keyword registration and lookup</li> <li>Data Models - Linked list structure and data models</li> <li>Test Context - Context variable system</li> <li>Execution Tracer - Strategy attempt logging</li> <li>CLI Layer - CLI execution</li> </ul>"},{"location":"architecture/extending/","title":"Extending Optics Framework","text":"<p>This guide provides step-by-step instructions for extending the Optics Framework by creating custom drivers, element sources, vision models, event handlers, keywords, executors, and result printers.</p>"},{"location":"architecture/extending/#introduction","title":"Introduction","text":"<p>The Optics Framework is designed to be highly extensible. You can extend it at multiple levels:</p> <ul> <li>Engines: Drivers, element sources, and vision models</li> <li>API Layer: Custom keywords and actions</li> <li>Execution Layer: Custom executors and result printers</li> <li>Event System: Custom event subscribers</li> <li>Strategies: Custom element location strategies</li> </ul>"},{"location":"architecture/extending/#when-to-extend","title":"When to Extend","text":"<p>Consider extending when:</p> <ul> <li>You need support for a new automation tool or protocol</li> <li>You want to integrate a custom OCR or image recognition service</li> <li>You need domain-specific keywords</li> <li>You want custom reporting or event handling</li> <li>You need specialized execution modes</li> </ul>"},{"location":"architecture/extending/#extension-architecture","title":"Extension Architecture","text":"<p>Extensions are automatically discovered by the factory system when placed in the correct directories:</p> <pre><code>graph TB\n    A[Your Extension] --&gt; B[Factory Discovery]\n    B --&gt; C[Interface Check]\n    C --&gt; D[Registration]\n    D --&gt; E[Configuration]\n    E --&gt; F[Usage]</code></pre>"},{"location":"architecture/extending/#creating-new-drivers","title":"Creating New Drivers","text":"<p>Drivers execute user actions on target applications or devices.</p>"},{"location":"architecture/extending/#step-1-create-driver-file","title":"Step 1: Create Driver File","text":"<p>Create a new file in <code>optics_framework/engines/drivers/your_driver.py</code>:</p> <pre><code>from typing import Any, Dict, Optional\nfrom optics_framework.common.driver_interface import DriverInterface\nfrom optics_framework.common.logging_config import internal_logger\nfrom optics_framework.common.eventSDK import EventSDK\nfrom optics_framework.common.error import OpticsError, Code\n\nclass YourDriver(DriverInterface):\n    \"\"\"\n    Your custom driver implementation.\n    \"\"\"\n\n    DEPENDENCY_TYPE = \"driver_sources\"\n    NAME = \"your_driver\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None, event_sdk: Optional[EventSDK] = None):\n        \"\"\"\n        Initialize your driver.\n\n        Args:\n            config: Configuration dictionary\n            event_sdk: Optional EventSDK for tracking actions\n        \"\"\"\n        self.config = config or {}\n        self.event_sdk = event_sdk\n        self.driver = None  # Your driver instance\n\n        # Initialize your driver here\n        self._initialize_driver()\n\n    def _initialize_driver(self):\n        \"\"\"Initialize the underlying driver.\"\"\"\n        # Your initialization logic\n        pass\n\n    def launch_app(\n        self,\n        app_identifier: str | None = None,\n        app_activity: str | None = None,\n        event_name: str | None = None,\n    ) -&gt; Optional[str]:\n        \"\"\"Launch an application.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"launch_app\", event_name)\n\n        # Your launch logic\n        session_id = \"your_session_id\"\n        return session_id\n\n    def press_coordinates(\n        self,\n        coor_x: int,\n        coor_y: int,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Press at absolute coordinates.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"press_coordinates\", event_name)\n\n        # Your press logic\n        pass\n\n    def press_element(\n        self,\n        element: str,\n        repeat: int,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Press a UI element.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"press_element\", event_name)\n\n        # Your element press logic\n        pass\n\n    def press_percentage_coordinates(\n        self,\n        percentage_x: float,\n        percentage_y: float,\n        repeat: int,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Press at percentage coordinates.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"press_percentage_coordinates\", event_name)\n\n        # Your percentage press logic\n        pass\n\n    def enter_text(\n        self,\n        text: str,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Enter text.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"enter_text\", event_name)\n\n        # Your text entry logic\n        pass\n\n    def press_keycode(\n        self,\n        keycode: str,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Press a key code.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"press_keycode\", event_name)\n\n        # Your keycode logic\n        pass\n\n    def enter_text_element(\n        self,\n        element: str,\n        text: str,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Enter text into an element.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"enter_text_element\", event_name)\n\n        # Your text entry logic\n        pass\n\n    def enter_text_using_keyboard(\n        self,\n        text: str,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Enter text using keyboard.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"enter_text_using_keyboard\", event_name)\n\n        # Your keyboard input logic\n        pass\n\n    def clear_text(self, event_name: Optional[str] = None) -&gt; None:\n        \"\"\"Clear text.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"clear_text\", event_name)\n\n        # Your clear text logic\n        pass\n\n    def clear_text_element(\n        self,\n        element: str,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Clear text from an element.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"clear_text_element\", event_name)\n\n        # Your clear text logic\n        pass\n\n    def swipe(\n        self,\n        x_coor: int,\n        y_coor: int,\n        direction: str,\n        swipe_length: int,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Swipe gesture.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"swipe\", event_name)\n\n        # Your swipe logic\n        pass\n\n    def swipe_percentage(\n        self,\n        x_percentage: int,\n        y_percentage: int,\n        direction: str,\n        swipe_length_percentage: int,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Swipe by percentage (x_percentage, y_percentage, swipe_length_percentage are integers 0-100).\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"swipe_percentage\", event_name)\n\n        # Your swipe logic\n        pass\n\n    def swipe_element(\n        self,\n        element: str,\n        direction: str,\n        swipe_length: int,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Swipe an element.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"swipe_element\", event_name)\n\n        # Your swipe logic\n        pass\n\n    def scroll(\n        self,\n        direction: str,\n        duration: int,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Scroll gesture.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"scroll\", event_name)\n\n        # Your scroll logic\n        pass\n\n    def get_text_element(self, element: str) -&gt; str:\n        \"\"\"Get text from an element.\"\"\"\n        # Your text extraction logic\n        return \"extracted_text\"\n\n    def force_terminate_app(\n        self,\n        app_name: str,\n        event_name: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Force terminate an application.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"force_terminate_app\", event_name)\n\n        # Your termination logic\n        pass\n\n    def terminate(self) -&gt; None:\n        \"\"\"Clean up and terminate the driver.\"\"\"\n        # Your cleanup logic\n        if self.driver:\n            # Close connections, release resources\n            pass\n\n    def get_app_version(self) -&gt; str:\n        \"\"\"Get application version.\"\"\"\n        # Your version retrieval logic\n        return \"1.0.0\"\n\n    def launch_other_app(\n        self,\n        app_name: str,\n        event_name: str | None\n    ) -&gt; None:\n        \"\"\"Launch another application.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"launch_other_app\", event_name)\n\n        # Your launch logic\n        pass\n\n    def get_driver_session_id(self) -&gt; Optional[str]:\n        \"\"\"Get driver session ID if supported.\"\"\"\n        return getattr(self.driver, 'session_id', None)\n\n    def execute_script(\n        self,\n        script: str,\n        *args,\n        event_name: Optional[str] = None\n    ) -&gt; Any:\n        \"\"\"Execute a script.\"\"\"\n        if self.event_sdk:\n            self.event_sdk.track_action(\"execute_script\", event_name)\n\n        # Your script execution logic\n        return None\n</code></pre>"},{"location":"architecture/extending/#step-2-configuration","title":"Step 2: Configuration","text":"<p>Your driver will be automatically discovered. Use it in configuration:</p> <pre><code>driver_sources:\n  - your_driver:\n      enabled: true\n      url: \"your_driver_url\"\n      capabilities:\n        key1: \"value1\"\n        key2: \"value2\"\n</code></pre>"},{"location":"architecture/extending/#key-points","title":"Key Points","text":"<ul> <li>Set <code>DEPENDENCY_TYPE = \"driver_sources\"</code> and <code>NAME = \"your_driver\"</code></li> <li>Implement all abstract methods from <code>DriverInterface</code></li> <li>Use <code>EventSDK</code> for action tracking (optional but recommended)</li> <li>Handle errors gracefully with <code>OpticsError</code></li> <li>Implement proper cleanup in <code>terminate()</code></li> </ul>"},{"location":"architecture/extending/#creating-new-element-sources","title":"Creating New Element Sources","text":"<p>Element sources detect and locate UI elements.</p>"},{"location":"architecture/extending/#step-1-create-element-source-file","title":"Step 1: Create Element Source File","text":"<p>Create a new file in <code>optics_framework/engines/elementsources/your_element_source.py</code>:</p> <pre><code>from typing import Optional, Any, List\nimport numpy as np\nfrom optics_framework.common.elementsource_interface import ElementSourceInterface\nfrom optics_framework.common.logging_config import internal_logger\n\nclass YourElementSource(ElementSourceInterface):\n    \"\"\"\n    Your custom element source implementation.\n    \"\"\"\n\n    # If your element source requires a specific driver, set this:\n    REQUIRED_DRIVER_TYPE = \"your_driver\"  # or None if driver-independent\n\n    def __init__(self, driver: Optional[Any] = None, config: Optional[dict] = None):\n        \"\"\"\n        Initialize element source.\n\n        Args:\n            driver: Optional driver instance (if REQUIRED_DRIVER_TYPE is set)\n            config: Optional configuration dictionary\n        \"\"\"\n        self.driver = driver\n        self.config = config or {}\n\n    def capture(self) -&gt; np.ndarray:\n        \"\"\"\n        Capture the current screen state.\n\n        Returns:\n            Screenshot as NumPy array\n        \"\"\"\n        # Your screenshot capture logic\n        # Return as numpy.ndarray with shape (height, width, channels)\n        pass\n\n    def locate(self, element: Any, index: int | None = None) -&gt; tuple:\n        \"\"\"\n        Locate an element within the current screen state.\n\n        Args:\n            element: Element identifier (XPath, text, etc.)\n            index: Index if multiple matches\n\n        Returns:\n            Tuple (x, y) representing element center, or element object\n        \"\"\"\n        # Your element location logic\n        # Return coordinates (x, y) or element object\n        pass\n\n    def assert_elements(\n        self,\n        elements: Any,\n        timeout: int = 30,\n        rule: str = 'any'\n    ) -&gt; None:\n        \"\"\"\n        Assert the presence of elements on the screen.\n\n        Args:\n            elements: List of elements to check\n            timeout: Time to wait\n            rule: 'any' or 'all'\n\n        Raises:\n            AssertionError if assertion fails\n        \"\"\"\n        # Your assertion logic\n        pass\n\n    def get_interactive_elements(\n        self,\n        filter_config: Optional[List[str]] = None\n    ) -&gt; list:\n        \"\"\"\n        Retrieve interactive elements on the current screen.\n\n        Args:\n            filter_config: Optional filter types (e.g., [\"buttons\", \"inputs\"])\n\n        Returns:\n            List of interactive elements\n        \"\"\"\n        # Your interactive element detection logic\n        return []\n</code></pre>"},{"location":"architecture/extending/#step-2-driver-dependency","title":"Step 2: Driver Dependency","text":"<p>If your element source requires a specific driver:</p> <pre><code>REQUIRED_DRIVER_TYPE = \"appium\"  # Must match driver NAME\n</code></pre> <p>The factory will automatically match and inject the driver.</p>"},{"location":"architecture/extending/#step-3-configuration","title":"Step 3: Configuration","text":"<pre><code>elements_sources:\n  - your_element_source:\n      enabled: true\n      # Additional configuration\n</code></pre>"},{"location":"architecture/extending/#key-points_1","title":"Key Points","text":"<ul> <li>Set <code>REQUIRED_DRIVER_TYPE</code> if driver-dependent</li> <li>Implement all abstract methods from <code>ElementSourceInterface</code></li> <li>Return NumPy arrays for screenshots</li> <li>Handle timeouts and retries in <code>assert_elements()</code></li> </ul>"},{"location":"architecture/extending/#creating-new-text-detection-models","title":"Creating New Text Detection Models","text":"<p>Text detection models provide OCR capabilities.</p>"},{"location":"architecture/extending/#step-1-create-ocr-model-file","title":"Step 1: Create OCR Model File","text":"<p>Create a new file in <code>optics_framework/engines/vision_models/ocr_models/your_ocr.py</code>:</p> <pre><code>from typing import Optional, Tuple, Any, List\nimport numpy as np\nfrom optics_framework.common.text_interface import TextInterface\nfrom optics_framework.common.logging_config import internal_logger\n\nclass YourOCR(TextInterface):\n    \"\"\"\n    Your custom OCR implementation.\n    \"\"\"\n\n    def __init__(self, config: Optional[dict] = None):\n        \"\"\"\n        Initialize OCR model.\n\n        Args:\n            config: Configuration dictionary\n        \"\"\"\n        self.config = config or {}\n        # Initialize your OCR engine here\n        self._initialize_ocr()\n\n    def _initialize_ocr(self):\n        \"\"\"Initialize the OCR engine.\"\"\"\n        # Your initialization logic\n        pass\n\n    def element_exist(\n        self,\n        input_data: Any,\n        reference_data: Any\n    ) -&gt; Optional[Tuple[int, int]]:\n        \"\"\"\n        Check if text exists in input data.\n\n        Args:\n            input_data: Screenshot/image as NumPy array\n            reference_data: Text to search for\n\n        Returns:\n            Tuple (x, y) of text location, or None if not found\n        \"\"\"\n        # Your text detection logic\n        # Return (x, y) coordinates or None\n        pass\n\n    def find_element(\n        self,\n        input_data,\n        text,\n        index=None\n    ) -&gt; Optional[Tuple[bool, Tuple[int, int], Tuple[Tuple[int, int], Tuple[int, int]]]]:\n        \"\"\"\n        Locate specific text in input data.\n\n        Args:\n            input_data: Screenshot/image as NumPy array\n            text: Text to locate\n            index: Index if multiple matches\n\n        Returns:\n            Tuple (found, center, bounds) where:\n            - found: bool\n            - center: (x, y) coordinates\n            - bounds: ((x1, y1), (x2, y2)) bounding box\n            Returns None if not found\n        \"\"\"\n        # Your text location logic\n        # Return (True, (x, y), ((x1, y1), (x2, y2))) or None\n        pass\n\n    def detect_text(\n        self,\n        input_data\n    ) -&gt; Optional[Tuple[str, List[Tuple[List[Tuple[int, int]], str, float]]]]:\n        \"\"\"\n        Detect all text in input data.\n\n        Args:\n            input_data: Screenshot/image as NumPy array\n\n        Returns:\n            Tuple (detected_text_str, results) where each result is:\n            (bbox, text, confidence) where bbox is list of (x,y) tuples\n        \"\"\"\n        # Your full text detection logic\n        # Return (full_text_string, [(bbox, text, confidence), ...])\n        pass\n</code></pre>"},{"location":"architecture/extending/#step-2-configuration_1","title":"Step 2: Configuration","text":"<pre><code>text_detection:\n  - your_ocr:\n      enabled: true\n      api_key: \"your_api_key\"\n      language: \"en\"\n</code></pre>"},{"location":"architecture/extending/#key-points_2","title":"Key Points","text":"<ul> <li>Implement all abstract methods from <code>TextInterface</code></li> <li>Handle NumPy array inputs (screenshots)</li> <li>Return bounding boxes with confidence scores</li> <li>Support multiple language detection</li> </ul>"},{"location":"architecture/extending/#creating-new-image-detection-models","title":"Creating New Image Detection Models","text":"<p>Image detection models provide template matching capabilities.</p>"},{"location":"architecture/extending/#step-1-create-image-model-file","title":"Step 1: Create Image Model File","text":"<p>Create a new file in <code>optics_framework/engines/vision_models/image_models/your_image_matcher.py</code>:</p> <pre><code>from typing import Literal, Optional, Tuple, Any\nimport numpy as np\nimport cv2\nfrom optics_framework.common.image_interface import ImageInterface\nfrom optics_framework.common.logging_config import internal_logger\nfrom optics_framework.engines.vision_models.base_methods import load_template\n\nclass YourImageMatcher(ImageInterface):\n    \"\"\"\n    Your custom image matching implementation.\n    \"\"\"\n\n    def __init__(self, config: Optional[dict] = None):\n        \"\"\"\n        Initialize image matcher.\n\n        Args:\n            config: Configuration dictionary with project_path and templates\n        \"\"\"\n        self.config = config or {}\n        self.project_path = self.config.get(\"project_path\", \"\")\n        self.templates = self.config.get(\"templates\", None)\n        self.execution_output_dir = self.config.get(\"execution_output_path\", \"\")\n\n    def element_exist(\n        self,\n        input_data: Any,\n        reference_data: Any\n    ) -&gt; (\n        tuple[Literal[False], tuple[None, None], None]\n        | tuple[Literal[True], tuple[int, int], list[tuple[int, int]]]\n    ):\n        \"\"\"\n        Check if image exists in input data.\n\n        Args:\n            input_data: Screenshot/image as NumPy array\n            reference_data: Template image path or name\n\n        Returns:\n            (False, (None, None), None) if not found\n            (True, (x, y), [corners]) if found\n        \"\"\"\n        # Load template\n        template = load_template(reference_data, self.templates)\n        if template is None:\n            return (False, (None, None), None)\n\n        # Your image matching logic\n        # Return (True, (x, y), [corners]) or (False, (None, None), None)\n        pass\n\n    def find_element(\n        self,\n        input_data,\n        image,\n        index=None\n    ) -&gt; Optional[Tuple[bool, Tuple[int, int], Tuple[Tuple[int, int], Tuple[int, int]]]]:\n        \"\"\"\n        Locate image in input data.\n\n        Args:\n            input_data: Screenshot/image as NumPy array\n            image: Template image path or name\n            index: Index if multiple matches\n\n        Returns:\n            Tuple (found, center, bounds) where:\n            - found: bool\n            - center: (x, y) coordinates\n            - bounds: ((x1, y1), (x2, y2)) bounding box\n            Returns None if not found\n        \"\"\"\n        # Load template\n        template = load_template(image, self.templates)\n        if template is None:\n            return None\n\n        # Your image matching logic\n        # Return (True, (x, y), ((x1, y1), (x2, y2))) or None\n        pass\n\n    def assert_elements(\n        self,\n        input_data,\n        elements,\n        rule=\"any\"\n    ) -&gt; Optional[Tuple[bool, Any]]:\n        \"\"\"\n        Assert that elements are present.\n\n        Args:\n            input_data: Screenshot/image as NumPy array\n            elements: List of template images\n            rule: \"any\" or \"all\"\n\n        Returns:\n            Tuple (result, annotated_image) or None\n        \"\"\"\n        # Your assertion logic\n        # Check if elements exist based on rule\n        # Return (True, annotated_image) or (False, None)\n        pass\n</code></pre>"},{"location":"architecture/extending/#step-2-configuration_2","title":"Step 2: Configuration","text":"<pre><code>image_detection:\n  - your_image_matcher:\n      enabled: true\n      project_path: \"/path/to/project\"\n      execution_output_path: \"/path/to/output\"\n      confidence_threshold: 0.85\n</code></pre>"},{"location":"architecture/extending/#key-points_3","title":"Key Points","text":"<ul> <li>Use <code>load_template()</code> helper to load template images</li> <li>Support template discovery from project directory</li> <li>Return proper coordinate formats</li> <li>Support multiple match detection (index parameter)</li> </ul>"},{"location":"architecture/extending/#creating-new-event-subscribers","title":"Creating New Event Subscribers","text":"<p>Event subscribers process execution events for custom handling.</p>"},{"location":"architecture/extending/#step-1-create-event-subscriber","title":"Step 1: Create Event Subscriber","text":"<p>Create a new file in <code>optics_framework/common/your_event_handler.py</code>:</p> <pre><code>from optics_framework.common.events import EventSubscriber, Event, EventStatus\nfrom optics_framework.common.logging_config import internal_logger\nfrom typing import Optional\n\nclass YourEventHandler(EventSubscriber):\n    \"\"\"\n    Your custom event handler.\n    \"\"\"\n\n    def __init__(self, config: Optional[dict] = None):\n        \"\"\"\n        Initialize event handler.\n\n        Args:\n            config: Optional configuration dictionary\n        \"\"\"\n        self.config = config or {}\n        self.events = []  # Store events if needed\n\n    async def on_event(self, event: Event) -&gt; None:\n        \"\"\"\n        Process an event.\n\n        Args:\n            event: Event object to process\n        \"\"\"\n        # Your event processing logic\n        internal_logger.debug(f\"Processing event: {event.name} - {event.status}\")\n\n        # Example: Filter by entity type\n        if event.entity_type == \"keyword\":\n            self._handle_keyword_event(event)\n        elif event.entity_type == \"test_case\":\n            self._handle_test_case_event(event)\n        elif event.entity_type == \"module\":\n            self._handle_module_event(event)\n\n    def _handle_keyword_event(self, event: Event):\n        \"\"\"Handle keyword-level events.\"\"\"\n        # Your keyword event logic\n        pass\n\n    def _handle_test_case_event(self, event: Event):\n        \"\"\"Handle test case-level events.\"\"\"\n        # Your test case event logic\n        pass\n\n    def _handle_module_event(self, event: Event):\n        \"\"\"Handle module-level events.\"\"\"\n        # Your module event logic\n        pass\n\n    def close(self):\n        \"\"\"Cleanup resources.\"\"\"\n        # Your cleanup logic\n        pass\n</code></pre>"},{"location":"architecture/extending/#step-2-register-event-subscriber","title":"Step 2: Register Event Subscriber","text":"<p>Register your subscriber in session setup:</p> <pre><code>from optics_framework.common.events import get_event_manager\nfrom optics_framework.common.your_event_handler import YourEventHandler\n\n# Get event manager for session\nevent_manager = get_event_manager(session_id)\n\n# Create and register your handler\nhandler = YourEventHandler(config={})\nevent_manager.subscribe(\"your_handler\", handler)\n</code></pre>"},{"location":"architecture/extending/#step-3-integration-in-session","title":"Step 3: Integration in Session","text":"<p>You can also integrate during session creation by modifying session setup or using a custom initialization hook.</p>"},{"location":"architecture/extending/#key-points_4","title":"Key Points","text":"<ul> <li>Implement <code>EventSubscriber</code> interface</li> <li>Handle events asynchronously</li> <li>Filter events by entity type or status</li> <li>Implement <code>close()</code> for cleanup</li> <li>Reference <code>JUnitEventHandler</code> for a complete example</li> </ul>"},{"location":"architecture/extending/#creating-new-keywords","title":"Creating New Keywords","text":"<p>Keywords are the user-facing API for test automation.</p>"},{"location":"architecture/extending/#step-1-add-method-to-api-class","title":"Step 1: Add Method to API Class","text":"<p>Add your keyword to an existing API class or create a new one in <code>optics_framework/api/your_keywords.py</code>:</p> <pre><code>from typing import Optional\nfrom optics_framework.common.optics_builder import OpticsBuilder\nfrom optics_framework.common.logging_config import internal_logger\nfrom optics_framework.optics import keyword, fallback_params, fallback_str\n\nclass YourKeywords:\n    \"\"\"\n    Your custom keywords.\n    \"\"\"\n\n    def __init__(self, builder: OpticsBuilder):\n        self.builder = builder\n        self.driver = builder.get_driver()\n        self.element_source = builder.get_element_source()\n\n    @keyword(\"Your Custom Keyword\")\n    @fallback_params  # Optional: for fallback parameter support\n    def your_custom_keyword(\n        self,\n        param1: fallback_str,\n        param2: Optional[fallback_str] = None,\n        event_name: Optional[fallback_str] = None\n    ) -&gt; Optional[str]:\n        \"\"\"\n        Your custom keyword description.\n\n        Args:\n            param1: First parameter (supports fallback)\n            param2: Optional second parameter\n            event_name: Optional event name for tracking\n\n        Returns:\n            Optional result value\n        \"\"\"\n        # Your keyword logic\n        internal_logger.info(f\"Executing your_custom_keyword with {param1}\")\n\n        # Access driver, element source, etc.\n        # self.driver.press_coordinates(x, y)\n\n        return \"result\"\n</code></pre>"},{"location":"architecture/extending/#step-2-register-keywords","title":"Step 2: Register Keywords","text":"<p>Register your keywords in the Optics class or session setup:</p> <pre><code># In optics.py or session initialization\nfrom optics_framework.api.your_keywords import YourKeywords\n\n# Build your keywords\nyour_keywords = session.optics.build(YourKeywords)\n\n# Register with keyword registry\nregistry = KeywordRegistry()\nregistry.register(your_keywords)\n</code></pre>"},{"location":"architecture/extending/#step-3-add-to-optics-class-optional","title":"Step 3: Add to Optics Class (Optional)","text":"<p>If you want to expose keywords through the main Optics class, add wrapper methods in <code>optics_framework/optics.py</code>:</p> <pre><code>@keyword(\"Your Custom Keyword\")\n@fallback_params\ndef your_custom_keyword(\n    self,\n    param1: fallback_str,\n    param2: Optional[fallback_str] = None,\n    event_name: Optional[fallback_str] = None\n) -&gt; Optional[str]:\n    \"\"\"Your custom keyword.\"\"\"\n    if not hasattr(self, 'your_keywords'):\n        self.your_keywords = self.session_manager.sessions[self.session_id].optics.build(YourKeywords)\n    return self.your_keywords.your_custom_keyword(\n        param1=cast(str, param1),\n        param2=cast(Optional[str], param2),\n        event_name=cast(Optional[str], event_name)\n    )\n</code></pre>"},{"location":"architecture/extending/#key-points_5","title":"Key Points","text":"<ul> <li>Use <code>@keyword(\"Display Name\")</code> decorator</li> <li>Use <code>@fallback_params</code> for fallback parameter support</li> <li>Use <code>fallback_str</code> type hint for fallback parameters</li> <li>Access builder components (driver, element_source, etc.)</li> <li>Handle errors gracefully</li> </ul>"},{"location":"architecture/extending/#creating-new-test-executors","title":"Creating New Test Executors","text":"<p>Executors handle different execution modes.</p>"},{"location":"architecture/extending/#step-1-create-executor","title":"Step 1: Create Executor","text":"<p>Create a new file or add to <code>optics_framework/common/execution.py</code>:</p> <pre><code>from optics_framework.common.execution import Executor\nfrom optics_framework.common.session_manager import Session\nfrom optics_framework.common.runner.test_runnner import Runner\nfrom optics_framework.common.events import EventManager, Event, EventStatus\nfrom optics_framework.common.error import OpticsError, Code\nfrom optics_framework.common.models import TestCaseNode\n\nclass YourExecutor(Executor):\n    \"\"\"\n    Your custom executor implementation.\n    \"\"\"\n\n    def __init__(self, test_case: Optional[TestCaseNode], event_manager: EventManager):\n        \"\"\"\n        Initialize executor.\n\n        Args:\n            test_case: Optional test case node\n            event_manager: Event manager for publishing events\n        \"\"\"\n        self.test_case = test_case\n        self.event_manager = event_manager\n\n    async def execute(self, session: Session, runner: Runner) -&gt; None:\n        \"\"\"\n        Execute with custom logic.\n\n        Args:\n            session: Session instance\n            runner: Runner instance\n        \"\"\"\n        # Your custom execution logic\n        try:\n            # Publish start event\n            await self.event_manager.publish_event(Event(\n                entity_type=\"execution\",\n                entity_id=session.session_id,\n                name=\"Your Execution\",\n                status=EventStatus.RUNNING,\n                message=\"Starting custom execution\"\n            ))\n\n            # Your execution logic\n            # For example, run with custom filtering\n            if self.test_case:\n                # Custom execution\n                await runner.run_all()\n\n            # Publish completion event\n            await self.event_manager.publish_event(Event(\n                entity_type=\"execution\",\n                entity_id=session.session_id,\n                name=\"Your Execution\",\n                status=EventStatus.PASS,\n                message=\"Execution completed\"\n            ))\n        except Exception as e:\n            await self.event_manager.publish_event(Event(\n                entity_type=\"execution\",\n                entity_id=session.session_id,\n                name=\"Your Execution\",\n                status=EventStatus.FAIL,\n                message=f\"Execution failed: {str(e)}\"\n            ))\n            raise\n</code></pre>"},{"location":"architecture/extending/#step-2-integrate-with-executionengine","title":"Step 2: Integrate with ExecutionEngine","text":"<p>Modify <code>ExecutionEngine</code> to support your executor:</p> <pre><code># In optics_framework/common/execution.py\nclass ExecutionEngine:\n    async def execute(self, params: ExecutionParams) -&gt; Any:\n        # ... existing code ...\n\n        # Add your executor\n        if params.mode == \"your_mode\":\n            executor = YourExecutor(test_case, event_manager)\n        elif params.mode == \"batch\":\n            executor = BatchExecutor(test_case, event_manager)\n        # ... etc ...\n</code></pre>"},{"location":"architecture/extending/#key-points_6","title":"Key Points","text":"<ul> <li>Implement <code>Executor</code> interface</li> <li>Handle async execution</li> <li>Publish events for tracking</li> <li>Handle errors gracefully</li> <li>Integrate with ExecutionEngine</li> </ul>"},{"location":"architecture/extending/#creating-new-result-printers","title":"Creating New Result Printers","text":"<p>Result printers format and display test execution results.</p>"},{"location":"architecture/extending/#step-1-create-result-printer","title":"Step 1: Create Result Printer","text":"<p>Create a new file in <code>optics_framework/common/runner/your_printer.py</code>:</p> <pre><code>from typing import Dict\nfrom optics_framework.common.runner.printers import (\n    IResultPrinter,\n    TestCaseResult,\n    KeywordResult,\n    ModuleResult\n)\nfrom optics_framework.common.logging_config import internal_logger\n\nclass YourResultPrinter(IResultPrinter):\n    \"\"\"\n    Your custom result printer.\n    \"\"\"\n\n    def __init__(self, config: Optional[dict] = None):\n        \"\"\"\n        Initialize result printer.\n\n        Args:\n            config: Optional configuration dictionary\n        \"\"\"\n        self.config = config or {}\n        self._test_state: Dict[str, TestCaseResult] = {}\n\n    @property\n    def test_state(self) -&gt; Dict[str, TestCaseResult]:\n        \"\"\"Get test state.\"\"\"\n        return self._test_state\n\n    @test_state.setter\n    def test_state(self, value: Dict[str, TestCaseResult]) -&gt; None:\n        \"\"\"Set test state.\"\"\"\n        self._test_state = value\n\n    def print_tree_log(self, test_case_result: TestCaseResult) -&gt; None:\n        \"\"\"\n        Print test case result in tree format.\n\n        Args:\n            test_case_result: Test case result to print\n        \"\"\"\n        # Your tree printing logic\n        internal_logger.info(f\"Test Case: {test_case_result.name} - {test_case_result.status}\")\n\n        for module in test_case_result.modules:\n            internal_logger.info(f\"  Module: {module.name} - {module.status}\")\n            for keyword in module.keywords:\n                internal_logger.info(f\"    Keyword: {keyword.name} - {keyword.status}\")\n\n    def print_event_log(self, event_data: dict) -&gt; None:\n        \"\"\"\n        Print event log.\n\n        Args:\n            event_data: Event data dictionary\n        \"\"\"\n        # Your event printing logic\n        internal_logger.debug(f\"Event: {event_data}\")\n\n    def start_live(self) -&gt; None:\n        \"\"\"Start live updates.\"\"\"\n        # Your live update initialization\n        pass\n\n    def stop_live(self) -&gt; None:\n        \"\"\"Stop live updates.\"\"\"\n        # Your live update cleanup\n        pass\n\n    def start_run(self, total_test_cases: int) -&gt; None:\n        \"\"\"\n        Start a test run.\n\n        Args:\n            total_test_cases: Total number of test cases\n        \"\"\"\n        # Your run initialization\n        internal_logger.info(f\"Starting run with {total_test_cases} test cases\")\n</code></pre>"},{"location":"architecture/extending/#step-2-integrate-with-runnerfactory","title":"Step 2: Integrate with RunnerFactory","text":"<p>Modify <code>RunnerFactory</code> to use your printer:</p> <pre><code># In optics_framework/common/execution.py\nfrom optics_framework.common.runner.your_printer import YourResultPrinter\n\nclass RunnerFactory:\n    @staticmethod\n    def create_runner(...):\n        # ... existing code ...\n\n        if use_printer:\n            result_printer = YourResultPrinter(config={})\n        else:\n            result_printer = NullResultPrinter()\n\n        # ... rest of code ...\n</code></pre>"},{"location":"architecture/extending/#key-points_7","title":"Key Points","text":"<ul> <li>Implement all methods from <code>IResultPrinter</code></li> <li>Maintain test state dictionary</li> <li>Support live updates if needed</li> <li>Format output as needed</li> <li>Reference <code>TreeResultPrinter</code> for Rich library usage</li> </ul>"},{"location":"architecture/extending/#creating-new-strategies","title":"Creating New Strategies","text":"<p>Strategies provide element location methods.</p>"},{"location":"architecture/extending/#step-1-create-strategy","title":"Step 1: Create Strategy","text":"<p>Add to <code>optics_framework/common/strategies.py</code>:</p> <pre><code>from optics_framework.common.strategies import LocatorStrategy\nfrom optics_framework.common.elementsource_interface import ElementSourceInterface\nfrom typing import Union, Tuple, Optional\n\nclass YourStrategy(LocatorStrategy):\n    \"\"\"\n    Your custom location strategy.\n    \"\"\"\n\n    def __init__(self, element_source: ElementSourceInterface):\n        self._element_source = element_source\n\n    @property\n    def element_source(self) -&gt; ElementSourceInterface:\n        return self._element_source\n\n    def locate(\n        self,\n        element: str,\n        index: int = 0\n    ) -&gt; Union[object, Tuple[int, int]]:\n        \"\"\"\n        Locate element using your custom method.\n\n        Args:\n            element: Element identifier\n            index: Index if multiple matches\n\n        Returns:\n            Coordinates (x, y) or element object\n        \"\"\"\n        # Your location logic\n        pass\n\n    def assert_elements(\n        self,\n        elements: list,\n        timeout: int = 30,\n        rule: str = 'any'\n    ) -&gt; Tuple[bool, Optional[str]]:\n        \"\"\"\n        Assert element presence.\n\n        Args:\n            elements: List of elements\n            timeout: Timeout in seconds\n            rule: 'any' or 'all'\n\n        Returns:\n            Tuple (result, timestamp)\n        \"\"\"\n        # Your assertion logic\n        pass\n\n    @staticmethod\n    def supports(\n        element_type: str,\n        element_source: ElementSourceInterface\n    ) -&gt; bool:\n        \"\"\"\n        Check if strategy supports element type and source.\n\n        Args:\n            element_type: Type of element (e.g., \"Custom\")\n            element_source: Element source to check\n\n        Returns:\n            True if supported\n        \"\"\"\n        return (\n            element_type == \"Custom\" and\n            LocatorStrategy._is_method_implemented(element_source, \"your_method\")\n        )\n</code></pre>"},{"location":"architecture/extending/#step-2-register-strategy","title":"Step 2: Register Strategy","text":"<p>Register in <code>StrategyFactory</code>:</p> <pre><code># In optics_framework/common/strategies.py\nclass StrategyFactory:\n    def __init__(self, text_detection, image_detection, strategy_manager):\n        # ... existing code ...\n        self._registry = [\n            # ... existing strategies ...\n            (YourStrategy, \"Custom\", {}, 5),  # Priority 5\n        ]\n</code></pre>"},{"location":"architecture/extending/#key-points_8","title":"Key Points","text":"<ul> <li>Extend <code>LocatorStrategy</code> base class</li> <li>Implement <code>supports()</code> static method</li> <li>Register in <code>StrategyFactory</code></li> <li>Set appropriate priority</li> <li>Handle element source capabilities</li> </ul>"},{"location":"architecture/extending/#best-practices","title":"Best Practices","text":""},{"location":"architecture/extending/#code-organization","title":"Code Organization","text":"<ol> <li>Follow Directory Structure: Place extensions in appropriate directories</li> <li>Naming Conventions: Use descriptive names matching framework patterns</li> <li>Module Structure: One class per file, clear imports</li> <li>Documentation: Add docstrings to all public methods</li> </ol>"},{"location":"architecture/extending/#error-handling","title":"Error Handling","text":"<pre><code>from optics_framework.common.error import OpticsError, Code\n\ntry:\n    # Your code\n    pass\nexcept SpecificError as e:\n    raise OpticsError(\n        Code.EXXXX,  # Use appropriate error code\n        message=f\"Descriptive error message: {e}\",\n        details={\"context\": \"additional_info\"}\n    )\n</code></pre>"},{"location":"architecture/extending/#logging","title":"Logging","text":"<pre><code>from optics_framework.common.logging_config import internal_logger, execution_logger\n\n# Use internal_logger for debug/info\ninternal_logger.debug(\"Debug message\")\ninternal_logger.info(\"Info message\")\n\n# Use execution_logger for execution events\nexecution_logger.info(\"Execution event\")\n</code></pre>"},{"location":"architecture/extending/#testing-extensions","title":"Testing Extensions","text":"<ol> <li>Unit Tests: Test individual methods</li> <li>Integration Tests: Test with framework components</li> <li>Configuration Tests: Test with various configurations</li> <li>Error Cases: Test error handling</li> </ol>"},{"location":"architecture/extending/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Lazy Loading: Initialize heavy resources on demand</li> <li>Caching: Cache expensive operations</li> <li>Connection Pooling: Reuse connections when possible</li> <li>Async Operations: Use async for I/O operations</li> </ol>"},{"location":"architecture/extending/#troubleshooting","title":"Troubleshooting","text":""},{"location":"architecture/extending/#factory-discovery-issues","title":"Factory Discovery Issues","text":"<p>Problem: Extension not discovered by factory</p> <p>Solutions:</p> <ul> <li>Verify file is in correct directory</li> <li>Check class name matches file name (convention)</li> <li>Ensure class implements correct interface</li> <li>Verify <code>DEPENDENCY_TYPE</code> and <code>NAME</code> attributes are set</li> <li>Check for import errors in module</li> </ul>"},{"location":"architecture/extending/#driver-matching-issues","title":"Driver Matching Issues","text":"<p>Problem: Element source not matching with driver</p> <p>Solutions:</p> <ul> <li>Verify <code>REQUIRED_DRIVER_TYPE</code> matches driver <code>NAME</code></li> <li>Check driver is enabled in configuration</li> <li>Ensure driver is instantiated before element source</li> <li>Verify factory matching logic</li> </ul>"},{"location":"architecture/extending/#configuration-issues","title":"Configuration Issues","text":"<p>Problem: Configuration not passed correctly</p> <p>Solutions:</p> <ul> <li>Check configuration structure matches expected format</li> <li>Verify configuration keys match what your extension expects</li> <li>Use <code>config.get()</code> with defaults for optional values</li> <li>Validate configuration in <code>__init__</code></li> </ul>"},{"location":"architecture/extending/#event-handling-issues","title":"Event Handling Issues","text":"<p>Problem: Events not received by subscriber</p> <p>Solutions:</p> <ul> <li>Verify subscriber is registered with correct session ID</li> <li>Check event manager is started</li> <li>Ensure <code>on_event()</code> is async</li> <li>Verify event filtering logic</li> </ul>"},{"location":"architecture/extending/#strategy-selection-issues","title":"Strategy Selection Issues","text":"<p>Problem: Strategy not being used</p> <p>Solutions:</p> <ul> <li>Check <code>supports()</code> method returns True</li> <li>Verify element type matches strategy registration</li> <li>Check element source implements required methods</li> <li>Review strategy priority ordering</li> </ul>"},{"location":"architecture/extending/#next-steps","title":"Next Steps","text":"<ul> <li>Review Architecture Overview for system design</li> <li>Check Components for component details</li> <li>See Engines for implementation examples</li> <li>Read Strategies for strategy patterns</li> <li>Explore Execution for execution flow</li> <li>Review Error Handling for error handling patterns</li> <li>Check Event System for event tracking</li> </ul>"},{"location":"architecture/extending/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview - System architecture</li> <li>Components - Component details</li> <li>Engines - Engine implementations</li> <li>Strategies - Strategy patterns</li> <li>Execution - Execution flow</li> <li>Error Handling - Error handling</li> <li>Event System - Event tracking</li> <li>Architecture Decisions - Design decisions and extension rationale</li> <li>REST API Usage - REST API endpoints</li> <li>API Reference - Python API documentation</li> </ul>"},{"location":"architecture/library_layer/","title":"Library Layer Architecture","text":"<p>The Optics Framework provides a Python library interface that enables programmatic access to framework functionality. This document explains the library architecture, usage patterns, and how it integrates with the core framework.</p>"},{"location":"architecture/library_layer/#overview","title":"Overview","text":"<p>The Library layer provides:</p> <ol> <li>Programmatic Interface - Direct Python API for test automation</li> <li>Robot Framework Integration - Can be used as a Robot Framework library</li> <li>Session Management - Create and manage test sessions programmatically</li> <li>Keyword Access - Direct access to all framework keywords</li> <li>Configuration Management - Flexible configuration via code or files</li> </ol>"},{"location":"architecture/library_layer/#library-architecture","title":"Library Architecture","text":"<pre><code>graph TB\n    A[Python Code] --&gt; B[Optics Class]\n    B --&gt; C[SessionManager]\n    B --&gt; D[ActionKeyword]\n    B --&gt; E[AppManagement]\n    B --&gt; F[Verifier]\n    B --&gt; G[FlowControl]\n    C --&gt; H[Session]\n    H --&gt; I[OpticsBuilder]\n    I --&gt; J[Factories]\n    J --&gt; K[Drivers]\n    J --&gt; L[Element Sources]\n    J --&gt; M[Vision Models]</code></pre> <p>Location: <code>optics_framework/optics.py</code></p>"},{"location":"architecture/library_layer/#optics-class","title":"Optics Class","text":"<p>The <code>Optics</code> class is the main entry point for the Python library. It provides a unified interface that can be used both as a standalone Python library and as a Robot Framework library.</p>"},{"location":"architecture/library_layer/#class-structure","title":"Class Structure","text":"<pre><code>@library(scope=\"GLOBAL\")\nclass Optics:\n    \"\"\"\n    A lightweight interface to interact with the Optics Framework.\n    Provides direct access to app management, action, and verification keywords\n    with a single setup method.\n    Supports Robot Framework as a library when Robot Framework is installed.\n    \"\"\"\n\n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        \"\"\"Initialize the Optics instance. Call setup() to configure.\"\"\"\n\n    @keyword(\"Setup\")\n    def setup(self, config: Union[str, Dict[str, Any], None] = None, ...):\n        \"\"\"Configure the framework with driver and element source settings.\"\"\"\n</code></pre>"},{"location":"architecture/library_layer/#initialization","title":"Initialization","text":"<p>The <code>Optics</code> class can be initialized with or without configuration:</p> <p>With Configuration: <pre><code>from optics_framework import Optics\n\nconfig = {\n    \"driver_sources\": [{\"appium\": {\"enabled\": True, \"url\": \"http://localhost:4723\"}}],\n    \"elements_sources\": [{\"appium_find_element\": {\"enabled\": True}}]\n}\n\noptics = Optics(config=config)\n</code></pre></p> <p>Without Configuration (setup later): <pre><code>from optics_framework import Optics\n\noptics = Optics()\noptics.setup(config=config)\n</code></pre></p>"},{"location":"architecture/library_layer/#usage-patterns","title":"Usage Patterns","text":""},{"location":"architecture/library_layer/#1-standalone-python-script","title":"1. Standalone Python Script","text":"<p>The library can be used in standalone Python scripts:</p> <pre><code>from optics_framework import Optics\n\n# Initialize and configure\noptics = Optics()\noptics.setup(\n    driver_sources=[{\"appium\": {\"enabled\": True, \"url\": \"http://localhost:4723\"}}],\n    elements_sources=[{\"appium_find_element\": {\"enabled\": True}}]\n)\n\n# Use keywords\noptics.launch_app(\"com.example.app\")\noptics.press_element(\"submit_button\")\noptics.enter_text(\"username_field\", \"testuser\")\noptics.validate_element(\"welcome_message\")\n\n# Cleanup\noptics.quit()\n</code></pre>"},{"location":"architecture/library_layer/#2-robot-framework-library","title":"2. Robot Framework Library","text":"<p>When Robot Framework is installed, the <code>Optics</code> class can be used as a Robot Framework library:</p> <pre><code>*** Settings ***\nLibrary    optics_framework.optics.Optics\n\n*** Test Cases ***\nExample Test\n    Setup    driver_sources=[{\"appium\": {\"enabled\": True, \"url\": \"http://localhost:4723\"}}]\n    Launch App    com.example.app\n    Press Element    submit_button\n    Enter Text    username_field    testuser\n    Validate Element    welcome_message\n    Quit\n</code></pre>"},{"location":"architecture/library_layer/#3-configuration-from-file","title":"3. Configuration from File","text":"<p>Configuration can be loaded from YAML or JSON files:</p> <pre><code>from optics_framework import Optics\n\n# From YAML file\noptics = Optics()\noptics.setup_from_file(\"config.yaml\")\n\n# Or inline YAML/JSON string\nyaml_config = \"\"\"\ndriver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\nelements_sources:\n  - appium_find_element:\n      enabled: true\n\"\"\"\noptics.setup(config=yaml_config)\n</code></pre>"},{"location":"architecture/library_layer/#component-access","title":"Component Access","text":"<p>The <code>Optics</code> class provides direct access to underlying components:</p>"},{"location":"architecture/library_layer/#action-keywords","title":"Action Keywords","text":"<pre><code>optics = Optics(config=config)\n\n# Element interactions\noptics.press_element(\"button_id\")\noptics.press_by_coordinates(100, 200)\noptics.press_by_percentage(50, 50)\n\n# Text input\noptics.enter_text(\"input_field\", \"text\")\noptics.enter_text_direct(\"input_field\", \"text\")\n\n# Gestures\noptics.swipe(100, 200, 300, 400)\noptics.scroll(100, 200, 300, 400)\n</code></pre>"},{"location":"architecture/library_layer/#app-management","title":"App Management","text":"<pre><code># App lifecycle\noptics.launch_app(\"com.example.app\")\noptics.launch_other_app(\"com.other.app\")\noptics.close_and_terminate_app()\noptics.force_terminate_app()\n\n# App information\nversion = optics.get_app_version()\nsession_id = optics.get_driver_session_id()\n</code></pre>"},{"location":"architecture/library_layer/#verification","title":"Verification","text":"<pre><code># Element validation\noptics.validate_element(\"element_id\")\noptics.assert_presence([\"element1\", \"element2\"], rule=\"all\")\n\n# Screen validation\noptics.validate_screen([\"element1\", \"element2\"])\n\n# Screenshots and page source\nscreenshot = optics.capture_screenshot()\npage_source = optics.capture_page_source()\n</code></pre>"},{"location":"architecture/library_layer/#flow-control","title":"Flow Control","text":"<pre><code># Conditional execution\noptics.condition(\"${variable} == 'value'\", \"keyword_name\")\n\n# Data operations\ndata = optics.read_data(\"data.csv\")\nresult = optics.invoke_api(\"GET\", \"https://api.example.com/data\")\n\n# Loops\noptics.run_loop(5, \"keyword_name\")\n\n# Evaluation\nvalue = optics.evaluate(\"${var1} + ${var2}\")\ndate = optics.date_evaluate(\"today + 1 day\")\n</code></pre>"},{"location":"architecture/library_layer/#session-management","title":"Session Management","text":""},{"location":"architecture/library_layer/#session-lifecycle","title":"Session Lifecycle","text":"<p>The library manages sessions internally:</p> <pre><code>optics = Optics()\n\n# Setup creates a session\noptics.setup(config=config)  # Session created automatically\n\n# All operations use the active session\noptics.press_element(\"button\")\n\n# Quit terminates the session\noptics.quit()  # Session terminated and cleaned up\n</code></pre>"},{"location":"architecture/library_layer/#multiple-sessions","title":"Multiple Sessions","text":"<p>For advanced use cases, you can manage multiple sessions:</p> <pre><code>from optics_framework import Optics\nfrom optics_framework.common.session_manager import SessionManager\n\n# Create multiple Optics instances for different sessions\noptics1 = Optics(config=config1)\noptics2 = Optics(config=config2)\n\n# Each instance has its own session\noptics1.launch_app(\"app1\")\noptics2.launch_app(\"app2\")\n</code></pre>"},{"location":"architecture/library_layer/#configuration","title":"Configuration","text":""},{"location":"architecture/library_layer/#configuration-formats","title":"Configuration Formats","text":"<p>The library supports multiple configuration formats:</p> <p>Dictionary: <pre><code>config = {\n    \"driver_sources\": [{\"appium\": {\"enabled\": True, \"url\": \"http://localhost:4723\"}}],\n    \"elements_sources\": [{\"appium_find_element\": {\"enabled\": True}}],\n    \"text_detection\": [{\"easyocr\": {\"enabled\": True}}],\n    \"image_detection\": [{\"templatematch\": {\"enabled\": True}}],\n    \"project_path\": \"/path/to/project\"\n}\noptics.setup(config=config)\n</code></pre></p> <p>YAML String: <pre><code>yaml_config = \"\"\"\ndriver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\n      capabilities:\n        platformName: \"Android\"\nelements_sources:\n  - appium_find_element:\n      enabled: true\n\"\"\"\noptics.setup(config=yaml_config)\n</code></pre></p> <p>JSON String: <pre><code>json_config = \"\"\"\n{\n  \"driver_sources\": [{\"appium\": {\"enabled\": true, \"url\": \"http://localhost:4723\"}}],\n  \"elements_sources\": [{\"appium_find_element\": {\"enabled\": true}}]\n}\n\"\"\"\noptics.setup(config=json_config)\n</code></pre></p> <p>File Path: <pre><code>optics.setup_from_file(\"config.yaml\")\n</code></pre></p>"},{"location":"architecture/library_layer/#configuration-parameters","title":"Configuration Parameters","text":"<p>Configuration can also be passed as individual parameters:</p> <pre><code>optics.setup(\n    driver_sources=[{\"appium\": {\"enabled\": True, \"url\": \"http://localhost:4723\"}}],\n    elements_sources=[{\"appium_find_element\": {\"enabled\": True}}],\n    text_detection=[{\"easyocr\": {\"enabled\": True}}],\n    image_detection=[{\"templatematch\": {\"enabled\": True}}],\n    execution_output_path_param=\"/path/to/output\"\n)\n</code></pre>"},{"location":"architecture/library_layer/#element-management","title":"Element Management","text":""},{"location":"architecture/library_layer/#adding-elements","title":"Adding Elements","text":"<p>Elements can be added and retrieved programmatically:</p> <pre><code># Add element\noptics.add_element(\"submit_button\", \"//button[@id='submit']\")\n\n# Get element value\nelement_value = optics.get_element_value(\"submit_button\")\n\n# Use element in keywords\noptics.press_element(\"submit_button\")  # Uses stored element\n</code></pre>"},{"location":"architecture/library_layer/#element-variables","title":"Element Variables","text":"<p>Elements can be referenced using <code>${variable}</code> syntax:</p> <pre><code>optics.add_element(\"button\", \"//button[@id='submit']\")\n\n# Resolve variable\noptics.press_element(\"${button}\")  # Resolves to stored element value\n</code></pre>"},{"location":"architecture/library_layer/#fallback-parameters","title":"Fallback Parameters","text":"<p>The library supports fallback parameters for resilience:</p> <pre><code># Single fallback value\noptics.press_element([\"button1\", \"button2\", \"button3\"])\n\n# Multiple fallback parameters\noptics.press_element(\n    element=[\"btn1\", \"btn2\"],\n    timeout=30\n)\n</code></pre> <p>The framework automatically tries each value until one succeeds.</p>"},{"location":"architecture/library_layer/#integration-with-core-framework","title":"Integration with Core Framework","text":""},{"location":"architecture/library_layer/#session-manager-integration","title":"Session Manager Integration","text":"<p>The library uses <code>SessionManager</code> internally:</p> <pre><code># Optics class creates and manages sessions\noptics = Optics()\noptics.setup(config)  # Creates session via SessionManager\n\n# Session is accessible\nsession_id = optics.session_id\nsession = optics.session_manager.get_session(session_id)\n</code></pre>"},{"location":"architecture/library_layer/#builder-integration","title":"Builder Integration","text":"<p>The library uses <code>OpticsBuilder</code> for component construction:</p> <pre><code># Builder is created during setup\noptics.setup(config)\n\n# Components are built via OpticsBuilder\n# Access to built components:\ndriver = optics.session_manager.get_session(optics.session_id).driver\n</code></pre>"},{"location":"architecture/library_layer/#api-class-integration","title":"API Class Integration","text":"<p>The library delegates to API classes:</p> <pre><code># Optics class wraps API classes\noptics.press_element(\"button\")\n# Internally calls: optics.action_keyword.press_element(\"button\")\n\noptics.validate_element(\"element\")\n# Internally calls: optics.verifier.validate_element(\"element\")\n</code></pre>"},{"location":"architecture/library_layer/#error-handling","title":"Error Handling","text":"<p>The library uses the framework's error handling system:</p> <pre><code>from optics_framework.common.error import OpticsError, Code\n\ntry:\n    optics.press_element(\"nonexistent_element\")\nexcept OpticsError as e:\n    print(f\"Error code: {e.code}\")\n    print(f\"Error message: {e.message}\")\n    print(f\"Error details: {e.details}\")\n</code></pre>"},{"location":"architecture/library_layer/#robot-framework-integration","title":"Robot Framework Integration","text":""},{"location":"architecture/library_layer/#library-registration","title":"Library Registration","text":"<p>When Robot Framework is installed, the <code>Optics</code> class is automatically registered as a library:</p> <pre><code>@library(scope=\"GLOBAL\")\nclass Optics:\n    # Class implementation\n</code></pre>"},{"location":"architecture/library_layer/#keyword-discovery","title":"Keyword Discovery","text":"<p>Robot Framework automatically discovers keywords decorated with <code>@keyword</code>:</p> <pre><code>@keyword(\"Press Element\")\ndef press_element(self, element: str, ...):\n    \"\"\"Press an element.\"\"\"\n    pass\n</code></pre>"},{"location":"architecture/library_layer/#scope-management","title":"Scope Management","text":"<p>The library uses <code>GLOBAL</code> scope, meaning a single instance is shared across all test cases:</p> <pre><code>*** Settings ***\nLibrary    optics_framework.optics.Optics\n\n*** Test Cases ***\nTest 1\n    Setup    config=config.yaml\n    Press Element    button1\n\nTest 2\n    # Uses same Optics instance from Test 1\n    Press Element    button2\n</code></pre>"},{"location":"architecture/library_layer/#best-practices","title":"Best Practices","text":""},{"location":"architecture/library_layer/#1-configuration-management","title":"1. Configuration Management","text":"<ul> <li>Use configuration files for complex setups</li> <li>Store sensitive data (URLs, credentials) in environment variables</li> <li>Use project-specific configuration files</li> </ul>"},{"location":"architecture/library_layer/#2-session-lifecycle","title":"2. Session Lifecycle","text":"<ul> <li>Always call <code>quit()</code> when done to clean up resources</li> <li>Use context managers for automatic cleanup:</li> </ul> <pre><code>from contextlib import contextmanager\n\n@contextmanager\ndef optics_session(config):\n    optics = Optics()\n    optics.setup(config=config)\n    try:\n        yield optics\n    finally:\n        optics.quit()\n\n# Usage\nwith optics_session(config) as optics:\n    optics.press_element(\"button\")\n</code></pre>"},{"location":"architecture/library_layer/#3-error-handling","title":"3. Error Handling","text":"<ul> <li>Always wrap operations in try/except blocks</li> <li>Handle <code>OpticsError</code> specifically for framework errors</li> <li>Check session state before operations</li> </ul>"},{"location":"architecture/library_layer/#4-element-management","title":"4. Element Management","text":"<ul> <li>Store frequently used elements</li> <li>Use descriptive element names</li> <li>Leverage fallback parameters for resilience</li> </ul>"},{"location":"architecture/library_layer/#5-code-organization","title":"5. Code Organization","text":"<ul> <li>Separate configuration from test logic</li> <li>Use helper functions for common operations</li> <li>Organize keywords into logical groups</li> </ul>"},{"location":"architecture/library_layer/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/library_layer/#1-session-reuse","title":"1. Session Reuse","text":"<ul> <li>Reuse <code>Optics</code> instances across multiple operations</li> <li>Avoid creating new instances for each operation</li> </ul>"},{"location":"architecture/library_layer/#2-lazy-initialization","title":"2. Lazy Initialization","text":"<ul> <li>Components are initialized on-demand</li> <li>First operation may be slower due to initialization</li> </ul>"},{"location":"architecture/library_layer/#3-resource-cleanup","title":"3. Resource Cleanup","text":"<ul> <li>Always call <code>quit()</code> to release resources</li> <li>Driver connections are closed on quit</li> </ul>"},{"location":"architecture/library_layer/#troubleshooting","title":"Troubleshooting","text":""},{"location":"architecture/library_layer/#setup-not-complete","title":"Setup Not Complete","text":"<p>Problem: <code>INVALID_SETUP</code> error when calling keywords.</p> <p>Solutions: 1. Ensure <code>setup()</code> is called before using keywords 2. Check configuration is valid 3. Verify at least one driver is enabled</p>"},{"location":"architecture/library_layer/#element-not-found","title":"Element Not Found","text":"<p>Problem: Element cannot be located.</p> <p>Solutions: 1. Verify element identifier is correct 2. Check element is visible on screen 3. Use fallback parameters for multiple strategies 4. Increase timeout if needed</p>"},{"location":"architecture/library_layer/#session-errors","title":"Session Errors","text":"<p>Problem: Session-related errors.</p> <p>Solutions: 1. Verify session was created successfully 2. Check session hasn't been terminated 3. Ensure <code>quit()</code> wasn't called prematurely</p>"},{"location":"architecture/library_layer/#robot-framework-integration-issues","title":"Robot Framework Integration Issues","text":"<p>Problem: Keywords not available in Robot Framework.</p> <p>Solutions: 1. Verify Robot Framework is installed 2. Check library import path is correct 3. Ensure <code>@keyword</code> decorators are present 4. Review Robot Framework logs</p>"},{"location":"architecture/library_layer/#related-documentation","title":"Related Documentation","text":"<ul> <li>Component Architecture - Optics class details</li> <li>Session Management - Session lifecycle</li> <li>Configuration - Configuration guide</li> <li>API Reference - Python API and keyword reference</li> <li>REST API Usage - REST API endpoints</li> <li>Strategies - Self-healing strategies</li> <li>Error Handling - Error codes and handling</li> </ul>"},{"location":"architecture/logging/","title":"Logging Architecture","text":"<p>The Optics Framework uses a sophisticated logging system that provides structured logging, multiple logger instances, and integration with execution tracking. This document explains the logging architecture, configuration, and usage patterns.</p>"},{"location":"architecture/logging/#overview","title":"Overview","text":"<p>The logging system consists of:</p> <ol> <li>Multiple Logger Instances - Separate loggers for different concerns</li> <li>Queue-Based Logging - Thread-safe logging using queues</li> <li>Rich Console Output - Beautiful formatted console output using Rich library</li> <li>File Logging - Rotating file handlers for persistent logs</li> <li>Sensitive Data Sanitization - Automatic sanitization of sensitive information</li> <li>Session Context - Session-scoped logging with context managers</li> <li>Log Capture - Capturing logs during keyword execution</li> </ol>"},{"location":"architecture/logging/#logger-architecture","title":"Logger Architecture","text":"<pre><code>graph TB\n    A[Application Code] --&gt; B[Logger Instance]\n    B --&gt; C{Logger Type}\n    C --&gt;|Internal| D[internal_logger]\n    C --&gt;|Execution| E[execution_logger]\n    D --&gt; F[Queue Handler]\n    E --&gt; G[Queue Handler]\n    F --&gt; H[Internal Queue]\n    G --&gt; I[Execution Queue]\n    H --&gt; J[Queue Listener]\n    I --&gt; K[Queue Listener]\n    J --&gt; L[Rich Console Handler]\n    K --&gt; M[Rich Console Handler]\n    J --&gt; N[File Handler]\n    K --&gt; O[File Handler]</code></pre>"},{"location":"architecture/logging/#logger-instances","title":"Logger Instances","text":""},{"location":"architecture/logging/#internal-logger","title":"Internal Logger","text":"<p>Name: <code>optics.internal</code> Purpose: Framework-internal operations, debugging, and development</p> <pre><code>from optics_framework.common.logging_config import internal_logger\n\ninternal_logger.debug(\"Debug message\")\ninternal_logger.info(\"Information message\")\ninternal_logger.warning(\"Warning message\")\ninternal_logger.error(\"Error message\")\n</code></pre> <p>Characteristics:</p> <ul> <li>Propagates to root logger: No (<code>propagate = False</code>)</li> <li>Rich tracebacks: Yes (shows full tracebacks with locals)</li> <li>Use cases: Framework debugging, component initialization, error details</li> </ul>"},{"location":"architecture/logging/#execution-logger","title":"Execution Logger","text":"<p>Name: <code>optics.execution</code> Purpose: Test execution events, keyword execution, and user-facing information</p> <pre><code>from optics_framework.common.logging_config import execution_logger\n\nexecution_logger.info(\"Test case started\")\nexecution_logger.info(\"Keyword executed successfully\")\nexecution_logger.warning(\"Element not found, trying fallback\")\n</code></pre> <p>Characteristics:</p> <ul> <li>Propagates to root logger: Yes (<code>propagate = True</code>)</li> <li>Rich tracebacks: No (cleaner output)</li> <li>Use cases: Test execution tracking, keyword results, execution tracer logs</li> </ul>"},{"location":"architecture/logging/#logging-configuration","title":"Logging Configuration","text":""},{"location":"architecture/logging/#configuration-structure","title":"Configuration Structure","text":"<p>Logging is configured through the main configuration system:</p> <pre><code># config.yaml\nlog_level: \"INFO\"  # DEBUG, INFO, WARNING, ERROR, CRITICAL\nfile_log: true\nlog_path: \"./logs/test_execution.log\"  # Optional\njson_log: false\njson_path: \"./logs/test_logs.json\"  # Optional\nexecution_output_path: \"./output\"\n</code></pre>"},{"location":"architecture/logging/#log-levels","title":"Log Levels","text":"<p>The framework supports standard Python log levels:</p> <ul> <li>DEBUG: Detailed information for troubleshooting</li> <li>INFO: General informational messages (default)</li> <li>WARNING: Warning messages</li> <li>ERROR: Error messages</li> <li>CRITICAL: Critical failures</li> </ul>"},{"location":"architecture/logging/#dynamic-reconfiguration","title":"Dynamic Reconfiguration","text":"<p>Logging can be reconfigured at runtime:</p> <pre><code>from optics_framework.common.logging_config import reconfigure_logging\nfrom optics_framework.common.config_handler import ConfigHandler\n\nconfig_handler = ConfigHandler(config)\nreconfigure_logging(config_handler.config)\n</code></pre> <p>When Reconfiguration Occurs:</p> <ul> <li>Session creation</li> <li>Configuration updates</li> <li>Runtime configuration changes</li> </ul>"},{"location":"architecture/logging/#log-handlers","title":"Log Handlers","text":""},{"location":"architecture/logging/#console-handlers","title":"Console Handlers","text":"<p>Both loggers use Rich handlers for beautiful console output:</p> <pre><code># Internal logger - Rich with tracebacks\ninternal_console_handler = RichHandler(\n    rich_tracebacks=True,\n    tracebacks_show_locals=True,\n    show_time=True,\n    show_level=True\n)\n\n# Execution logger - Clean Rich output\nexecution_console_handler = RichHandler(\n    rich_tracebacks=False,\n    show_time=True,\n    show_level=True,\n    markup=True\n)\n</code></pre>"},{"location":"architecture/logging/#file-handlers","title":"File Handlers","text":"<p>File handlers use rotating file handlers:</p> <pre><code>handler = RotatingFileHandler(\n    path,\n    maxBytes=10 * 1024 * 1024,  # 10MB\n    backupCount=10  # Keep 10 backup files\n)\n</code></pre> <p>File Handler Features:</p> <ul> <li>Automatic rotation at 10MB</li> <li>Keeps 10 backup files</li> <li>Separate files for internal and execution logs</li> <li>Configurable log paths</li> </ul>"},{"location":"architecture/logging/#queue-handlers","title":"Queue Handlers","text":"<p>Logging uses queue-based handlers for thread safety:</p> <pre><code>execution_queue_handler = QueueHandler(self.execution_log_queue)\nself.execution_logger.addHandler(self.execution_queue_handler)\n</code></pre> <p>Benefits:</p> <ul> <li>Thread-safe logging</li> <li>Non-blocking log writes</li> <li>Background processing</li> <li>Better performance</li> </ul>"},{"location":"architecture/logging/#sensitive-data-sanitization","title":"Sensitive Data Sanitization","text":"<p>The framework automatically sanitizes sensitive data in log messages:</p> <pre><code>class SensitiveDataFormatter(logging.Formatter):\n    def _sanitize(self, message: str) -&gt; str:\n        # Removes patterns like @:password, @:api_key\n        return re.sub(r\"@:([^\\s,\\)\\]]+)\", \"****\", message)\n</code></pre> <p>Sanitization Pattern:</p> <ul> <li>Matches: <code>@:password</code>, <code>@:api_key</code>, <code>@:token</code></li> <li>Replaces with: <code>****</code></li> <li>Prevents accidental credential exposure</li> </ul> <p>Usage: <pre><code># This will be sanitized\ninternal_logger.info(\"Connecting with @:api_key\")\n# Output: \"Connecting with ****\"\n</code></pre></p>"},{"location":"architecture/logging/#session-context-logging","title":"Session Context Logging","text":"<p>The framework provides session-scoped logging:</p> <pre><code>from optics_framework.common.logging_config import LoggerContext\n\nwith LoggerContext(session_id) as (session_execution_logger, session_internal_logger):\n    session_execution_logger.info(\"Session-specific log message\")\n    # Logs include session_id automatically\n</code></pre> <p>SessionLoggerAdapter:</p> <ul> <li>Automatically adds session_id to log records</li> <li>Provides session-scoped logging</li> <li>Used during test execution</li> </ul>"},{"location":"architecture/logging/#log-capture","title":"Log Capture","text":"<p>During keyword execution, logs are captured:</p> <pre><code>from optics_framework.common.logging_config import LogCaptureBuffer\n\nclass LogCaptureBuffer(logging.Handler):\n    def __init__(self):\n        super().__init__()\n        self.records = []\n\n    def emit(self, record):\n        self.records.append(record)\n</code></pre> <p>Usage in Test Runner: <pre><code>capture_handler = LogCaptureBuffer()\nexecution_logger.addHandler(capture_handler)\n\n# Execute keyword\nexecute_keyword(...)\n\n# Get captured logs\nlogs = capture_handler.get_records()\n</code></pre></p> <p>Use Cases:</p> <ul> <li>Capturing logs during keyword execution</li> <li>Including logs in test results</li> <li>Debugging keyword failures</li> <li>Event logging</li> </ul>"},{"location":"architecture/logging/#integration-with-execution-tracer","title":"Integration with Execution Tracer","text":"<p>The execution tracer uses the execution logger:</p> <pre><code>from optics_framework.common.logging_config import execution_logger\nfrom optics_framework.common.execution_tracer import execution_tracer\n\n# Execution tracer automatically logs to execution_logger\nexecution_tracer.log_attempt(\n    strategy=XPathStrategy,\n    element=\"submit_button\",\n    status=\"success\",\n    duration=0.15\n)\n# Logs: \"Trying XPathStrategy on 'submit_button' ... SUCCESS, duration: 0.15s\"\n</code></pre>"},{"location":"architecture/logging/#log-format","title":"Log Format","text":""},{"location":"architecture/logging/#console-format","title":"Console Format","text":"<p>Internal Logger: <pre><code>12:34:56 INFO     Debug message\n</code></pre></p> <p>Execution Logger: <pre><code>12:34:56 INFO     Test case started\n</code></pre></p>"},{"location":"architecture/logging/#file-format","title":"File Format","text":"<pre><code>INFO | 2024-01-01 12:34:56 | optics.internal:function_name:123 | Log message\n</code></pre> <p>Format Components: - Level name - Timestamp - Logger name:function:line - Message</p>"},{"location":"architecture/logging/#logging-manager","title":"Logging Manager","text":"<p>The <code>LoggingManager</code> class manages all logging infrastructure:</p> <pre><code>class LoggingManager:\n    def __init__(self):\n        # Initialize loggers\n        # Set up handlers\n        # Configure queues\n\n    def initialize_handlers(self, config):\n        # Configure handlers based on config\n        # Add file handlers if enabled\n        # Set log levels\n\n    def shutdown_logging(self):\n        # Clean shutdown\n        # Stop listeners\n        # Flush handlers\n</code></pre>"},{"location":"architecture/logging/#shutdown-and-cleanup","title":"Shutdown and Cleanup","text":"<p>The framework provides graceful logging shutdown:</p> <pre><code>from optics_framework.common.logging_config import shutdown_logging\n\n# Automatically called on exit\natexit.register(shutdown_logging)\n</code></pre> <p>Shutdown Process:</p> <ol> <li>Disable root logger</li> <li>Stop queue listeners</li> <li>Wait for threads to terminate</li> <li>Flush all handlers</li> <li>Clear log queues</li> </ol>"},{"location":"architecture/logging/#best-practices","title":"Best Practices","text":""},{"location":"architecture/logging/#1-use-appropriate-logger","title":"1. Use Appropriate Logger","text":"<pre><code># Framework debugging\ninternal_logger.debug(\"Component initialized\")\n\n# Test execution events\nexecution_logger.info(\"Keyword executed\")\n</code></pre>"},{"location":"architecture/logging/#2-log-levels","title":"2. Log Levels","text":"<pre><code># Debug: Detailed troubleshooting\ninternal_logger.debug(\"Element coordinates: (100, 200)\")\n\n# Info: General information\nexecution_logger.info(\"Test case completed\")\n\n# Warning: Non-critical issues\nexecution_logger.warning(\"Element not found, using fallback\")\n\n# Error: Errors that don't stop execution\nexecution_logger.error(\"Driver connection failed\")\n\n# Critical: Critical failures\ninternal_logger.critical(\"System error, shutting down\")\n</code></pre>"},{"location":"architecture/logging/#3-sensitive-data","title":"3. Sensitive Data","text":"<pre><code># Good - sanitized\ninternal_logger.info(\"API key: @:api_key\")\n\n# Bad - exposed\ninternal_logger.info(f\"API key: {api_key}\")\n</code></pre>"},{"location":"architecture/logging/#4-context-information","title":"4. Context Information","text":"<pre><code># Include context in messages\nexecution_logger.info(f\"Element '{element_id}' located at ({x}, {y})\")\n</code></pre>"},{"location":"architecture/logging/#5-exception-logging","title":"5. Exception Logging","text":"<pre><code>try:\n    operation()\nexcept Exception as e:\n    internal_logger.exception(\"Operation failed\", exc_info=e)\n    # Logs full traceback\n</code></pre>"},{"location":"architecture/logging/#configuration-examples","title":"Configuration Examples","text":""},{"location":"architecture/logging/#development-configuration","title":"Development Configuration","text":"<pre><code>log_level: \"DEBUG\"\nfile_log: true\nlog_path: \"./logs/dev.log\"\n</code></pre>"},{"location":"architecture/logging/#production-configuration","title":"Production Configuration","text":"<pre><code>log_level: \"INFO\"\nfile_log: true\nlog_path: \"./logs/production.log\"\njson_log: true\njson_path: \"./logs/production.json\"\n</code></pre>"},{"location":"architecture/logging/#minimal-configuration","title":"Minimal Configuration","text":"<pre><code>log_level: \"INFO\"\n# Uses defaults for everything else\n</code></pre>"},{"location":"architecture/logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"architecture/logging/#logs-not-appearing","title":"Logs Not Appearing","text":"<p>Problem: Logs not showing in console or files</p> <p>Solutions:</p> <ol> <li>Check log level configuration</li> <li>Verify handlers are initialized</li> <li>Check file permissions for file logging</li> <li>Review configuration loading</li> </ol>"},{"location":"architecture/logging/#too-many-logs","title":"Too Many Logs","text":"<p>Problem: Excessive log output</p> <p>Solutions:</p> <ol> <li>Increase log level (INFO \u2192 WARNING)</li> <li>Disable file logging if not needed</li> <li>Review debug statements</li> </ol>"},{"location":"architecture/logging/#missing-logs","title":"Missing Logs","text":"<p>Problem: Some logs missing</p> <p>Solutions:</p> <ol> <li>Check logger propagation settings</li> <li>Verify handlers are attached</li> <li>Review log level filters</li> <li>Check queue listener status</li> </ol>"},{"location":"architecture/logging/#performance-issues","title":"Performance Issues","text":"<p>Problem: Logging causing performance problems</p> <p>Solutions:</p> <ol> <li>Reduce log level</li> <li>Disable file logging</li> <li>Review log message frequency</li> <li>Check queue sizes</li> </ol>"},{"location":"architecture/logging/#related-documentation","title":"Related Documentation","text":"<ul> <li>Execution Architecture - Execution tracer integration</li> <li>Execution Tracer - Strategy attempt logging</li> <li>Error Handling - Error logging patterns</li> <li>Configuration - Logging configuration options</li> <li>Components - Component logging usage</li> <li>Architecture Decisions - Logging system design decisions</li> </ul>"},{"location":"architecture/strategies/","title":"Strategy Pattern and Self-Healing","text":"<p>The Optics Framework uses the Strategy pattern extensively to provide self-healing test automation. This document explains how strategies work, how they're selected, and how the fallback mechanism ensures test resilience.</p>"},{"location":"architecture/strategies/#overview","title":"Overview","text":"<p>The strategy pattern allows the framework to try multiple methods for locating elements, with automatic fallback when one method fails. This creates a self-healing system that adapts to UI changes and different application states.</p>"},{"location":"architecture/strategies/#strategy-architecture","title":"Strategy Architecture","text":"<pre><code>graph TB\n    A[ActionKeyword] --&gt; B[StrategyManager]\n    B --&gt; C[StrategyFactory]\n    C --&gt; D[XPathStrategy]\n    C --&gt; E[TextElementStrategy]\n    C --&gt; F[TextDetectionStrategy]\n    C --&gt; G[ImageDetectionStrategy]\n    D --&gt; H[ElementSource]\n    E --&gt; H\n    F --&gt; I[TextDetection]\n    F --&gt; H\n    G --&gt; J[ImageDetection]\n    G --&gt; H\n    B --&gt; K[Fallback Chain]\n    K --&gt; L[Try Next Strategy]</code></pre>"},{"location":"architecture/strategies/#strategymanager","title":"StrategyManager","text":"<p>Location: <code>optics_framework/common/strategies.py</code></p> <p>The <code>StrategyManager</code> orchestrates multiple location strategies and manages fallback chains.</p>"},{"location":"architecture/strategies/#key-responsibilities","title":"Key Responsibilities","text":"<ul> <li>Strategy creation and management</li> <li>Strategy execution with fallback</li> <li>Screenshot and page source strategy management</li> <li>Element location coordination</li> </ul>"},{"location":"architecture/strategies/#initialization","title":"Initialization","text":"<pre><code>strategy_manager = StrategyManager(\n    element_source=element_source_fallback,\n    text_detection=text_detection_fallback,\n    image_detection=image_detection_fallback\n)\n</code></pre>"},{"location":"architecture/strategies/#strategy-building","title":"Strategy Building","text":"<p>The manager builds three types of strategies:</p> <ol> <li>Locator Strategies: For element location</li> <li>Screenshot Strategies: For screen capture</li> <li>Page Source Strategies: For page source extraction</li> </ol>"},{"location":"architecture/strategies/#locator-strategies","title":"Locator Strategies","text":""},{"location":"architecture/strategies/#xpathstrategy","title":"XPathStrategy","text":"<p>Priority: 1 (Highest)</p> <p>Locates elements using XPath expressions through the element source.</p>"},{"location":"architecture/strategies/#when-used","title":"When Used","text":"<ul> <li>Element type is \"XPath\"</li> <li>Element source supports <code>locate()</code> method</li> <li>Fastest method when available</li> </ul>"},{"location":"architecture/strategies/#implementation","title":"Implementation","text":"<pre><code>def locate(self, element: str, index: int = 0):\n    return self.element_source.locate(element, index)\n</code></pre>"},{"location":"architecture/strategies/#examples","title":"Examples","text":"<p>Basic XPath: <pre><code># Element: \"//button[@id='submit']\"\n# Strategy: XPathStrategy\n# Process: Direct element location via XPath\n# Result: Element object or coordinates\npress_element(\"//button[@id='submit']\")\n</code></pre></p> <p>XPath with Attributes: <pre><code># Complex XPath with multiple attributes\npress_element(\"//android.widget.Button[@resource-id='com.app:id/button' and @text='Submit']\")\n</code></pre></p> <p>XPath with Index: <pre><code># Get second matching element\npress_element(\"//button[@class='action']\", index=1)\n</code></pre></p> <p>XPath Performance: - Fastest strategy (typically &lt; 0.1s) - Direct DOM access - No screenshot required - No vision processing</p>"},{"location":"architecture/strategies/#textelementstrategy","title":"TextElementStrategy","text":"<p>Priority: 2</p> <p>Locates elements by text content directly through the element source.</p>"},{"location":"architecture/strategies/#when-used_1","title":"When Used","text":"<ul> <li>Element type is \"Text\" or \"CSS\"</li> <li>Element source supports direct text location</li> <li>Faster than OCR-based detection</li> </ul>"},{"location":"architecture/strategies/#implementation_1","title":"Implementation","text":"<pre><code>def locate(self, element: str, index: int = 0):\n    return self.element_source.locate(element, index)\n</code></pre>"},{"location":"architecture/strategies/#examples_1","title":"Examples","text":"<p>Text-Based Location: <pre><code># Element: \"Submit Button\"\n# Strategy: TextElementStrategy\n# Process: Direct text-based element location\n# Result: Element object\npress_element(\"Submit Button\")\n</code></pre></p> <p>CSS Selector: <pre><code># CSS selector (if supported by driver)\npress_element(\"button.submit-btn\")\n</code></pre></p> <p>ID-Based: <pre><code># Element ID\npress_element(\"submit-button-id\")\n</code></pre></p> <p>Performance: - Fast strategy (typically &lt; 0.2s) - Direct element access - No screenshot required - Driver-specific implementation</p>"},{"location":"architecture/strategies/#textdetectionstrategy","title":"TextDetectionStrategy","text":"<p>Priority: 3</p> <p>Locates text elements using OCR (Optical Character Recognition).</p>"},{"location":"architecture/strategies/#when-used_2","title":"When Used","text":"<ul> <li>Element type is \"Text\"</li> <li>XPath and direct text location failed</li> <li>OCR model is available</li> <li>Element source supports screenshot capture</li> </ul>"},{"location":"architecture/strategies/#implementation-flow","title":"Implementation Flow","text":"<pre><code>sequenceDiagram\n    participant TS as TextDetectionStrategy\n    participant ES as ElementSource\n    participant OCR as TextDetection\n    participant SM as StrategyManager\n\n    TS-&gt;&gt;ES: capture()\n    ES--&gt;&gt;TS: screenshot\n    TS-&gt;&gt;OCR: detect_text(screenshot)\n    OCR--&gt;&gt;TS: text locations\n    TS-&gt;&gt;TS: find matching text\n    TS--&gt;&gt;SM: coordinates</code></pre>"},{"location":"architecture/strategies/#features","title":"Features","text":"<ul> <li>Screenshot-based detection</li> <li>Full text detection with bounding boxes</li> <li>Confidence-based matching</li> <li>Timeout support for element appearance</li> </ul>"},{"location":"architecture/strategies/#examples_2","title":"Examples","text":"<p>Basic Text Detection: <pre><code># Element: \"Login\"\n# Strategy: TextDetectionStrategy\n# Process:\n#   1. Capture screenshot\n#   2. Run OCR on screenshot\n#   3. Find \"Login\" text in OCR results\n#   4. Return center coordinates\npress_element(\"Login\")\n</code></pre></p> <p>Text with Index: <pre><code># Get second occurrence of \"Submit\"\npress_element(\"Submit\", index=1)\n</code></pre></p> <p>Text in Specific Language: <pre><code># Configure OCR for specific language\n# In config.yaml:\ntext_detection:\n  - easyocr:\n      enabled: true\n      capabilities:\n        languages: [\"en\", \"es\"]  # English and Spanish\n\n# Use in test\npress_element(\"Iniciar Sesi\u00f3n\")  # Spanish text\n</code></pre></p> <p>Performance: - Slower strategy (typically 1-3s) - Requires screenshot capture - OCR processing time - Accuracy depends on image quality</p>"},{"location":"architecture/strategies/#imagedetectionstrategy","title":"ImageDetectionStrategy","text":"<p>Priority: 4 (Lowest)</p> <p>Locates elements using image template matching.</p>"},{"location":"architecture/strategies/#when-used_3","title":"When Used","text":"<ul> <li>Element type is \"Image\"</li> <li>Other strategies failed</li> <li>Image detection model is available</li> <li>Element source supports screenshot capture</li> </ul>"},{"location":"architecture/strategies/#implementation-flow_1","title":"Implementation Flow","text":"<pre><code>sequenceDiagram\n    participant IDS as ImageDetectionStrategy\n    participant ES as ElementSource\n    participant IM as ImageDetection\n    participant SM as StrategyManager\n\n    IDS-&gt;&gt;ES: capture()\n    ES--&gt;&gt;IDS: screenshot\n    IDS-&gt;&gt;IM: find_element(screenshot, template)\n    IM--&gt;&gt;IDS: coordinates\n    IDS--&gt;&gt;SM: coordinates</code></pre>"},{"location":"architecture/strategies/#features_1","title":"Features","text":"<ul> <li>Template-based matching</li> <li>SIFT/FLANN feature matching</li> <li>Area of Interest (AOI) support</li> <li>Multiple match support (index-based)</li> </ul>"},{"location":"architecture/strategies/#aoi-support","title":"AOI Support","text":"<p>The strategy supports locating images within a specified Area of Interest (AOI). AOI allows you to restrict element location to a specific region of the screen, improving performance and accuracy.</p> <p>What is AOI? Area of Interest (AOI) is a percentage-based region of the screen where element location is performed. Instead of searching the entire screen, the framework crops the screenshot to the AOI region, performs location within that region, then adjusts coordinates back to the full screen.</p> <p>Why Use AOI? - Performance: Smaller search area = faster location - Accuracy: Reduces false positives from similar elements elsewhere - Efficiency: Focuses vision models on relevant screen area - Flexibility: Works with any screen size (percentage-based)</p> <p>AOI Parameters: - <code>aoi_x</code>: X percentage of AOI top-left corner (0-100) - <code>aoi_y</code>: Y percentage of AOI top-left corner (0-100) - <code>aoi_width</code>: Width percentage of AOI (0-100) - <code>aoi_height</code>: Height percentage of AOI (0-100)</p> <p>Example: <pre><code># Locate element in top-right quarter of screen\npress_element(\n    \"submit_button\",\n    aoi_x=\"50\",      # Start at 50% from left\n    aoi_y=\"0\",       # Start at top\n    aoi_width=\"50\",  # 50% width\n    aoi_height=\"50\"  # 50% height\n)\n</code></pre></p> <p>AOI Implementation Flow:</p> <pre><code>sequenceDiagram\n    participant Action\n    participant Strategy\n    participant Utils\n    participant Vision\n\n    Action-&gt;&gt;Strategy: locate_with_aoi(element, aoi_x, aoi_y, aoi_width, aoi_height)\n    Strategy-&gt;&gt;Strategy: Capture full screenshot\n    Strategy-&gt;&gt;Utils: crop_screenshot_to_aoi(screenshot, aoi_x, aoi_y, aoi_width, aoi_height)\n    Utils-&gt;&gt;Utils: Calculate pixel bounds from percentages\n    Utils-&gt;&gt;Utils: Crop screenshot to bounds\n    Utils--&gt;&gt;Strategy: cropped_screenshot, aoi_bounds\n    Strategy-&gt;&gt;Vision: find_element(cropped_screenshot, template)\n    Vision--&gt;&gt;Strategy: coordinates (relative to cropped)\n    Strategy-&gt;&gt;Utils: adjust_coordinates_for_aoi(coordinates, aoi_bounds)\n    Utils--&gt;&gt;Strategy: coordinates (relative to full screenshot)\n    Strategy--&gt;&gt;Action: Final coordinates</code></pre> <p>Coordinate Adjustment: <pre><code>def adjust_coordinates_for_aoi(coordinates, aoi_bounds):\n    \"\"\"\n    Adjust coordinates found in cropped AOI back to full screenshot.\n\n    Args:\n        coordinates: (x, y) found in cropped screenshot\n        aoi_bounds: (x1, y1, x2, y2) pixel bounds of AOI\n\n    Returns:\n        (adjusted_x, adjusted_y) in full screenshot coordinates\n    \"\"\"\n    x, y = coordinates\n    x1, y1, x2, y2 = aoi_bounds\n    adjusted_x = x1 + x\n    adjusted_y = y1 + y\n    return (adjusted_x, adjusted_y)\n</code></pre></p> <p>AOI Validation: <pre><code>def calculate_aoi_bounds(screenshot_shape, aoi_x, aoi_y, aoi_width, aoi_height):\n    \"\"\"\n    Calculate pixel bounds for AOI from percentage coordinates.\n\n    Validates:\n    - All parameters between 0-100\n    - AOI doesn't exceed screen bounds\n    - Width and height &gt; 0\n    \"\"\"\n    # Validation logic\n    # Calculate pixel bounds\n    return (x1, y1, x2, y2)\n</code></pre></p> <p>AOI Annotation: When AOI is used, screenshots are annotated with the AOI region for debugging:</p> <pre><code>def annotate_aoi_region(screenshot, aoi_x, aoi_y, aoi_width, aoi_height):\n    \"\"\"\n    Draw rectangle on screenshot showing AOI region.\n\n    - Red rectangle shows AOI bounds\n    - Label shows AOI parameters\n    - Saved to execution output directory\n    \"\"\"\n</code></pre> <p>Supported Strategies: - <code>ImageDetectionStrategy</code>: Supports <code>locate_with_aoi()</code> - <code>TextDetectionStrategy</code>: Supports <code>locate_with_aoi()</code> - <code>XPathStrategy</code>: AOI not applicable (uses DOM structure) - <code>TextElementStrategy</code>: AOI not applicable (uses DOM structure)</p> <p>Use Cases: 1. Button in Specific Region: Locate button only in bottom navigation 2. Form Fields: Search only in form area, not entire screen 3. Modal Dialogs: Focus search on dialog region 4. Performance Optimization: Reduce search area for faster location</p>"},{"location":"architecture/strategies/#examples_3","title":"Examples","text":"<p>Basic Image Matching: <pre><code># Element: \"button_template.png\"\n# Strategy: ImageDetectionStrategy\n# Process:\n#   1. Capture screenshot\n#   2. Load template image from project_path/input_templates/\n#   3. Match template in screenshot using SIFT/FLANN\n#   4. Return center coordinates\npress_element(\"button_template.png\")\n</code></pre></p> <p>Image with Index: <pre><code># Get second occurrence of template\npress_element(\"icon_template.png\", index=1)\n</code></pre></p> <p>Image with AOI: <pre><code># Search for image only in top-right quarter\npress_element(\n    \"button_template.png\",\n    aoi_x=\"50\",      # Start at 50% from left\n    aoi_y=\"0\",       # Start at top\n    aoi_width=\"50\",  # 50% width\n    aoi_height=\"50\"  # 50% height\n)\n</code></pre></p> <p>Template Organization: <pre><code>project/\n\u2514\u2500\u2500 test_data/\n    \u2514\u2500\u2500 input_templates/\n        \u251c\u2500\u2500 button_template.png\n        \u251c\u2500\u2500 login_form.png\n        \u2514\u2500\u2500 submit_button.png\n</code></pre></p> <p>Performance: - Slowest strategy (typically 2-5s) - Requires screenshot capture - SIFT feature detection - FLANN matching computation - Performance improves with AOI</p>"},{"location":"architecture/strategies/#strategy-selection","title":"Strategy Selection","text":""},{"location":"architecture/strategies/#automatic-selection","title":"Automatic Selection","text":"<p>Strategies are automatically selected based on:</p> <ol> <li>Element Type: Determined from element identifier</li> <li>XPath: <code>//button[@id='submit']</code></li> <li>Text: <code>\"Submit Button\"</code></li> <li> <p>Image: <code>button_template.png</code></p> </li> <li> <p>Element Source Capabilities: Checked via <code>supports()</code> method</p> </li> <li>Does element source implement required methods?</li> <li> <p>Is the method actually implemented (not a stub)?</p> </li> <li> <p>Priority Ordering: Strategies tried in priority order</p> </li> <li>Higher priority = tried first</li> <li>Lower priority = fallback option</li> </ol>"},{"location":"architecture/strategies/#strategy-factory","title":"Strategy Factory","text":"<p>Location: <code>optics_framework/common/strategies.py</code></p> <p>The <code>StrategyFactory</code> creates strategies based on element source capabilities.</p> <pre><code>class StrategyFactory:\n    def __init__(self, text_detection, image_detection, strategy_manager):\n        self._registry = [\n            (XPathStrategy, \"XPath\", {}, 1),\n            (TextElementStrategy, \"Text\", {}, 2),\n            (TextDetectionStrategy, \"Text\", {...}, 3),\n            (ImageDetectionStrategy, \"Image\", {...}, 4),\n        ]\n</code></pre>"},{"location":"architecture/strategies/#strategy-creation","title":"Strategy Creation","text":"<pre><code>def create_strategies(self, element_source):\n    strategies = [\n        (cls(element_source, **args), priority)\n        for cls, etype, args, priority in self._registry\n        if cls.supports(etype, element_source)\n    ]\n    strategies.sort(key=lambda x: x[1])  # Sort by priority\n    return [strategy for strategy, _ in strategies]\n</code></pre>"},{"location":"architecture/strategies/#fallback-mechanism","title":"Fallback Mechanism","text":""},{"location":"architecture/strategies/#multi-level-fallback","title":"Multi-Level Fallback","text":"<p>The framework implements fallback at multiple levels:</p> <pre><code>graph TB\n    A[Action Request] --&gt; B[StrategyManager]\n    B --&gt; C{Try Strategy 1}\n    C --&gt;|Success| D[Return Result]\n    C --&gt;|Fail| E{Try Strategy 2}\n    E --&gt;|Success| D\n    E --&gt;|Fail| F{Try Strategy 3}\n    F --&gt;|Success| D\n    F --&gt;|Fail| G{Try Strategy 4}\n    G --&gt;|Success| D\n    G --&gt;|Fail| H[All Strategies Failed]</code></pre>"},{"location":"architecture/strategies/#strategy-fallback-flow","title":"Strategy Fallback Flow","text":"<pre><code>def locate(self, element: str, index: int = 0):\n    results = []\n    for strategy in self.locator_strategies:\n        try:\n            result = strategy.locate(element, index)\n            if result is not None:\n                results.append(LocateResult(result, strategy))\n        except Exception as e:\n            internal_logger.debug(f\"Strategy {strategy} failed: {e}\")\n            continue\n\n    # Yield results from all successful strategies\n    for result in results:\n        yield result\n</code></pre>"},{"location":"architecture/strategies/#element-source-fallback","title":"Element Source Fallback","text":"<p>If multiple element sources are configured, they're tried in order:</p> <pre><code># If AppiumScreenshot fails, try SeleniumScreenshot\nelement_source_fallback.capture()\n</code></pre>"},{"location":"architecture/strategies/#vision-model-fallback","title":"Vision Model Fallback","text":"<p>If multiple vision models are configured, they're tried in order:</p> <pre><code># If EasyOCR fails, try GoogleVision\ntext_detection_fallback.detect_text(screenshot)\n</code></pre>"},{"location":"architecture/strategies/#self-healing-decorator","title":"Self-Healing Decorator","text":"<p>Location: <code>optics_framework/api/action_keyword.py</code></p> <p>The <code>@with_self_healing</code> decorator wraps action methods to provide automatic fallback and self-healing capabilities. It orchestrates element location, handles multiple results, and provides comprehensive error handling.</p>"},{"location":"architecture/strategies/#decorator-flow","title":"Decorator Flow","text":"<pre><code>sequenceDiagram\n    participant Action as Action Method\n    participant Decorator as @with_self_healing\n    participant SM as StrategyManager\n    participant Strategy as Strategy\n    participant Driver as Driver\n    participant Utils as Utils\n\n    Action-&gt;&gt;Decorator: press_element(element, aoi_x, aoi_y, ...)\n    Decorator-&gt;&gt;SM: capture_screenshot()\n    SM--&gt;&gt;Decorator: screenshot\n    Decorator-&gt;&gt;Utils: save_screenshot() or annotate_aoi_region()\n    Utils--&gt;&gt;Decorator: saved\n    Decorator-&gt;&gt;SM: locate(element, aoi_x, aoi_y, ...)\n    SM-&gt;&gt;Strategy: try strategies\n    Strategy--&gt;&gt;SM: LocateResult\n    SM--&gt;&gt;Decorator: results (generator)\n    loop For each result\n        Decorator-&gt;&gt;Action: func(element, located=result.value, ...)\n        alt Success\n            Action--&gt;&gt;Decorator: success\n            Decorator--&gt;&gt;Action: return result\n        else Failure\n            Action--&gt;&gt;Decorator: exception\n            Decorator-&gt;&gt;Decorator: log error, try next\n        end\n    end\n    alt All failed\n        Decorator--&gt;&gt;Action: raise OpticsError\n    end</code></pre>"},{"location":"architecture/strategies/#implementation-details","title":"Implementation Details","text":"<p>Decorator Signature: <pre><code>def with_self_healing(func: Callable) -&gt; Callable:\n    @wraps(func)\n    def wrapper(self, element, *args, **kwargs):\n        # Implementation\n    return wrapper\n</code></pre></p> <p>Step-by-Step Process:</p> <p>1. Screenshot Capture: <pre><code># Capture screenshot before location\nscreenshot_np = self.strategy_manager.capture_screenshot()\n</code></pre></p> <p>2. AOI Parameter Extraction: <pre><code># Extract and parse AOI parameters\naoi_x = parse_aoi_param(kwargs.pop('aoi_x', '0'), 0)\naoi_y = parse_aoi_param(kwargs.pop('aoi_y', '0'), 0)\naoi_width = parse_aoi_param(kwargs.pop('aoi_width', '100'), 100)\naoi_height = parse_aoi_param(kwargs.pop('aoi_height', '100'), 100)\n\n# Check if AOI is being used\nis_aoi_used = not (aoi_x == 0 and aoi_y == 0 and aoi_width == 100 and aoi_height == 100)\n</code></pre></p> <p>3. Screenshot Saving: <pre><code># Save screenshot with AOI annotation if AOI is used\nif is_aoi_used:\n    annotated_screenshot = utils.annotate_aoi_region(\n        screenshot_np, aoi_x, aoi_y, aoi_width, aoi_height\n    )\n    utils.save_screenshot(\n        annotated_screenshot,\n        f\"{func.__name__}_with_aoi\",\n        output_dir=self.execution_dir\n    )\nelse:\n    utils.save_screenshot(\n        screenshot_np,\n        func.__name__,\n        output_dir=self.execution_dir\n    )\n</code></pre></p> <p>4. Element Location: <pre><code># Locate element with or without AOI\nif is_aoi_used:\n    results = self.strategy_manager.locate(\n        element, aoi_x, aoi_y, aoi_width, aoi_height, index=index\n    )\nelse:\n    results = self.strategy_manager.locate(element, index=index)\n</code></pre></p> <p>5. Result Iteration: <pre><code>last_exception = None\nresult_count = 0\n\nfor result in results:\n    result_count += 1\n    try:\n        # Try executing action with this result\n        return func(self, element, located=result.value, *args, **kwargs)\n    except Exception as e:\n        # Log error and try next result\n        internal_logger.error(\n            f\"Action '{func.__name__}' failed with \"\n            f\"{result.strategy.__class__.__name__}: {e}\"\n        )\n        last_exception = e\n        continue  # Try next result\n</code></pre></p> <p>6. Error Handling: <pre><code># Handle different failure scenarios\nif result_count == 0:\n    # No strategies yielded a result\n    raise OpticsError(\n        Code.E0201,\n        message=f\"No valid strategies found for '{element}' in '{func.__name__}'\"\n    )\n\nif last_exception:\n    # All strategies failed\n    raise OpticsError(\n        Code.X0201,\n        message=f\"All strategies failed for '{element}' in '{func.__name__}': {last_exception}\",\n        cause=last_exception\n    )\n\n# Unexpected case\nraise OpticsError(\n    Code.E0801,\n    message=f\"Unexpected failure: No results or exceptions for '{element}' in '{func.__name__}'\"\n)\n</code></pre></p>"},{"location":"architecture/strategies/#key-features","title":"Key Features","text":"<p>1. Automatic Screenshot Capture: - Captures screenshot before element location - Saves screenshot for debugging - Annotates AOI region if used</p> <p>2. Strategy-Based Location: - Uses StrategyManager to locate element - Supports multiple location strategies - Handles AOI parameters automatically</p> <p>3. Multiple Result Handling: - Iterates through all successful strategy results - Tries each result until one succeeds - Continues on failure (self-healing)</p> <p>4. Error Aggregation: - Logs each failure with strategy information - Preserves last exception for error message - Provides detailed error context</p> <p>5. Screenshot Saving: - Saves screenshots to execution output directory - Annotates AOI regions for debugging - Uses function name for screenshot filename</p> <p>6. AOI Integration: - Extracts AOI parameters from kwargs - Passes AOI to strategy manager - Annotates screenshots with AOI region</p>"},{"location":"architecture/strategies/#usage-example","title":"Usage Example","text":"<p>Basic Usage: <pre><code>@with_self_healing\ndef press_element(\n    self,\n    element: str,\n    repeat: str = \"1\",\n    offset_x: str = \"0\",\n    offset_y: str = \"0\",\n    index: str = \"0\",\n    aoi_x: str = \"0\",\n    aoi_y: str = \"0\",\n    aoi_width: str = \"100\",\n    aoi_height: str = \"100\",\n    event_name: Optional[str] = None,\n    *, located: Any = None\n) -&gt; None:\n    \"\"\"\n    Press an element with self-healing.\n\n    The decorator handles:\n    - Screenshot capture\n    - Element location\n    - Multiple result handling\n    - Error aggregation\n    \"\"\"\n    # located parameter is provided by decorator\n    if isinstance(located, tuple):\n        x, y = located\n        self.driver.press_coordinates(x + int(offset_x), y + int(offset_y))\n    else:\n        self.driver.press_element(located, int(repeat))\n</code></pre></p> <p>With AOI: <pre><code># Press element in specific region\npress_element(\n    \"submit_button\",\n    aoi_x=\"50\",      # Right half of screen\n    aoi_y=\"0\",       # Top\n    aoi_width=\"50\",  # 50% width\n    aoi_height=\"100\" # Full height\n)\n</code></pre></p>"},{"location":"architecture/strategies/#error-scenarios","title":"Error Scenarios","text":"<p>1. No Strategies Available: <pre><code># Error: E0201 - No valid strategies found\n# Occurs when no strategies can locate the element\n</code></pre></p> <p>2. All Strategies Failed: <pre><code># Error: X0201 - All strategies failed\n# Occurs when all strategies tried but all failed\n# Includes last exception as cause\n</code></pre></p> <p>3. Unexpected Failure: <pre><code># Error: E0801 - Unexpected failure\n# Occurs in unexpected scenarios\n</code></pre></p>"},{"location":"architecture/strategies/#debugging-support","title":"Debugging Support","text":"<p>Screenshot Files: - Saved to <code>execution_output_path</code> - Named after function: <code>press_element.png</code> - AOI annotated: <code>press_element_with_aoi.png</code></p> <p>Logging: - Each strategy attempt is logged - Failures include strategy name and error - Execution logger shows location attempts</p> <p>Error Messages: - Include element name - Include function name - Include strategy that failed - Include original exception</p>"},{"location":"architecture/strategies/#best-practices","title":"Best Practices","text":"<ol> <li>Always Use Decorator: Apply to all element interaction methods</li> <li>Handle Located Parameter: Check if tuple (coordinates) or object (element)</li> <li>Provide Context: Include meaningful error messages</li> <li>Save Screenshots: Enable screenshot saving for debugging</li> <li>Use AOI When Appropriate: Improve performance and accuracy</li> </ol>"},{"location":"architecture/strategies/#integration-points","title":"Integration Points","text":"<ul> <li>StrategyManager: For element location</li> <li>Utils: For screenshot saving and AOI annotation</li> <li>Driver: For actual action execution</li> <li>Error System: For error reporting</li> <li>Logging: For debugging information</li> </ul>"},{"location":"architecture/strategies/#screenshot-strategies","title":"Screenshot Strategies","text":""},{"location":"architecture/strategies/#screenshotstrategy","title":"ScreenshotStrategy","text":"<p>Manages screenshot capture from element sources.</p>"},{"location":"architecture/strategies/#features_2","title":"Features","text":"<ul> <li>Black screen detection</li> <li>Screenshot validation</li> <li>Screenshot streaming support</li> <li>Multiple element source fallback</li> </ul>"},{"location":"architecture/strategies/#screenshot-streaming","title":"Screenshot Streaming","text":"<p>Location: <code>optics_framework/common/screenshot_stream.py</code></p> <p>Screenshot streaming provides continuous screenshot capture for timeout-based element location operations. This is useful when waiting for elements to appear or when monitoring screen changes.</p>"},{"location":"architecture/strategies/#architecture","title":"Architecture","text":"<pre><code>graph TB\n    A[Capture Thread] --&gt; B[Screenshot Queue]\n    B --&gt; C[Deduplication Thread]\n    C --&gt; D[Filtered Queue]\n    D --&gt; E[Strategy/Consumer]\n\n    A --&gt; F[Element Source]\n    F --&gt; A</code></pre>"},{"location":"architecture/strategies/#key-components","title":"Key Components","text":"<p>ScreenshotStream Class: <pre><code>class ScreenshotStream:\n    def __init__(self, capture_screenshot_callable, max_queue_size=100):\n        self.capture_screenshot = capture_screenshot_callable\n        self.screenshot_queue = queue.Queue(maxsize=max_queue_size)\n        self.filtered_queue = queue.Queue(maxsize=max_queue_size)\n        self.stop_event = threading.Event()\n</code></pre></p>"},{"location":"architecture/strategies/#capture-process","title":"Capture Process","text":"<p>1. Continuous Capture: <pre><code>def capture_stream(self, timeout):\n    \"\"\"\n    Continuously captures screenshots in a separate thread.\n\n    - Captures at maximum rate\n    - Stores in screenshot_queue\n    - Stops on timeout or stop_event\n    \"\"\"\n    start_time = time.time()\n    while not self.stop_event.is_set() and (time.time() - start_time) &lt; timeout:\n        frame = self.capture_screenshot()\n        self.screenshot_queue.put((frame, timestamp))\n</code></pre></p> <p>2. Deduplication: <pre><code>def process_screenshot_queue(self):\n    \"\"\"\n    Processes screenshots with SSIM-based deduplication.\n\n    - Compares frames using Structural Similarity Index\n    - Filters duplicate frames (similarity &gt;= 0.75)\n    - Stores unique frames in filtered_queue\n    \"\"\"\n    similarity = ssim(gray_last_frame, gray_frame)\n    if similarity &gt;= 0.75:\n        # Skip duplicate\n        return last_processed_frame\n    # Add to filtered queue\n</code></pre></p> <p>SSIM Deduplication: - Uses Structural Similarity Index (SSIM) to detect duplicate frames - Threshold: 0.75 (75% similarity = duplicate) - Reduces processing load by filtering similar screenshots - Preserves unique frames for element location</p>"},{"location":"architecture/strategies/#usage","title":"Usage","text":"<p>Starting Stream: <pre><code>stream = ScreenshotStream(capture_screenshot_callable)\nstream.start_capture(timeout=30, deduplication=True)\n</code></pre></p> <p>Getting Screenshots: <pre><code># Get latest screenshot\nframe, timestamp = stream.get_latest_screenshot(wait_time=1)\n\n# Get all available screenshots\nframes = stream.get_all_available_screenshots(wait_time=0.1)\n\n# Get specific number of frames\nframes = stream.fetch_frames_from_queue(num_frames=10)\n</code></pre></p> <p>Stopping Stream: <pre><code>stream.stop_capture(wait_for_threads=True, timeout=5)\n</code></pre></p>"},{"location":"architecture/strategies/#thread-management","title":"Thread Management","text":"<p>Capture Thread: - Continuously captures screenshots - Non-blocking (daemon thread) - Stops on timeout or stop_event</p> <p>Deduplication Thread: - Processes screenshots from queue - Applies SSIM deduplication - Stores unique frames in filtered queue - Optional (can be disabled)</p> <p>Cleanup: <pre><code>def stop_capture(self, wait_for_threads=True, timeout=5):\n    \"\"\"\n    Stops capture and waits for threads to finish.\n\n    - Sets stop_event\n    - Waits for threads with timeout\n    - Logs warnings if threads don't stop\n    \"\"\"\n</code></pre></p>"},{"location":"architecture/strategies/#queue-management","title":"Queue Management","text":"<p>Queue Sizes: - Default max size: 100 frames - Oldest frames dropped when queue is full - Prevents memory issues</p> <p>Queue Operations: <pre><code># Clear queues\nstream.clear_queues()\n\n# Get queue sizes (debugging)\nsizes = stream.get_queue_sizes()\n# Returns: {'screenshot_queue_size': 10, 'filtered_queue_size': 5}\n</code></pre></p>"},{"location":"architecture/strategies/#performance-considerations","title":"Performance Considerations","text":"<p>Benefits: - Non-blocking capture (doesn't slow down execution) - Deduplication reduces processing load - Queue-based (decouples capture from consumption)</p> <p>Trade-offs: - Memory usage (queues store frames) - CPU usage (deduplication computation) - Thread overhead</p> <p>Optimization Tips: - Adjust <code>max_queue_size</code> based on needs - Disable deduplication if not needed - Use appropriate timeout values - Clear queues between operations</p>"},{"location":"architecture/strategies/#use-cases","title":"Use Cases","text":"<ol> <li>Timeout-Based Location: Wait for element to appear</li> <li>Screen Change Detection: Monitor for UI changes</li> <li>Continuous Monitoring: Track screen state over time</li> <li>Performance Analysis: Capture frames for analysis</li> </ol>"},{"location":"architecture/strategies/#integration-with-strategies","title":"Integration with Strategies","text":"<p>Strategies can use screenshot streaming for timeout-based operations:</p> <pre><code># In strategy implementation\ndef locate_with_timeout(self, element: str, timeout: int = 30):\n    stream = ScreenshotStream(self.element_source.capture)\n    stream.start_capture(timeout, deduplication=True)\n\n    while True:\n        frame, timestamp = stream.get_latest_screenshot()\n        if frame is None:\n            continue\n\n        # Try to locate element in frame\n        result = self._locate_in_frame(frame, element)\n        if result:\n            stream.stop_capture()\n            return result\n\n        # Check timeout\n        if time.time() - start_time &gt; timeout:\n            break\n\n    stream.stop_capture()\n    raise ElementNotFoundError()\n</code></pre>"},{"location":"architecture/strategies/#page-source-strategies","title":"Page Source Strategies","text":""},{"location":"architecture/strategies/#pagesourcestrategy","title":"PagesourceStrategy","text":"<p>Manages page source extraction from element sources.</p>"},{"location":"architecture/strategies/#features_3","title":"Features","text":"<ul> <li>Page source extraction</li> <li>Interactive element detection</li> <li>Multiple format support (XML, HTML)</li> <li>Element hierarchy navigation</li> </ul>"},{"location":"architecture/strategies/#strategy-result-handling","title":"Strategy Result Handling","text":""},{"location":"architecture/strategies/#locateresult","title":"LocateResult","text":"<p>Wraps location results with strategy information:</p> <pre><code>class LocateResult:\n    def __init__(self, value: Union[object, Tuple[int, int]], strategy: LocatorStrategy):\n        self.value = value  # Coordinates or element object\n        self.strategy = strategy  # Which strategy found it\n        self.is_coordinates = isinstance(value, tuple)\n</code></pre>"},{"location":"architecture/strategies/#result-types","title":"Result Types","text":"<ol> <li>Coordinates: <code>(x, y)</code> tuple for direct coordinate-based actions</li> <li>Element Object: Element object for driver-specific actions</li> </ol>"},{"location":"architecture/strategies/#best-practices_1","title":"Best Practices","text":""},{"location":"architecture/strategies/#strategy-selection_1","title":"Strategy Selection","text":"<ol> <li>Use XPath when possible: Fastest and most reliable</li> <li>Fallback to vision: When UI structure is unknown</li> <li>Configure multiple models: For maximum resilience</li> <li>Set appropriate timeouts: For element appearance</li> </ol>"},{"location":"architecture/strategies/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Priority ordering: Fastest strategies first</li> <li>Caching: Screenshots may be cached</li> <li>Early exit: Stop trying when first strategy succeeds</li> <li>Parallel execution: Multiple strategies can run in parallel</li> </ol>"},{"location":"architecture/strategies/#error-handling","title":"Error Handling","text":"<ol> <li>Graceful degradation: Try next strategy on failure</li> <li>Error aggregation: Collect all errors for debugging</li> <li>Screenshot capture: Save screenshots on failures</li> <li>Detailed logging: Log strategy attempts and results</li> </ol>"},{"location":"architecture/strategies/#extension-guide","title":"Extension Guide","text":""},{"location":"architecture/strategies/#adding-a-new-strategy","title":"Adding a New Strategy","text":"<ol> <li>Create class extending <code>LocatorStrategy</code>:</li> </ol> <pre><code>class CustomStrategy(LocatorStrategy):\n    def __init__(self, element_source: ElementSourceInterface):\n        self._element_source = element_source\n\n    def locate(self, element: str, index: int = 0):\n        # Implementation\n        pass\n\n    @staticmethod\n    def supports(element_type: str, element_source: ElementSourceInterface) -&gt; bool:\n        return element_type == \"Custom\" and ...\n</code></pre> <ol> <li>Register in <code>StrategyFactory</code>:</li> </ol> <pre><code>self._registry = [\n    ...,\n    (CustomStrategy, \"Custom\", {}, 5),  # Priority 5\n]\n</code></pre> <ol> <li>Strategy will be automatically used when:</li> <li>Element type matches</li> <li>Element source supports it</li> <li>Higher priority strategies fail</li> </ol>"},{"location":"architecture/strategies/#debugging-strategies","title":"Debugging Strategies","text":""},{"location":"architecture/strategies/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>import logging\nlogging.getLogger(\"optics_framework.common.strategies\").setLevel(logging.DEBUG)\n</code></pre>"},{"location":"architecture/strategies/#strategy-execution-log","title":"Strategy Execution Log","text":"<p>The framework logs: - Which strategies are tried - Which strategy succeeded - Why strategies failed - Screenshot locations</p>"},{"location":"architecture/strategies/#visual-debugging","title":"Visual Debugging","text":"<p>Screenshots are saved with strategy information: - <code>press_element_with_xpath.png</code> - <code>press_element_with_ocr.png</code> - <code>press_element_with_image.png</code></p>"},{"location":"architecture/strategies/#related-documentation","title":"Related Documentation","text":"<ul> <li>Components - Component architecture and Optics class</li> <li>Engines - Engine implementations</li> <li>Execution - Execution flow and test context</li> <li>Error Handling - Error codes and handling</li> <li>Logging - Logging system</li> <li>Architecture Decisions - Strategy pattern rationale</li> <li>Extending - Creating custom strategies</li> <li>Self-Healing Decorator - Detailed decorator implementation</li> <li>AOI Support - Area of Interest system</li> <li>Screenshot Streaming - Continuous screenshot capture</li> </ul>"},{"location":"contribution/code_of_conduct/","title":"Code of Conduct","text":""},{"location":"contribution/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We, as contributors and maintainers of the Optics Framework, pledge to make participation in our project and community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"contribution/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment include:</p> <ul> <li>Using welcoming and inclusive language.</li> <li>Being respectful of differing viewpoints and experiences.</li> <li>Gracefully accepting constructive criticism.</li> <li>Focusing on what is best for the community.</li> <li>Showing empathy towards other community members.</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances.</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks.</li> <li>Public or private harassment.</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission.</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting.</li> </ul>"},{"location":"contribution/code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned with this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"contribution/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces (e.g., GitHub repository, issue trackers, documentation) and in public spaces when an individual is representing the Optics Framework or its community.</p>"},{"location":"contribution/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project maintainers at [TODO: Add Lalit's sir email]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Maintainers are obligated to maintain confidentiality with regard to the reporter of an incident.</p>"},{"location":"contribution/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct/.</p>"},{"location":"contribution/contributing_guidelines/","title":"Contributing Guidelines","text":"<p>Before Contributing</p> <p>Before contributing, please read our Code of Conduct to understand the standards of behavior we expect from our contributors.</p> <p>Welcome to the contributing guidelines for the Optics Framework! We appreciate your interest in contributing to our project.</p>"},{"location":"contribution/contributing_guidelines/#how-to-contribute","title":"How to Contribute","text":"<p>We welcome contributions in the form of bug reports, feature requests, documentation improvements, and code contributions. To contribute, follow these steps:</p> <ul> <li> <p>Fork the Repository: Click the \"Fork\" button on the top right of the repository page to create a copy of the repository in your GitHub account.</p> </li> <li> <p>Clone the Repository: Clone the forked repository to your local machine using the following command:</p> </li> </ul> <pre><code>git clone &lt;your_forked_repository_url&gt;\n</code></pre> <ul> <li>Create a Branch: Create a new branch for your contribution using the following command:</li> </ul> <pre><code>git checkout -b &lt;branch_name&gt;\n</code></pre> <ul> <li> <p>Make Changes: Make your changes to the codebase, documentation, or tests.</p> </li> <li> <p>Commit Changes: Commit your changes with a descriptive commit message.</p> </li> </ul> <p>Commit Message Format</p> <p>Ensure that your commit messages follow the Conventional Commits format for consistency and clarity (e.g., <code>feat: add new feature</code>, <code>fix: resolve bug #123</code>).</p> <p>Signing Commits</p> <p>Sign your commits using the Developer Certificate of Origin (DCO) to certify your contribution. Use <code>git commit -s</code> to add a <code>Signed-off-by</code> line.</p> <ul> <li> <p>Push Changes: Push your changes to your forked remote repository.</p> </li> <li> <p>Create a Pull Request: Create a pull request from your forked repository to the main repository.</p> </li> </ul> <p>Referencing Issues in Pull Requests</p> <p>If you are fixing an issue, reference the issue number in your pull request message using the format <code>Fixes #&lt;issue_number&gt;</code> to link it automatically.</p> <ul> <li>Review and Merge: The maintainers will review your pull request and merge it if it meets the project's guidelines.</li> </ul>"},{"location":"contribution/contributing_guidelines/#reporting-issues","title":"Reporting Issues","text":"<p>To report a bug, follow these steps:</p> <ol> <li> <p>Check Existing Issues: Check if the bug has already been reported by searching the existing issues.</p> </li> <li> <p>Create a New Issue: If the bug has not been reported, create a new issue with the following details:</p> </li> <li> <p>Issue Title: A descriptive title that summarizes the bug.</p> </li> <li> <p>Description: A detailed description of the bug, including steps to reproduce it.</p> </li> <li> <p>Expected Behavior: A description of what you expected to happen.</p> </li> <li> <p>Actual Behavior: A description of what actually happened.</p> </li> <li> <p>Environment: Details about your environment, such as the operating system, Python version, and any other relevant information.</p> </li> <li> <p>Screenshots: If applicable, include screenshots that help illustrate the bug.</p> </li> <li> <p>Labels: Add appropriate labels to the issue, such as <code>bug</code> or <code>enhancement</code>.</p> </li> </ol>"},{"location":"contribution/developer_guide/","title":"Developer Guide","text":"<p>This section provides guidelines for developers who want to contribute to the Optics Framework.</p> <p>Note: Before contributing, please read our Contributing Guidelines to understand the contribution process.</p>"},{"location":"contribution/developer_guide/#1-setting-up-the-development-environment","title":"1. Setting Up the Development Environment","text":"<p>To set up the development environment for the Optics Framework, follow these steps:</p>"},{"location":"contribution/developer_guide/#clone-the-repository","title":"Clone the Repository","text":"<p>Clone the Optics Framework repository to your local machine using the following command:</p> <pre><code>git clone &lt;repository_url&gt;\ncd optics-framework\n</code></pre>"},{"location":"contribution/developer_guide/#install-dependencies","title":"Install Dependencies","text":"<p>Install the required dependencies using the following command:</p> <pre><code>pipx install poetry\n</code></pre> <p>For changes related to source code:</p> <pre><code>poetry install --with dev\n</code></pre> <p>For changes related to documentation:</p> <pre><code>poetry install --with docs\n</code></pre> <p>For default installation:</p> <pre><code>poetry install\n</code></pre> <p>NOTE: We recommend using <code>poetry</code> to manage dependencies and virtual environments for the project. NOTE: For more info about <code>pipx</code> and <code>poetry</code>, refer to the pipx documentation and poetry documentation.</p>"},{"location":"contribution/developer_guide/#install-pre-commit-hooks","title":"Install Pre-Commit Hooks","text":"<p>After installing dependencies, set up the pre-commit hooks to ensure code quality and commit message formatting:</p> <pre><code>poetry run pre-commit install\n</code></pre> <p>This will install hooks that: - Run <code>ruff</code> for code linting and formatting - Run <code>bandit</code> for security checks - Validate commit messages using <code>commitizen</code> (Conventional Commits format) - Check for trailing whitespace, end-of-file issues, and YAML/JSON validity - Scan for secrets using <code>gitleaks</code></p> <p>NOTE: Pre-commit hooks will automatically run on <code>git commit</code>. You can also run them manually: <pre><code>poetry run pre-commit run --all-files\n</code></pre></p>"},{"location":"contribution/developer_guide/#2-create-a-new-branch","title":"2. Create a New Branch","text":"<p>Before making any changes to the codebase, create a new branch for your contribution using the following command:</p> <pre><code>git checkout -b &lt;branch_name&gt;\n</code></pre>"},{"location":"contribution/developer_guide/#3-make-changes","title":"3. Make Changes","text":"<p>Work on your feature, bug fix, or documentation improvement in the appropriate directory:</p> <ul> <li>Source code: <code>optics_framework/</code></li> <li>Tests: <code>tests/</code></li> <li>Documentation: <code>docs/</code></li> </ul>"},{"location":"contribution/developer_guide/#source-code-changes","title":"Source Code Changes","text":"<ul> <li>Make changes to the source code in the <code>optics_framework/</code> directory.</li> </ul> <p>Adhere to the project\u2019s coding standards: Use Ruff for linting and formatting:</p> <pre><code>poetry run ruff check .\npoetry run ruff format .\n</code></pre> <p>Or run both together:</p> <pre><code>poetry run ruff check --fix .\npoetry run ruff format .\n</code></pre> <p>NOTE: Ruff is configured to automatically fix issues where possible. The pre-commit hooks will also run Ruff automatically on commit.</p>"},{"location":"contribution/developer_guide/#documentation-changes","title":"Documentation Changes","text":"<ul> <li>Make changes to the documentation in the <code>docs/</code> directory.</li> <li>Ensure the documentation is clear, concise, and follows the style guide.</li> <li>Use MkDocs for generating documentation.</li> </ul> <p>For live changes while working on documentation: Use MkDocs to serve the documentation locally with auto-reload:</p> <pre><code>poetry run mkdocs serve\n</code></pre> <p>This will start a local server (typically at <code>http://127.0.0.1:8000</code>) that automatically reloads when you make changes to the documentation files.</p> <p>To build the documentation for production:</p> <pre><code>poetry run mkdocs build\n</code></pre>"},{"location":"contribution/developer_guide/#run-tests","title":"Run Tests","text":"<p>Run the tests to ensure that your changes do not break existing functionality:</p> <pre><code>poetry run pytest\n</code></pre>"},{"location":"contribution/developer_guide/#packaging","title":"Packaging","text":"<p>To build the package:</p> <pre><code>poetry build\n</code></pre>"},{"location":"contribution/developer_guide/#4-commit-changes","title":"4. Commit Changes","text":"<ul> <li>Adhere to the Conventional Commits format for your commit messages.</li> <li>The pre-commit hooks will automatically validate your commit messages using <code>commitizen</code>.</li> <li>You can also use <code>commitizen</code> to help create properly formatted commit messages:</li> </ul> <pre><code>poetry run cz commit\n</code></pre> <p>This will interactively guide you through creating a commit message that follows the Conventional Commits format.</p> <p>NOTE: If you installed the pre-commit hooks (step 1.3), they will automatically run on each commit to check code quality and validate commit messages.</p>"},{"location":"contribution/help_wanted/","title":"Help Wanted","text":"<p>Contributing to Optics Framework</p> <p>We welcome contributions from the community! This document outlines areas where the Optics Framework could benefit from your help. Whether you're a beginner or an experienced developer, there's something for everyone.</p> <p>This document identifies specific areas for improvement across the Optics Framework. Each section includes the current state, goals, implementation details, and priority levels to help you choose where to contribute.</p>"},{"location":"contribution/help_wanted/#priority-and-difficulty-levels","title":"Priority and Difficulty Levels","text":"<p>Each item is tagged with:</p> <p>Priority Levels:</p> <ul> <li>High Priority: Critical for production use or security</li> <li>Medium Priority: Important for usability and completeness</li> <li>Low Priority: Nice to have improvements</li> </ul> <p>Difficulty Levels:</p> <ul> <li>Beginner: Good first contribution, minimal framework knowledge needed</li> <li>Intermediate: Requires some framework knowledge</li> <li>Advanced: Requires deep framework understanding</li> </ul>"},{"location":"contribution/help_wanted/#1-stateless-api-layer","title":"1. Stateless API Layer","text":"<p>Priority: High | Difficulty: Advanced</p>"},{"location":"contribution/help_wanted/#current-state","title":"Current State","text":"<p>The API layer maintains state in <code>SessionManager</code> which stores sessions in memory. Sessions cannot be migrated between instances, making it difficult to scale horizontally or recover from instance failures.</p>"},{"location":"contribution/help_wanted/#goal","title":"Goal","text":"<p>Make the API layer stateless so sessions can be migrated/moved from one instance to another without losing context. This enables:</p> <ul> <li>Horizontal scaling of API instances</li> <li>Session recovery after instance failures</li> <li>Load balancing across multiple instances</li> <li>Zero-downtime deployments</li> </ul>"},{"location":"contribution/help_wanted/#key-areas","title":"Key Areas","text":""},{"location":"contribution/help_wanted/#session-storage","title":"Session Storage","text":"<p>Current: Sessions stored in-memory only (<code>optics_framework/common/session_manager.py</code>)</p> <p>Needed:</p> <ul> <li>External session storage (database, Redis, etc.)</li> <li>Session serialization/deserialization</li> <li>Session state export/import functionality</li> </ul>"},{"location":"contribution/help_wanted/#session-context","title":"Session Context","text":"<p>Current: Session contains driver instances, element sources, vision models that cannot be serialized</p> <p>Needed:</p> <ul> <li>Serialize all session state (configuration, driver state, element sources, vision models)</li> <li>Reconstruct session from serialized state</li> <li>Handle driver reconnection on migration</li> <li>Store driver session IDs and connection details</li> </ul>"},{"location":"contribution/help_wanted/#api-endpoints","title":"API Endpoints","text":"<p>New Endpoints Needed:</p> <ul> <li><code>POST /v1/sessions/{id}/export</code> - Export session state as JSON</li> <li><code>POST /v1/sessions/import</code> - Import session state and recreate session</li> <li><code>POST /v1/sessions/{id}/migrate</code> - Migrate session to another instance</li> </ul>"},{"location":"contribution/help_wanted/#files-to-modify","title":"Files to Modify","text":"<ul> <li><code>optics_framework/common/session_manager.py</code> - Add serialization support</li> <li><code>optics_framework/common/expose_api.py</code> - Add migration endpoints</li> <li><code>optics_framework/common/models.py</code> - Add session state models (Pydantic)</li> <li><code>optics_framework/common/optics_builder.py</code> - Support session reconstruction</li> </ul>"},{"location":"contribution/help_wanted/#related-documentation","title":"Related Documentation","text":"<ul> <li>Session Management</li> <li>REST API Layer</li> </ul>"},{"location":"contribution/help_wanted/#2-parallel-strategy-execution","title":"2. Parallel Strategy Execution","text":"<p>Priority: High | Difficulty: Advanced</p>"},{"location":"contribution/help_wanted/#current-state_1","title":"Current State","text":"<p>Strategies are currently executed sequentially (one after another) in a fallback chain. When locating an element, the framework tries Strategy 1, waits for it to complete (success or failure), then tries Strategy 2, and so on. This sequential approach, while reliable, is slower than necessary because:</p> <ol> <li>Independent strategies wait unnecessarily: Many strategies can run simultaneously since they don't depend on each other</li> <li>Total execution time is sum of all strategies: If Strategy 1 takes 2s and Strategy 2 takes 3s, total time is 5s even if Strategy 2 could succeed immediately</li> <li>Resource underutilization: CPU, I/O, and network resources are idle while waiting for sequential execution</li> </ol> <p>Example of Current Sequential Flow:</p> <pre><code># Current: Sequential execution\n1. Try XPathStrategy.find_element() \u2192 Wait 2s \u2192 Fail\n2. Try TextElementStrategy.find_element() \u2192 Wait 1s \u2192 Fail\n3. Try TextDetectionStrategy.find_element() \u2192 Wait 3s \u2192 Success\n# Total time: 6 seconds\n</code></pre>"},{"location":"contribution/help_wanted/#goal_1","title":"Goal","text":"<p>Implement parallel strategy execution where multiple independent strategies run simultaneously, significantly reducing element location time while maintaining the same reliability and fallback behavior.</p> <p>Benefits:</p> <ul> <li>Faster element location: Strategies execute concurrently, returning the first successful result</li> <li>Better resource utilization: CPU, I/O, and network resources used efficiently</li> <li>Improved user experience: Tests execute faster, especially with multiple fallback strategies</li> <li>Maintains reliability: Still supports fallback, but optimizes for the common case</li> </ul> <p>Example of Desired Parallel Flow:</p> <pre><code># Desired: Parallel execution\n1. Start XPathStrategy.find_element() \u2192 (runs in background)\n2. Start TextElementStrategy.find_element() \u2192 (runs in background)\n3. Start TextDetectionStrategy.find_element() \u2192 (runs in background)\n4. First successful result returns \u2192 Total time: ~3 seconds (longest strategy)\n</code></pre>"},{"location":"contribution/help_wanted/#execution-semantics","title":"Execution Semantics","text":"<p>Critical Requirement: Only one strategy should execute the final keyword/action. Once a strategy successfully performs the keyword, all remaining strategies must be immediately aborted.</p> <p>Execution Rules:</p> <ol> <li>Parallel Location Phase: Multiple strategies run in parallel to locate the element</li> <li>All strategies attempt to find the element simultaneously</li> <li>First successful location result is selected</li> <li> <p>Remaining location attempts are cancelled/aborted</p> </li> <li> <p>Single Action Execution: Only the winning strategy executes the keyword/action</p> </li> <li>The strategy that successfully located the element proceeds to execute the action</li> <li>Other strategies are aborted before they can execute any actions</li> <li> <p>This prevents duplicate actions (e.g., clicking the same button twice)</p> </li> <li> <p>Fallback Behavior: If the selected strategy fails to execute the keyword</p> </li> <li>Abort the failed strategy</li> <li>Move to the next successful location result (if available)</li> <li>If no other strategies succeeded in location, try the next strategy in sequence</li> </ol> <p>Example Flow:</p> <pre><code># Parallel location phase\nstrategy1_result = await XPathStrategy.locate(element)      # Success: found element\nstrategy2_result = await TextStrategy.locate(element)      # Success: found element\nstrategy3_result = await OCRStrategy.locate(element)       # Still running...\n\n# Strategy 1 wins (first success)\nif strategy1_result:\n    # Abort strategy 2 and 3 immediately\n    abort_strategy(strategy2)\n    abort_strategy(strategy3)\n\n    # Only strategy 1 executes the keyword\n    try:\n        await strategy1.execute_keyword(\"press_element\", strategy1_result)\n        return success  # Done! No other strategies execute\n    except Exception:\n        # Strategy 1 failed to execute, try strategy 2\n        abort_strategy(strategy1)\n        await strategy2.execute_keyword(\"press_element\", strategy2_result)\n        return success\n</code></pre> <p>Implementation Requirements:</p> <ul> <li>Cancellation Tokens: Use <code>asyncio.CancelledError</code> or cancellation tokens to abort strategies</li> <li>Early Exit: Return immediately when first strategy succeeds</li> <li>Resource Cleanup: Properly clean up aborted strategies (close connections, release locks)</li> <li>Error Handling: Handle cancellation gracefully without side effects</li> </ul>"},{"location":"contribution/help_wanted/#key-scenarios","title":"Key Scenarios","text":""},{"location":"contribution/help_wanted/#scenario-1-xpath-with-parallel-coordinate-discovery","title":"Scenario 1: XPath with Parallel Coordinate Discovery","text":"<p>Current Behavior:</p> <p>When given an XPath, the framework: 1. Tries <code>find_element()</code> using the XPath directly 2. If that fails, tries other strategies sequentially</p> <p>Desired Parallel Behavior:</p> <p>When given an XPath, simultaneously:</p> <ol> <li>Primary path: Execute <code>find_element()</code> using the XPath directly</li> <li>Parallel path: Search page source to find the XPath and extract coordinates</li> <li>Fallback path: If XPath is not accessible, use coordinates from page source</li> </ol> <p>Implementation Flow:</p> <pre><code># Parallel execution\nasync def locate_with_xpath(element: str):\n    tasks = [\n        # Task 1: Direct findElement\n        find_element_direct(element),\n\n        # Task 2: Parse page source for XPath and get coordinates\n        parse_page_source_for_coordinates(element),\n\n        # Task 3: Alternative XPath variations\n        try_xpath_variations(element)\n    ]\n\n    # Return first successful result\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    return first_successful_result(results)\n</code></pre>"},{"location":"contribution/help_wanted/#scenario-2-text-with-parallel-xpath-discovery-and-ocr","title":"Scenario 2: Text with Parallel XPath Discovery and OCR","text":"<p>Current Behavior:</p> <p>When given text, the framework: 1. Tries text-based element location 2. If that fails, tries OCR sequentially 3. If that fails, tries other strategies</p> <p>Desired Parallel Behavior:</p> <p>When given text, simultaneously:</p> <ol> <li>Path A: Search page source to find text and convert to XPath, then execute <code>find_element()</code></li> <li>Path B: Capture screenshot and use OCR/text detection to find coordinates</li> <li>Path C: Try direct text matching in element source</li> </ol> <p>Implementation Flow:</p> <pre><code># Parallel execution for text\nasync def locate_with_text(text: str):\n    tasks = [\n        # Task 1: Page source \u2192 XPath \u2192 findElement\n        page_source_to_xpath_to_find_element(text),\n\n        # Task 2: Screenshot \u2192 OCR \u2192 Coordinates\n        screenshot_ocr_to_coordinates(text),\n\n        # Task 3: Direct text element location\n        direct_text_element_location(text)\n    ]\n\n    # Return first successful result\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    return first_successful_result(results)\n</code></pre>"},{"location":"contribution/help_wanted/#scenario-3-image-template-with-parallel-detection-methods","title":"Scenario 3: Image Template with Parallel Detection Methods","text":"<p>Current Behavior:</p> <p>When given an image template, tries image detection strategies sequentially.</p> <p>Desired Parallel Behavior:</p> <p>Simultaneously: 1. Template matching (OpenCV) 2. Remote OIR service 3. Alternative image detection models</p>"},{"location":"contribution/help_wanted/#implementation-approach","title":"Implementation Approach","text":""},{"location":"contribution/help_wanted/#architecture-changes","title":"Architecture Changes","text":"<p>1. Strategy Execution Model</p> <p>Convert from sequential to parallel execution with abort capability:</p> <pre><code># Current: Sequential\nclass StrategyManager:\n    def locate(self, element: str):\n        for strategy in self.strategies:\n            result = strategy.locate(element)  # Blocks here\n            if result:\n                return result\n        raise ElementNotFoundError()\n\n# Desired: Parallel with abort\nclass StrategyManager:\n    async def locate(self, element: str):\n        # Create tasks with cancellation support\n        tasks = {\n            strategy: asyncio.create_task(strategy.locate_async(element))\n            for strategy in self.strategies\n        }\n\n        # Wait for first success, then abort others\n        for strategy, task in tasks.items():\n            try:\n                result = await task\n                if result:\n                    # Abort all remaining tasks\n                    for other_strategy, other_task in tasks.items():\n                        if other_strategy != strategy and not other_task.done():\n                            other_task.cancel()\n                    return result\n            except asyncio.CancelledError:\n                continue\n\n        raise ElementNotFoundError()\n</code></pre> <p>2. Strategy Interface Updates</p> <p>Make strategies async-compatible:</p> <pre><code># Current\nclass LocatorStrategy(ABC):\n    def locate(self, element: str, index: int = 0):\n        # Synchronous implementation\n        pass\n\n# Desired\nclass LocatorStrategy(ABC):\n    async def locate_async(self, element: str, index: int = 0):\n        # Asynchronous implementation\n        pass\n\n    def locate(self, element: str, index: int = 0):\n        # Synchronous wrapper for backward compatibility\n        return run_async(self.locate_async(element, index))\n</code></pre> <p>3. Parallel Execution Groups with Abort</p> <p>Group strategies that can run in parallel with abort capability:</p> <pre><code>class ParallelStrategyGroup:\n    \"\"\"Groups strategies that can execute in parallel\"\"\"\n\n    def __init__(self, strategies: List[LocatorStrategy]):\n        self.strategies = strategies\n        self.priority = min(s.priority for s in strategies)\n\n    async def execute_parallel(self, element: str):\n        \"\"\"Execute all strategies in parallel, return first success, abort others\"\"\"\n        # Create cancellable tasks\n        tasks = {\n            strategy: asyncio.create_task(strategy.locate_async(element))\n            for strategy in self.strategies\n        }\n\n        # Wait for first success\n        for strategy, task in tasks.items():\n            try:\n                result = await task\n                if result:\n                    # Abort all remaining tasks\n                    self._abort_remaining(tasks, strategy)\n                    return result\n            except asyncio.CancelledError:\n                continue\n\n        return None\n\n    def _abort_remaining(self, tasks: dict, winner: LocatorStrategy):\n        \"\"\"Cancel all tasks except the winner\"\"\"\n        for strategy, task in tasks.items():\n            if strategy != winner and not task.done():\n                task.cancel()\n</code></pre> <p>4. Dependency Management</p> <p>Identify which strategies can run in parallel vs. which must be sequential:</p> <pre><code>class StrategyDependencyGraph:\n    \"\"\"Manages strategy dependencies and parallel execution\"\"\"\n\n    def can_run_parallel(self, strategy1: LocatorStrategy, strategy2: LocatorStrategy) -&gt; bool:\n        \"\"\"Check if two strategies can run in parallel\"\"\"\n        # Strategies can run in parallel if:\n        # 1. They don't modify shared state\n        # 2. They don't depend on each other's results\n        # 3. They use different resources (e.g., page source vs screenshot)\n        return (\n            not strategy1.modifies_shared_state() and\n            not strategy2.modifies_shared_state() and\n            strategy1.resource_type() != strategy2.resource_type()\n        )\n</code></pre>"},{"location":"contribution/help_wanted/#specific-implementation-patterns","title":"Specific Implementation Patterns","text":"<p>Pattern 1: XPath with Coordinate Discovery</p> <pre><code>async def locate_xpath_parallel(element: str):\n    \"\"\"Locate element by XPath with parallel coordinate discovery\"\"\"\n\n    async def direct_find():\n        \"\"\"Direct findElement using XPath\"\"\"\n        return await element_source.locate(element)\n\n    async def page_source_coords():\n        \"\"\"Parse page source to find XPath and get coordinates\"\"\"\n        page_source, _ = await element_source.get_page_source()\n        xpath_node = parse_xpath_from_page_source(page_source, element)\n        if xpath_node:\n            return get_coordinates_from_node(xpath_node)\n        return None\n\n    # Execute both in parallel\n    results = await asyncio.gather(\n        direct_find(),\n        page_source_coords(),\n        return_exceptions=True\n    )\n\n    # Prefer direct find, fallback to coordinates\n    if results[0] and not isinstance(results[0], Exception):\n        return results[0]\n    if results[1] and not isinstance(results[1], Exception):\n        return results[1]\n    raise ElementNotFoundError()\n</code></pre> <p>Pattern 2: Text with Multi-Path Discovery</p> <pre><code>async def locate_text_parallel(text: str):\n    \"\"\"Locate element by text with parallel multi-path discovery\"\"\"\n\n    async def page_source_path():\n        \"\"\"Page source \u2192 Find text \u2192 Convert to XPath \u2192 findElement\"\"\"\n        page_source, _ = await element_source.get_page_source()\n        xpath = find_text_in_page_source(page_source, text)\n        if xpath:\n            return await element_source.locate(xpath)\n        return None\n\n    async def screenshot_ocr_path():\n        \"\"\"Screenshot \u2192 OCR \u2192 Find coordinates\"\"\"\n        screenshot = await element_source.capture()\n        text_locations = await text_detection.find_element(screenshot, text)\n        if text_locations:\n            return text_locations[0]  # Return first match\n        return None\n\n    async def direct_text_path():\n        \"\"\"Direct text element location\"\"\"\n        return await element_source.locate_by_text(text)\n\n    # Execute all three paths in parallel\n    results = await asyncio.gather(\n        page_source_path(),\n        screenshot_ocr_path(),\n        direct_text_path(),\n        return_exceptions=True\n    )\n\n    # Return first successful result\n    for result in results:\n        if result and not isinstance(result, Exception):\n            return result\n    raise ElementNotFoundError()\n</code></pre> <p>Pattern 3: Resource-Aware Parallel Execution</p> <pre><code>class ResourceAwareStrategyExecutor:\n    \"\"\"Executes strategies in parallel while managing resources\"\"\"\n\n    def __init__(self):\n        self.page_source_lock = asyncio.Lock()\n        self.screenshot_lock = asyncio.Lock()\n        self.driver_lock = asyncio.Lock()\n\n    async def execute_parallel(self, strategies: List[LocatorStrategy], element: str):\n        \"\"\"Execute strategies in parallel with resource management\"\"\"\n\n        # Group strategies by resource type\n        page_source_strategies = [s for s in strategies if s.uses_page_source()]\n        screenshot_strategies = [s for s in strategies if s.uses_screenshot()]\n        driver_strategies = [s for s in strategies if s.uses_driver()]\n\n        # Execute groups in parallel, but serialize within groups if needed\n        tasks = []\n\n        if page_source_strategies:\n            tasks.append(self._execute_with_lock(\n                page_source_strategies, element, self.page_source_lock\n            ))\n\n        if screenshot_strategies:\n            tasks.append(self._execute_with_lock(\n                screenshot_strategies, element, self.screenshot_lock\n            ))\n\n        if driver_strategies:\n            tasks.append(self._execute_with_lock(\n                driver_strategies, element, self.driver_lock\n            ))\n\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        return first_successful_result(results)\n</code></pre>"},{"location":"contribution/help_wanted/#key-implementation-areas","title":"Key Implementation Areas","text":""},{"location":"contribution/help_wanted/#1-async-strategy-interface","title":"1. Async Strategy Interface","text":"<p>Files to Modify:</p> <ul> <li><code>optics_framework/common/strategies.py</code> - Add async methods to <code>LocatorStrategy</code></li> <li>All strategy implementations - Add <code>locate_async()</code> methods</li> </ul> <p>Changes Needed:</p> <ul> <li>Convert <code>locate()</code> methods to async</li> <li>Maintain backward compatibility with sync wrappers</li> <li>Update strategy base class</li> </ul>"},{"location":"contribution/help_wanted/#2-parallel-execution-engine","title":"2. Parallel Execution Engine","text":"<p>Files to Create/Modify:</p> <ul> <li><code>optics_framework/common/parallel_strategy_executor.py</code> - New parallel executor</li> <li><code>optics_framework/common/strategies.py</code> - Update <code>StrategyManager</code> for parallel execution</li> </ul> <p>Features:</p> <ul> <li>Parallel task execution using <code>asyncio.create_task()</code> and cancellation</li> <li>First-success-wins semantics with immediate abort of remaining strategies</li> <li>Exception handling and aggregation</li> <li>Resource management (locks for shared resources)</li> <li>Cancellation token support for graceful abort</li> <li>Only winning strategy executes the keyword/action</li> </ul>"},{"location":"contribution/help_wanted/#3-strategy-dependency-analysis","title":"3. Strategy Dependency Analysis","text":"<p>Files to Create:</p> <ul> <li><code>optics_framework/common/strategy_dependencies.py</code> - Dependency analysis</li> </ul> <p>Features:</p> <ul> <li>Identify which strategies can run in parallel</li> <li>Group strategies by resource requirements</li> <li>Manage resource locks (page source, screenshot, driver)</li> </ul>"},{"location":"contribution/help_wanted/#4-configuration-and-control","title":"4. Configuration and Control","text":"<p>Files to Modify:</p> <ul> <li><code>optics_framework/common/config_handler.py</code> - Add parallel execution config</li> <li><code>optics_framework/common/models.py</code> - Add configuration models</li> </ul> <p>Configuration Options:</p> <pre><code>strategy_execution:\n  mode: \"parallel\"  # \"sequential\" or \"parallel\"\n  max_parallel_strategies: 5\n  timeout_per_strategy: 10\n  resource_locks:\n    page_source: true\n    screenshot: true\n    driver: false\n</code></pre>"},{"location":"contribution/help_wanted/#performance-considerations","title":"Performance Considerations","text":""},{"location":"contribution/help_wanted/#expected-improvements","title":"Expected Improvements","text":"<ul> <li>XPath location: 40-60% faster (2-3 strategies in parallel)</li> <li>Text location: 50-70% faster (3-4 strategies in parallel)</li> <li>Image location: 30-50% faster (2-3 detection methods in parallel)</li> <li>Overall test execution: 20-40% faster for tests with many element locations</li> </ul>"},{"location":"contribution/help_wanted/#resource-management","title":"Resource Management","text":"<ul> <li>CPU: Better utilization with parallel I/O operations</li> <li>Memory: Slight increase due to parallel task execution</li> <li>Network: Better utilization for remote services (OCR, OIR)</li> <li>Driver: Careful locking to prevent driver conflicts</li> </ul>"},{"location":"contribution/help_wanted/#testing-requirements","title":"Testing Requirements","text":""},{"location":"contribution/help_wanted/#unit-tests","title":"Unit Tests","text":"<ul> <li>Test parallel execution with mock strategies</li> <li>Test first-success-wins behavior</li> <li>Test abort/cancellation of remaining strategies when one succeeds</li> <li>Test that only one strategy executes the keyword/action</li> <li>Test exception handling</li> <li>Test resource locking</li> <li>Test graceful cancellation cleanup</li> </ul>"},{"location":"contribution/help_wanted/#integration-tests","title":"Integration Tests","text":"<ul> <li>Test with real drivers and element sources</li> <li>Test performance improvements</li> <li>Test backward compatibility</li> <li>Test configuration options</li> </ul>"},{"location":"contribution/help_wanted/#migration-path","title":"Migration Path","text":""},{"location":"contribution/help_wanted/#phase-1-add-async-support-non-breaking","title":"Phase 1: Add Async Support (Non-Breaking)","text":"<ul> <li>Add async methods alongside sync methods</li> <li>Maintain backward compatibility</li> <li>No behavior changes</li> </ul>"},{"location":"contribution/help_wanted/#phase-2-parallel-execution-opt-in","title":"Phase 2: Parallel Execution (Opt-In)","text":"<ul> <li>Add configuration option for parallel execution</li> <li>Default to sequential for safety</li> <li>Allow users to opt-in</li> </ul>"},{"location":"contribution/help_wanted/#phase-3-parallel-by-default","title":"Phase 3: Parallel by Default","text":"<ul> <li>Make parallel execution the default</li> <li>Keep sequential as fallback option</li> <li>Optimize based on real-world usage</li> </ul>"},{"location":"contribution/help_wanted/#files-to-modify_1","title":"Files to Modify","text":"<p>Core Strategy System:</p> <ul> <li><code>optics_framework/common/strategies.py</code> - Add parallel execution support</li> <li><code>optics_framework/common/execution.py</code> - Update execution flow</li> </ul> <p>Strategy Implementations:</p> <ul> <li><code>optics_framework/common/strategies.py</code> - Update all strategy classes</li> <li>All element source implementations - Add async support</li> </ul> <p>Configuration:</p> <ul> <li><code>optics_framework/common/config_handler.py</code> - Add parallel execution config</li> <li><code>optics_framework/common/models.py</code> - Add configuration models</li> </ul> <p>New Files:</p> <ul> <li><code>optics_framework/common/parallel_strategy_executor.py</code> - Parallel executor</li> <li><code>optics_framework/common/strategy_dependencies.py</code> - Dependency management</li> </ul>"},{"location":"contribution/help_wanted/#related-documentation_1","title":"Related Documentation","text":"<ul> <li>Strategy Pattern</li> <li>Execution Architecture</li> </ul>"},{"location":"contribution/help_wanted/#challenges-and-considerations","title":"Challenges and Considerations","text":""},{"location":"contribution/help_wanted/#challenge-1-resource-conflicts","title":"Challenge 1: Resource Conflicts","text":"<p>Problem: Multiple strategies accessing the same resource (driver, page source) simultaneously</p> <p>Solution: - Use asyncio locks for shared resources - Group strategies by resource type - Serialize access to shared resources</p>"},{"location":"contribution/help_wanted/#challenge-2-backward-compatibility","title":"Challenge 2: Backward Compatibility","text":"<p>Problem: Existing code expects synchronous strategy execution</p> <p>Solution: - Maintain sync wrappers for async methods - Use <code>run_async()</code> utility for compatibility - Gradual migration path</p>"},{"location":"contribution/help_wanted/#challenge-3-error-handling","title":"Challenge 3: Error Handling","text":"<p>Problem: Multiple strategies may fail in parallel</p> <p>Solution: - Aggregate all exceptions - Return most informative error - Log all strategy attempts</p>"},{"location":"contribution/help_wanted/#challenge-4-performance-tuning","title":"Challenge 4: Performance Tuning","text":"<p>Problem: Too many parallel tasks may degrade performance</p> <p>Solution: - Configurable max parallel strategies - Resource-aware task scheduling - Monitor and optimize based on metrics</p>"},{"location":"contribution/help_wanted/#challenge-5-ensuring-single-action-execution","title":"Challenge 5: Ensuring Single Action Execution","text":"<p>Problem: Multiple strategies might try to execute the same keyword/action</p> <p>Solution: - Implement strict abort mechanism when first strategy succeeds - Use cancellation tokens to immediately stop remaining strategies - Only allow the winning strategy to proceed to action execution - Add validation to prevent duplicate actions - Implement proper cleanup for aborted strategies</p>"},{"location":"contribution/help_wanted/#3-flexible-driver-specific-strategies","title":"3. Flexible Driver-Specific Strategies","text":"<p>Priority: High | Difficulty: Intermediate</p>"},{"location":"contribution/help_wanted/#current-state_2","title":"Current State","text":"<p>Strategies are generic and work across all drivers. Driver-specific capabilities (Playwright roles, CSS selectors) are not leveraged, limiting the framework's ability to use the best features of each driver.</p>"},{"location":"contribution/help_wanted/#goal_2","title":"Goal","text":"<p>Enable custom strategies that are specific to individual drivers, allowing each driver to expose its unique capabilities while maintaining the fallback mechanism.</p>"},{"location":"contribution/help_wanted/#key-areas_1","title":"Key Areas","text":""},{"location":"contribution/help_wanted/#playwright-specific-strategies","title":"Playwright-Specific Strategies","text":"<p>Playwright provides powerful locator methods that are not currently used:</p> <ul> <li><code>get_by_role()</code> - Locate by ARIA role (button, textbox, etc.)</li> <li><code>get_by_test_id()</code> - Locate by test ID attribute</li> <li><code>get_by_label()</code> - Locate by associated label</li> <li><code>get_by_placeholder()</code> - Locate by placeholder text</li> <li><code>get_by_text()</code> - Locate by visible text</li> <li><code>get_by_title()</code> - Locate by title attribute</li> <li><code>get_by_alt_text()</code> - Locate by alt text (for images)</li> </ul> <p>Example:</p> <pre><code># Current: Generic text strategy\nelement = \"Submit Button\"\n\n# With Playwright role strategy:\nelement = \"role:button[name='Submit']\"\n</code></pre>"},{"location":"contribution/help_wanted/#seleniumplaywright-css-strategies","title":"Selenium/Playwright CSS Strategies","text":"<p>Currently only XPath is supported. CSS selectors are more performant and readable:</p> <ul> <li>CSS selector support (not just XPath)</li> <li>CSS pseudo-selectors (<code>:first-child</code>, <code>:nth-of-type</code>, etc.)</li> <li>CSS attribute selectors (<code>[data-testid=\"submit\"]</code>)</li> </ul>"},{"location":"contribution/help_wanted/#appium-specific-strategies","title":"Appium-Specific Strategies","text":"<ul> <li>UI Automator selectors (Android)</li> <li>iOS predicate strings</li> <li>Accessibility ID strategies</li> <li>Class name strategies</li> </ul>"},{"location":"contribution/help_wanted/#strategy-registration","title":"Strategy Registration","text":"<p>Needed:</p> <ul> <li>Driver-specific strategy factory</li> <li>Strategy priority per driver</li> <li>Dynamic strategy discovery mechanism</li> <li>Strategy registration API for drivers</li> </ul>"},{"location":"contribution/help_wanted/#files-to-modify_2","title":"Files to Modify","text":"<ul> <li><code>optics_framework/common/strategies.py</code> - Add driver-specific strategy support</li> <li><code>optics_framework/engines/drivers/playwright.py</code> - Add Playwright-specific strategies</li> <li><code>optics_framework/engines/drivers/selenium.py</code> - Add CSS selector strategies</li> <li><code>optics_framework/engines/drivers/appium.py</code> - Add Appium-specific strategies</li> </ul>"},{"location":"contribution/help_wanted/#related-documentation_2","title":"Related Documentation","text":"<ul> <li>Strategy Pattern</li> <li>Extending the Framework</li> </ul>"},{"location":"contribution/help_wanted/#4-additional-image-detection-drivers","title":"4. Additional Image Detection Drivers","text":"<p>Priority: Medium | Difficulty: Intermediate to Advanced</p>"},{"location":"contribution/help_wanted/#current-state_3","title":"Current State","text":"<p>Only two image detection models are available: - TemplateMatch (OpenCV-based) - Local template matching - RemoteOIR (Remote service) - Remote object image recognition</p>"},{"location":"contribution/help_wanted/#goal_3","title":"Goal","text":"<p>Add more image detection/vision models to provide users with more options, better accuracy, and different use cases.</p>"},{"location":"contribution/help_wanted/#potential-additions","title":"Potential Additions","text":""},{"location":"contribution/help_wanted/#yolo-integration","title":"YOLO Integration","text":"<p>Object detection using YOLO (You Only Look Once) models: - Real-time object detection - Pre-trained models for UI elements - Custom model support</p> <p>File to Create: <code>optics_framework/engines/vision_models/image_models/yolo.py</code></p>"},{"location":"contribution/help_wanted/#cloud-vision-services","title":"Cloud Vision Services","text":"<ul> <li>AWS Rekognition: Amazon's image recognition service</li> <li>Azure Computer Vision: Microsoft's vision API</li> <li>Google Cloud Vision: Google's image analysis API (for object detection, not just OCR)</li> </ul> <p>Files to Create: - <code>optics_framework/engines/vision_models/image_models/aws_rekognition.py</code> - <code>optics_framework/engines/vision_models/image_models/azure_vision.py</code> - <code>optics_framework/engines/vision_models/image_models/google_vision_detection.py</code></p>"},{"location":"contribution/help_wanted/#deep-learning-models","title":"Deep Learning Models","text":"<ul> <li>TensorFlow/PyTorch Models: Support for custom trained models</li> <li>Pre-trained models for UI element detection</li> <li>Model loading and inference</li> </ul> <p>File to Create: <code>optics_framework/engines/vision_models/image_models/tensorflow_model.py</code></p>"},{"location":"contribution/help_wanted/#advanced-opencv-algorithms","title":"Advanced OpenCV Algorithms","text":"<ul> <li>ORB (Oriented FAST and Rotated BRIEF)</li> <li>BRISK (Binary Robust Invariant Scalable Keypoints)</li> <li>AKAZE (Accelerated-KAZE)</li> <li>Feature matching alternatives to SIFT</li> </ul>"},{"location":"contribution/help_wanted/#implementation-guidelines","title":"Implementation Guidelines","text":"<p>All image detection models must implement the <code>ImageInterface</code>:</p> <pre><code>from optics_framework.common.image_interface import ImageInterface\n\nclass YourImageDetection(ImageInterface):\n    def find_element(self, frame, element, index=0):\n        # Implementation\n        pass\n\n    def element_exist(self, frame, element):\n        # Implementation\n        pass\n\n    def assert_elements(self, frame, elements, rule=\"all\"):\n        # Implementation\n        pass\n</code></pre>"},{"location":"contribution/help_wanted/#files-to-create","title":"Files to Create","text":"<ul> <li><code>optics_framework/engines/vision_models/image_models/yolo.py</code></li> <li><code>optics_framework/engines/vision_models/image_models/aws_rekognition.py</code></li> <li><code>optics_framework/engines/vision_models/image_models/azure_vision.py</code></li> <li><code>optics_framework/engines/vision_models/image_models/tensorflow_model.py</code></li> </ul>"},{"location":"contribution/help_wanted/#related-documentation_3","title":"Related Documentation","text":"<ul> <li>Vision Models</li> <li>Extending Vision Models</li> </ul>"},{"location":"contribution/help_wanted/#5-interactive-test-creation","title":"5. Interactive Test Creation","text":"<p>Priority: Medium | Difficulty: Advanced</p>"},{"location":"contribution/help_wanted/#current-state_4","title":"Current State","text":"<p>Tests are created via CSV/YAML files or programmatically. There's no interactive test authoring tool, making it difficult for non-technical users to create tests.</p>"},{"location":"contribution/help_wanted/#goal_4","title":"Goal","text":"<p>Support interactive test creation where users can: - Record interactions automatically - Visually select elements on screen - Generate test steps automatically - Edit tests in a visual interface - Preview test execution step-by-step</p>"},{"location":"contribution/help_wanted/#key-features","title":"Key Features","text":""},{"location":"contribution/help_wanted/#test-recorder","title":"Test Recorder","text":"<p>Record user interactions and generate test steps: - Capture mouse clicks, keyboard input, scrolls - Automatically detect element locators - Generate test steps in CSV/YAML format - Support for multiple strategies (XPath, text, image)</p>"},{"location":"contribution/help_wanted/#visual-element-selector","title":"Visual Element Selector","text":"<p>Click on screen to select elements: - Highlight elements on hover - Show element information (XPath, text, attributes) - Suggest multiple locator strategies - Validate element locators</p>"},{"location":"contribution/help_wanted/#test-editor","title":"Test Editor","text":"<p>Visual editor for test cases: - Drag-and-drop test step reordering - Edit step parameters - Add/remove test steps - Preview test structure</p>"},{"location":"contribution/help_wanted/#element-inspector","title":"Element Inspector","text":"<p>Inspect and validate element locators: - Show all available locators for an element - Test locator validity - Suggest better locators - Show element hierarchy</p>"},{"location":"contribution/help_wanted/#potential-implementation","title":"Potential Implementation","text":"<ul> <li>Web-based UI: React/Vue.js frontend with FastAPI backend</li> <li>Browser Extension: Chrome/Firefox extension for recording</li> <li>Desktop Application: Electron app for test authoring</li> <li>CLI Integration: Extend existing CLI with interactive mode</li> </ul>"},{"location":"contribution/help_wanted/#files-to-create_1","title":"Files to Create","text":"<ul> <li><code>optics_framework/helper/recorder.py</code> - Test recording functionality</li> <li><code>optics_framework/helper/inspector.py</code> - Element inspection tools</li> <li><code>optics_framework/api/recorder_api.py</code> - API endpoints for recorder</li> <li>Web UI components (separate repo or <code>optics_framework/web_ui/</code>)</li> </ul>"},{"location":"contribution/help_wanted/#related-documentation_4","title":"Related Documentation","text":"<ul> <li>CLI Usage</li> <li>User Workflow</li> </ul>"},{"location":"contribution/help_wanted/#6-code-simplification-unification","title":"6. Code Simplification &amp; Unification","text":"<p>Priority: Medium | Difficulty: Intermediate</p>"},{"location":"contribution/help_wanted/#current-state_5","title":"Current State","text":"<p>Analysis reveals several areas with duplicate code and similar patterns that could be unified to reduce maintenance burden and improve code quality.</p>"},{"location":"contribution/help_wanted/#areas-identified","title":"Areas Identified","text":""},{"location":"contribution/help_wanted/#driver-method-patterns","title":"Driver Method Patterns","text":"<p>Similar implementations across Appium, Selenium, and Playwright: - <code>press_element()</code>, <code>enter_text()</code>, <code>clear_text()</code>, <code>scroll()</code> have similar patterns - Common error handling - Similar event logging</p> <p>Files:</p> <ul> <li><code>optics_framework/engines/drivers/appium.py</code></li> <li><code>optics_framework/engines/drivers/selenium.py</code></li> <li><code>optics_framework/engines/drivers/playwright.py</code></li> </ul> <p>Solution: Create base driver mixins or helper classes</p>"},{"location":"contribution/help_wanted/#element-source-patterns","title":"Element Source Patterns","text":"<p>Similar code in find_element, page_source, screenshot classes: - Common initialization patterns - Similar error handling - Common interface implementations</p> <p>Files: <code>optics_framework/engines/elementsources/*.py</code></p> <p>Solution: Create common base class for element source implementations</p>"},{"location":"contribution/help_wanted/#vision-model-patterns","title":"Vision Model Patterns","text":"<p>OCR models share similar structure: - Common text detection patterns - Similar configuration handling - Common error handling</p> <p>Files: <code>optics_framework/engines/vision_models/ocr_models/*.py</code></p> <p>Solution: Enhanced base classes for vision models</p>"},{"location":"contribution/help_wanted/#strategy-factory-pattern","title":"Strategy Factory Pattern","text":"<p>Current implementation has hard-coded strategy registry: - Strategy registration is static - Limited flexibility for custom strategies</p> <p>File: <code>optics_framework/common/strategies.py</code></p> <p>Solution: Make strategy registration more flexible and dynamic</p>"},{"location":"contribution/help_wanted/#session-management","title":"Session Management","text":"<p>Complex builder pattern could be simplified: - Many intermediate steps - Could use simpler factory pattern in some cases</p> <p>File: <code>optics_framework/common/optics_builder.py</code></p> <p>Solution: Simplify builder pattern or add convenience methods</p>"},{"location":"contribution/help_wanted/#specific-unification-opportunities","title":"Specific Unification Opportunities","text":"<ol> <li>Base Driver Mixin: Create <code>BaseWebDriverMixin</code> for common web driver methods</li> <li>Element Source Base: Common base class for element source implementations</li> <li>Vision Model Base: Enhanced base classes for vision models</li> <li>Strategy Registry: Make strategy registration more flexible</li> <li>Configuration Normalization: Unify configuration handling across components</li> <li>Error Handling Utilities: Standardize error handling patterns</li> </ol>"},{"location":"contribution/help_wanted/#files-to-createmodify","title":"Files to Create/Modify","text":"<p>Create: - <code>optics_framework/common/base_driver_mixin.py</code> - Common driver methods - <code>optics_framework/common/base_element_source.py</code> - Common element source base - <code>optics_framework/common/error_utils.py</code> - Error handling utilities</p> <p>Modify: - <code>optics_framework/common/strategies.py</code> - Flexible strategy registration - <code>optics_framework/common/optics_builder.py</code> - Simplify builder pattern - All driver implementations to use mixins - All element source implementations to use base class</p>"},{"location":"contribution/help_wanted/#related-documentation_5","title":"Related Documentation","text":"<ul> <li>Architecture Overview</li> <li>Extending the Framework</li> </ul>"},{"location":"contribution/help_wanted/#7-test-coverage","title":"7. Test Coverage","text":"<p>Priority: High | Difficulty: Beginner to Intermediate</p>"},{"location":"contribution/help_wanted/#current-state_6","title":"Current State","text":"<p>Current test structure shows limited coverage. Many core components lack comprehensive tests.</p>"},{"location":"contribution/help_wanted/#missing-tests-for","title":"Missing Tests For","text":"<ul> <li>Most engine implementations (drivers, element sources, vision models)</li> <li>Strategy manager and location strategies</li> <li>Event system and event handlers</li> <li>Session management edge cases</li> <li>Error handling scenarios</li> <li>Factory pattern implementations</li> <li>Screenshot streaming</li> <li>API layer endpoints</li> <li>CLI commands</li> </ul>"},{"location":"contribution/help_wanted/#test-files-to-create","title":"Test Files to Create","text":""},{"location":"contribution/help_wanted/#unit-tests_1","title":"Unit Tests","text":"<ul> <li><code>tests/units/engines/drivers/test_ble.py</code> - BLE driver tests</li> <li><code>tests/units/engines/drivers/test_playwright.py</code> - Playwright driver tests</li> <li><code>tests/units/engines/drivers/test_appium.py</code> - Appium driver tests (if missing)</li> <li><code>tests/units/engines/elementsources/test_playwright_find_element.py</code></li> <li><code>tests/units/engines/elementsources/test_playwright_page_source.py</code></li> <li><code>tests/units/engines/elementsources/test_playwright_screenshot.py</code></li> <li><code>tests/units/common/test_strategies.py</code> - Strategy manager tests</li> <li><code>tests/units/common/test_session_manager.py</code> - Session management tests</li> <li><code>tests/units/common/test_screenshot_stream.py</code> - Screenshot streaming tests</li> <li><code>tests/units/api/test_verifier.py</code> - Verifier API tests</li> <li><code>tests/units/common/test_factories.py</code> - Factory pattern tests</li> </ul>"},{"location":"contribution/help_wanted/#integration-tests_1","title":"Integration Tests","text":"<ul> <li><code>tests/integration/test_api_endpoints.py</code> - API endpoint integration tests</li> <li><code>tests/integration/test_session_lifecycle.py</code> - Full session lifecycle</li> <li><code>tests/integration/test_driver_fallback.py</code> - Driver fallback mechanism</li> </ul>"},{"location":"contribution/help_wanted/#functional-tests","title":"Functional Tests","text":"<ul> <li><code>tests/functional/test_end_to_end.py</code> - End-to-end test execution</li> <li><code>tests/functional/test_vision_detection.py</code> - Vision detection workflows</li> </ul>"},{"location":"contribution/help_wanted/#testing-guidelines","title":"Testing Guidelines","text":"<ul> <li>Use <code>pytest</code> for all tests</li> <li>Follow existing test patterns in <code>tests/units/</code></li> <li>Use fixtures from <code>tests/units/conftest.py</code></li> <li>Aim for &gt;80% code coverage</li> <li>Test both success and failure scenarios</li> <li>Include edge cases and error conditions</li> </ul>"},{"location":"contribution/help_wanted/#related-documentation_6","title":"Related Documentation","text":"<ul> <li>Developer Guide</li> <li>Architecture Overview</li> </ul>"},{"location":"contribution/help_wanted/#8-security-improvements","title":"8. Security Improvements","text":"<p>Priority: High | Difficulty: Intermediate</p>"},{"location":"contribution/help_wanted/#current-state_7","title":"Current State","text":"<p>From <code>docs/architecture/api_layer.md</code>, several security improvements are needed for production use.</p>"},{"location":"contribution/help_wanted/#cors-configuration","title":"CORS Configuration","text":"<p>Current: CORS allows all origins (<code>allow_origins=[\"*\"]</code>)</p> <p>Needed: Configurable CORS with environment-based restrictions</p> <p>File: <code>optics_framework/common/expose_api.py</code></p> <p>Implementation: <pre><code># Allow configuration via environment variables\nallowed_origins = os.getenv(\"OPTICS_CORS_ORIGINS\", \"*\").split(\",\")\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=allowed_origins if \"*\" not in allowed_origins else [\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n</code></pre></p>"},{"location":"contribution/help_wanted/#authentication","title":"Authentication","text":"<p>Current: No authentication currently</p> <p>Needed: - API key authentication - Bearer token authentication - Session-based authentication</p> <p>Files to Modify: - <code>optics_framework/common/expose_api.py</code> - Add authentication middleware - <code>optics_framework/common/auth.py</code> - Create authentication module (new file)</p>"},{"location":"contribution/help_wanted/#input-validation","title":"Input Validation","text":"<p>Current: Using Pydantic for validation</p> <p>Enhancements Needed: - Rate limiting per IP/session - Request size limits - SQL injection prevention (if adding database support) - XSS prevention for string inputs</p>"},{"location":"contribution/help_wanted/#related-documentation_7","title":"Related Documentation","text":"<ul> <li>REST API Layer</li> <li>Security Policy</li> </ul>"},{"location":"contribution/help_wanted/#9-feature-development","title":"9. Feature Development","text":"<p>Priority: Medium to High | Difficulty: Intermediate to Advanced</p>"},{"location":"contribution/help_wanted/#mcp-servicer","title":"MCP Servicer","text":"<p>From Roadmap: Introduce a dedicated service to handle MCP (Model Context Protocol)</p> <p>Goal: Improve scalability and modularity across the framework</p> <p>Needed: - MCP protocol implementation - Service architecture design - Integration with existing framework</p>"},{"location":"contribution/help_wanted/#omniparser-integration","title":"Omniparser Integration","text":"<p>From Roadmap: Seamlessly integrate Omniparser for robust and flexible element extraction and location</p> <p>Goal: Enable more flexible element parsing capabilities</p> <p>Needed: - Omniparser library integration - Parser configuration - Strategy integration</p>"},{"location":"contribution/help_wanted/#playwright-integration-enhancements","title":"Playwright Integration Enhancements","text":"<p>From Roadmap: Add support for Playwright (partially implemented)</p> <p>Needed: - Complete remaining Playwright methods - Add driver-specific strategies (see section 2) - Improve error handling</p>"},{"location":"contribution/help_wanted/#audio-support","title":"Audio Support","text":"<p>From Roadmap: Extend the framework to support audio inputs and outputs</p> <p>Goal: Enable testing and verification of voice-based or sound-related interactions</p> <p>Needed: - Audio input capture - Audio output verification - Speech recognition integration - Audio comparison utilities</p>"},{"location":"contribution/help_wanted/#session-persistence","title":"Session Persistence","text":"<p>Identified in: <code>docs/architecture/components.md</code></p> <p>Current: Sessions are in-memory only, lost on process termination</p> <p>Needed: - Session serialization - Session recovery on restart - Session state snapshots - Persistent storage backend</p> <p>Note: This overlaps with section 1 (Stateless API Layer) but focuses on persistence rather than migration.</p>"},{"location":"contribution/help_wanted/#additional-drivers","title":"Additional Drivers","text":"<ul> <li>iOS driver enhancements</li> <li>Additional browser drivers (Edge, Safari)</li> <li>IoT device drivers</li> <li>Desktop application drivers (Windows, macOS, Linux)</li> </ul>"},{"location":"contribution/help_wanted/#10-performance-optimizations","title":"10. Performance Optimizations","text":"<p>Priority: Medium | Difficulty: Intermediate</p>"},{"location":"contribution/help_wanted/#areas-identified_1","title":"Areas Identified","text":""},{"location":"contribution/help_wanted/#screenshot-streaming","title":"Screenshot Streaming","text":"<p>Current: SSIM computation overhead could be optimized</p> <p>Opportunities: - Parallel SSIM computation - Optimize image comparison algorithms - Cache comparison results - Use faster similarity metrics where appropriate</p> <p>File: <code>optics_framework/common/screenshot_stream.py</code></p>"},{"location":"contribution/help_wanted/#strategy-execution","title":"Strategy Execution","text":"<p>Current: Strategies executed sequentially</p> <p>Opportunities: - Parallel strategy attempts where safe - Early exit optimization - Strategy result caching</p> <p>File: <code>optics_framework/common/strategies.py</code></p>"},{"location":"contribution/help_wanted/#factory-caching","title":"Factory Caching","text":"<p>Current: Instance caching implemented</p> <p>Enhancements: - Cache invalidation strategies - Memory-aware caching - Cache size limits</p> <p>File: <code>optics_framework/common/base_factory.py</code></p>"},{"location":"contribution/help_wanted/#event-processing","title":"Event Processing","text":"<p>Current: Events processed individually</p> <p>Opportunities: - Batch events for better throughput - Async event processing - Event queue optimization</p> <p>Files: - <code>optics_framework/common/events.py</code> - <code>optics_framework/common/eventSDK.py</code></p>"},{"location":"contribution/help_wanted/#image-processing","title":"Image Processing","text":"<p>Current: OCR and template matching operations</p> <p>Opportunities: - Parallel image processing - Image caching - Optimize OpenCV operations - GPU acceleration where available</p> <p>Files: - <code>optics_framework/engines/vision_models/image_models/templatematch.py</code> - <code>optics_framework/engines/vision_models/ocr_models/*.py</code></p>"},{"location":"contribution/help_wanted/#related-documentation_8","title":"Related Documentation","text":"<ul> <li>Architecture Decisions</li> <li>Performance Considerations</li> </ul>"},{"location":"contribution/help_wanted/#11-documentation","title":"11. Documentation","text":"<p>Priority: Medium | Difficulty: Beginner to Intermediate</p>"},{"location":"contribution/help_wanted/#documentation-gaps","title":"Documentation Gaps","text":""},{"location":"contribution/help_wanted/#api-examples","title":"API Examples","text":"<p>Current: API reference exists but lacks practical examples</p> <p>Needed: - More code examples in API reference - Common use case examples - Error handling examples</p> <p>Files: <code>docs/api_reference.md</code> (Python API) and <code>docs/usage/REST_API_usage.md</code> (REST API)</p>"},{"location":"contribution/help_wanted/#troubleshooting-guides","title":"Troubleshooting Guides","text":"<p>Current: Limited troubleshooting information</p> <p>Needed: - Common issues and solutions - Debugging guides - Performance troubleshooting - Error code reference with solutions</p>"},{"location":"contribution/help_wanted/#performance-tuning","title":"Performance Tuning","text":"<p>Needed: Guide for optimizing framework performance</p> <p>Topics: - Configuration optimization - Strategy selection guidance - Memory management - Parallel execution tips</p>"},{"location":"contribution/help_wanted/#migration-guides","title":"Migration Guides","text":"<p>Needed: When breaking changes occur</p> <p>Topics: - Version migration guides - Configuration migration - API migration guides</p>"},{"location":"contribution/help_wanted/#video-tutorials","title":"Video Tutorials","text":"<p>Needed: Screen recordings for complex workflows</p> <p>Topics: - Getting started walkthrough - Creating your first test - Advanced features - Troubleshooting common issues</p>"},{"location":"contribution/help_wanted/#best-practices","title":"Best Practices","text":"<p>Needed: Comprehensive best practices guide</p> <p>Topics: - Test design patterns - Element locator best practices - Configuration management - CI/CD integration - Error handling strategies</p>"},{"location":"contribution/help_wanted/#integration-examples","title":"Integration Examples","text":"<p>Needed: Examples with CI/CD systems</p> <p>Examples: - GitHub Actions - Jenkins - GitLab CI - Azure DevOps - CircleCI</p>"},{"location":"contribution/help_wanted/#related-documentation_9","title":"Related Documentation","text":"<ul> <li>Contributing Guidelines</li> <li>Developer Guide</li> </ul>"},{"location":"contribution/help_wanted/#12-infrastructure","title":"12. Infrastructure","text":"<p>Priority: Low to Medium | Difficulty: Intermediate</p>"},{"location":"contribution/help_wanted/#cicd-enhancements","title":"CI/CD Enhancements","text":""},{"location":"contribution/help_wanted/#test-coverage-reporting","title":"Test Coverage Reporting","text":"<p>Needed:</p> <ul> <li>Automated coverage reports</li> <li>Coverage badges</li> <li>Coverage trend tracking</li> <li>Coverage thresholds</li> </ul>"},{"location":"contribution/help_wanted/#performance-benchmarking","title":"Performance Benchmarking","text":"<p>Needed:</p> <ul> <li>Automated performance tests</li> <li>Performance regression detection</li> <li>Benchmark comparisons</li> <li>Performance reports</li> </ul>"},{"location":"contribution/help_wanted/#security-scanning-automation","title":"Security Scanning Automation","text":"<p>Needed:</p> <ul> <li>Automated dependency scanning</li> <li>Code security scanning</li> <li>Container security scanning</li> <li>Automated security updates</li> </ul>"},{"location":"contribution/help_wanted/#tooling","title":"Tooling","text":""},{"location":"contribution/help_wanted/#pre-commit-hooks-enhancements","title":"Pre-commit Hooks Enhancements","text":"<p>Current: Basic hooks in place</p> <p>Enhancements:</p> <ul> <li>Additional linting rules</li> <li>Documentation checks</li> <li>Test coverage checks</li> <li>Commit message validation improvements</li> </ul>"},{"location":"contribution/help_wanted/#code-quality-metrics-dashboard","title":"Code Quality Metrics Dashboard","text":"<p>Needed:</p> <ul> <li>Code quality metrics</li> <li>Technical debt tracking</li> <li>Code complexity metrics</li> <li>Maintainability index</li> </ul>"},{"location":"contribution/help_wanted/#dependency-update-automation","title":"Dependency Update Automation","text":"<p>Needed:</p> <ul> <li>Automated dependency updates</li> <li>Security update prioritization</li> <li>Update testing automation</li> <li>Changelog generation</li> </ul>"},{"location":"contribution/help_wanted/#related-documentation_10","title":"Related Documentation","text":"<ul> <li>Developer Guide</li> <li>CI/CD Workflows</li> </ul>"},{"location":"contribution/help_wanted/#getting-started","title":"Getting Started","text":""},{"location":"contribution/help_wanted/#choose-an-area","title":"Choose an Area","text":"<ol> <li>Review the sections above and identify an area that interests you</li> <li>Check the priority and difficulty levels</li> <li>Review related documentation</li> <li>Look at existing code to understand patterns</li> </ol>"},{"location":"contribution/help_wanted/#before-you-start","title":"Before You Start","text":"<ol> <li>Read the Contributing Guidelines</li> <li>Read the Developer Guide</li> <li>Set up your development environment</li> <li>Familiarize yourself with the codebase</li> </ol>"},{"location":"contribution/help_wanted/#making-your-contribution","title":"Making Your Contribution","text":"<ol> <li>Fork the Repository: Create your own fork</li> <li>Create a Branch: Use a descriptive branch name</li> <li>Make Changes: Follow coding standards and patterns</li> <li>Write Tests: Add tests for your changes</li> <li>Update Documentation: Update relevant docs</li> <li>Submit PR: Create a pull request with clear description</li> </ol>"},{"location":"contribution/help_wanted/#need-help","title":"Need Help?","text":"<ul> <li>Open an issue on GitHub for questions</li> <li>Check existing documentation</li> <li>Review similar implementations in the codebase</li> <li>Ask in pull request comments</li> </ul>"},{"location":"contribution/help_wanted/#recognition","title":"Recognition","text":"<p>Contributors will be: - Listed in the project's contributors - Credited in release notes - Acknowledged in documentation (for significant contributions)</p>"},{"location":"contribution/help_wanted/#summary","title":"Summary","text":"<p>This document outlines many opportunities to improve the Optics Framework. Whether you're interested in:</p> <ul> <li>Architecture: Stateless API, flexible strategies</li> <li>Features: New drivers, interactive tools</li> <li>Quality: Tests, documentation, code simplification</li> <li>Performance: Optimizations and enhancements</li> <li>Security: Authentication, validation, hardening</li> </ul> <p>There's something for everyone. We appreciate your interest in contributing and look forward to your contributions!</p> <p>Start Small</p> <p>If you're new to the project, consider starting with documentation improvements or test coverage. These are great ways to learn the codebase while making valuable contributions.</p>"},{"location":"usage/CLI_usage/","title":"CLI Guide","text":"<p>This section describes the available commands for the Optics Framework CLI. The command you run is <code>optics</code>; the package you install is <code>optics-framework</code> (e.g. <code>pip install optics-framework</code>).</p>"},{"location":"usage/CLI_usage/#setup-optics-framework","title":"Setup Optics Framework","text":"<p>To set up the Optics Framework, use the following command:</p> <p>To list all possible drivers:</p> <pre><code>optics setup --list\n</code></pre> <p>TUI way:</p> <pre><code>optics setup\n</code></pre> <p>CLI way:</p> <pre><code>optics setup --install &lt;driver_name1&gt; &lt;driver_name2&gt; ...\n</code></pre>"},{"location":"usage/CLI_usage/#executing-test-cases","title":"Executing Test Cases","text":"<p>Run test cases from a project folder. The runner discovers test cases (and modules, elements, config) from that folder:</p> <pre><code>optics execute &lt;folder_path&gt; [--runner &lt;runner_name&gt;] [--use-printer | --no-use-printer]\n</code></pre> <p>Options:</p> <ul> <li><code>&lt;folder_path&gt;</code>: Path to the project directory (contains <code>test_cases.csv</code>, <code>test_modules.csv</code>, <code>config.yaml</code>, etc.).</li> <li><code>--runner &lt;runner_name&gt;</code>: Test runner to use. Supported: <code>test_runner</code> (default), <code>pytest</code>.</li> <li><code>--use-printer</code> (default): Enable live result printer.</li> <li><code>--no-use-printer</code>: Disable live result printer.</li> </ul>"},{"location":"usage/CLI_usage/#initializing-a-new-project","title":"Initializing a New Project","text":"<p>Use the following command to initialize a new project:</p> <pre><code>optics init --name &lt;project_name&gt; --path &lt;directory&gt; --template &lt;sample_name&gt; --git-init\n</code></pre> <p>Options:</p> <ul> <li><code>--name &lt;project_name&gt;</code>: Name of the project (required).</li> <li><code>--path &lt;directory&gt;</code>: Directory to create the project in (default: current directory).</li> <li><code>--template &lt;sample_name&gt;</code>: Copy files from a predefined sample. See Templates below.</li> <li><code>--force</code>: Overwrite an existing project directory if it exists.</li> <li><code>--git-init</code>: Initialize a Git repository in the project.</li> </ul>"},{"location":"usage/CLI_usage/#templates","title":"Templates","text":"<p>Use <code>--template &lt;name&gt;</code> to copy a sample layout and assets from <code>optics_framework/samples/</code>. Available template names include:</p> <ul> <li><code>contact</code> \u2014 Contact/sample layout</li> <li><code>clock</code> \u2014 Clock app sample</li> <li><code>youtube</code> \u2014 YouTube sample</li> <li><code>gmail_web</code> \u2014 Gmail web sample</li> <li><code>calendar</code> \u2014 Calendar sample</li> </ul> <p>Exact values depend on the directories under <code>optics_framework/samples/</code>. Use only names that exist as subdirectories there.</p>"},{"location":"usage/CLI_usage/#generating-code","title":"Generating Code","text":"<p>Generate test automation code from a project's test data (test cases, modules, config):</p> <pre><code>optics generate &lt;project_path&gt; [--output &lt;output_file&gt;] [--framework pytest|robot]\n</code></pre> <p>Options:</p> <ul> <li><code>&lt;project_path&gt;</code>: Path to the project folder (containing test case and module data).</li> <li><code>--output &lt;path&gt;</code>: Output file path. Defaults to <code>test_generated.py</code> (pytest) or <code>test_generated.robot</code> (robot).</li> <li><code>--framework</code>: <code>pytest</code> (default) or <code>robot</code>.</li> </ul>"},{"location":"usage/CLI_usage/#listing-available-keywords","title":"Listing Available Keywords","text":"<p>Display all available keywords and their parameters:</p> <pre><code>optics list\n</code></pre>"},{"location":"usage/CLI_usage/#executing-dry-run","title":"Executing Dry Run","text":"<p>Validate test cases without executing actions (keyword and parameter checks):</p> <pre><code>optics dry_run &lt;folder_path&gt; [--runner &lt;runner_name&gt;] [--use-printer | --no-use-printer]\n</code></pre> <p>Options:</p> <ul> <li><code>&lt;folder_path&gt;</code>: Path to the project directory.</li> <li><code>--runner &lt;runner_name&gt;</code>: Test runner to use (default: <code>test_runner</code>).</li> <li><code>--use-printer</code> (default): Enable live result printer.</li> <li><code>--no-use-printer</code>: Disable live result printer.</li> </ul>"},{"location":"usage/CLI_usage/#serving-the-rest-api","title":"Serving the REST API","text":"<p>Start the REST API server (e.g. for programmatic or remote use):</p> <pre><code>optics serve [--host &lt;host&gt;] [--port &lt;port&gt;] [--workers &lt;n&gt;]\n</code></pre> <p>Options:</p> <ul> <li><code>--host</code>: Host to bind (default: <code>127.0.0.1</code>).</li> <li><code>--port</code>: Port to bind (default: <code>8000</code>).</li> <li><code>--workers</code>: Number of worker processes (default: <code>1</code>).</li> </ul> <p>For endpoint details, request/response formats, and examples, see REST API Usage.</p>"},{"location":"usage/CLI_usage/#shell-autocompletion","title":"Shell autocompletion","text":"<p>Enable shell autocompletion for the <code>optics</code> command:</p> <pre><code>optics completion\n</code></pre> <p>This updates your shell RC (e.g. <code>.bashrc</code>, <code>.zshrc</code>) so that commands and arguments are completed when you press Tab.</p>"},{"location":"usage/CLI_usage/#showing-help-information","title":"Showing Help Information","text":"<p>Get help for the CLI:</p> <pre><code>optics --help\n</code></pre>"},{"location":"usage/CLI_usage/#managing-configuration","title":"Managing Configuration","text":"<p>Manage framework configuration:</p> <pre><code>optics config [--set &lt;key&gt; &lt;value&gt;] [--reset] [--list]\n</code></pre> <p>Options:</p> <ul> <li><code>--set &lt;key&gt; &lt;value&gt;</code>: Set a configuration key-value pair.</li> <li><code>--reset</code>: Reset all configurations to default.</li> <li><code>--list</code>: Display current configuration values.</li> </ul>"},{"location":"usage/CLI_usage/#checking-version","title":"Checking Version","text":"<p>Check the installed version:</p> <pre><code>optics --version\n</code></pre>"},{"location":"usage/CLI_usage/#additional-information","title":"Additional Information","text":"<p>Command name</p> <p>The CLI command is <code>optics</code>. The PyPI package is <code>optics-framework</code>. Install with <code>pip install optics-framework</code>; then run <code>optics</code> in your terminal.</p> <p>Optional parameters</p> <p>Options such as <code>--runner</code>, <code>--force</code>, and <code>--git-init</code> are optional. Omit them to use defaults (e.g. <code>test_runner</code> for <code>--runner</code>).</p> <p>Driver installation</p> <p>When using <code>optics setup --install</code>, use driver names listed by <code>optics setup --list</code>.</p> <p>Configuration persistence</p> <p>Configuration changed with <code>optics config --set</code> persists until you run <code>optics config --reset</code>.</p>"},{"location":"usage/REST_API_usage/","title":"REST API Usage","text":"<p>The Optics Framework provides a RESTful API for programmatic interaction with the framework. This API allows you to create sessions, execute keywords, capture screenshots, and manage test execution.</p>"},{"location":"usage/REST_API_usage/#base-url","title":"Base URL","text":"<p>The API is served via FastAPI and typically runs on <code>http://localhost:8000</code> by default.</p>"},{"location":"usage/REST_API_usage/#authentication","title":"Authentication","text":"<p>Currently, the API does not require authentication. CORS is enabled for all origins.</p>"},{"location":"usage/REST_API_usage/#response-format","title":"Response Format","text":"<p>All endpoints return JSON responses. Error responses follow this format:</p> <pre><code>{\n  \"detail\": \"Error message\"\n}\n</code></pre>"},{"location":"usage/REST_API_usage/#models","title":"Models","text":""},{"location":"usage/REST_API_usage/#sessionconfig","title":"SessionConfig","text":"<p>Configuration for starting a new Optics session.</p> <pre><code>{\n  \"driver_sources\": [\"appium\", \"selenium\"],\n  \"elements_sources\": [\"appium\"],\n  \"text_detection\": [\"easyocr\"],\n  \"image_detection\": [\"templatematch\"],\n  \"project_path\": \"/path/to/project\",\n}\n</code></pre> <p>Fields:</p> <ul> <li><code>driver_sources</code> (List[Union[str, Dict]]): List of driver sources. Can be strings like <code>[\"appium\"]</code> or detailed dicts like <code>[{\"appium\": {\"enabled\": true, \"url\": \"...\", \"capabilities\": {...}}}]</code></li> <li><code>elements_sources</code> (List[Union[str, Dict]]): List of element detection sources</li> <li><code>text_detection</code> (List[Union[str, Dict]]): List of text detection engines</li> <li><code>image_detection</code> (List[Union[str, Dict]]): List of image detection engines</li> <li><code>project_path</code> (Optional[str]): Path to the project directory</li> <li><code>api_data</code> (Optional[Dict]): Inline API definitions for use with the Invoke API keyword. A JSON object with the same shape as the API YAML content (top-level <code>\"api\"</code> key with <code>collections</code>, or the API content at root). File path is not supported in the REST API; use inline object only. Omit if you will add definitions later via Add API definitions.</li> <li><code>appium_url</code> (Optional[str]): Deprecated - Use driver_sources instead</li> <li><code>appium_config</code> (Optional[Dict]): Deprecated - Use driver_sources instead</li> </ul>"},{"location":"usage/REST_API_usage/#executerequest","title":"ExecuteRequest","text":"<p>Request model for executing a keyword or test case.</p> <pre><code>{\n  \"mode\": \"keyword\",\n  \"test_case\": null,\n  \"keyword\": \"press_element\",\n  \"params\": [\"button_login\"]\n}\n</code></pre> <p>Fields:</p> <ul> <li><code>mode</code> (str): Execution mode. Currently only <code>\"keyword\"</code> is supported</li> <li><code>test_case</code> (Optional[str]): Test case name (not currently used)</li> <li><code>keyword</code> (Optional[str]): Keyword name to execute</li> <li><code>params</code> (Union[List, Dict]): Parameters for the keyword. Can be:</li> <li>Positional: <code>[\"param1\", \"param2\"]</code></li> <li>Named: <code>{\"element\": \"button_login\", \"timeout\": \"30\"}</code></li> <li>Fallback values: <code>[\"value1\", \"value2\"]</code> or <code>[[\"value1a\", \"value1b\"], \"value2\"]</code></li> </ul>"},{"location":"usage/REST_API_usage/#sessionresponse","title":"SessionResponse","text":"<p>Response model for session creation.</p> <pre><code>{\n  \"session_id\": \"uuid-string\",\n  \"driver_id\": \"driver-session-id\",\n  \"status\": \"created\"\n}\n</code></pre>"},{"location":"usage/REST_API_usage/#executionresponse","title":"ExecutionResponse","text":"<p>Response model for execution results.</p> <pre><code>{\n  \"execution_id\": \"uuid-string\",\n  \"status\": \"SUCCESS\",\n  \"data\": {\n    \"result\": \"execution result\"\n  }\n}\n</code></pre>"},{"location":"usage/REST_API_usage/#executionevent","title":"ExecutionEvent","text":"<p>Event model for execution status updates (used in SSE streams).</p> <pre><code>{\n  \"execution_id\": \"uuid-string\",\n  \"status\": \"RUNNING\",\n  \"message\": \"Starting keyword: press_element\"\n}\n</code></pre>"},{"location":"usage/REST_API_usage/#keywordinfo","title":"KeywordInfo","text":"<p>Information about an available keyword.</p> <pre><code>{\n  \"keyword\": \"Press Element\",\n  \"keyword_slug\": \"press_element\",\n  \"description\": \"Taps on a given element with optional offset and repeat parameters.\",\n  \"parameters\": [\n    {\n      \"name\": \"element\",\n      \"type\": \"str\",\n      \"default\": null\n    },\n    {\n      \"name\": \"repeat\",\n      \"type\": \"int\",\n      \"default\": 1\n    }\n  ]\n}\n</code></pre>"},{"location":"usage/REST_API_usage/#endpoints","title":"Endpoints","text":""},{"location":"usage/REST_API_usage/#health-check","title":"Health Check","text":"<p>GET <code>/</code></p> <p>Check if the API is running.</p> <p>Response: <pre><code>{\n  \"status\": \"Optics Framework API is running\",\n  \"version\": \"1.7.14\"\n}\n</code></pre></p>"},{"location":"usage/REST_API_usage/#create-session","title":"Create Session","text":"<p>POST <code>/v1/sessions/start</code></p> <p>Create a new Optics session with the provided configuration.</p> <p>Request Body: <code>SessionConfig</code></p> <p>Response: <code>SessionResponse</code></p> <p>Example: <pre><code>curl -X POST \"http://localhost:8000/v1/sessions/start\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"driver_sources\": [{\"appium\": {\"enabled\": true, \"url\": \"http://127.0.0.1:4723/wd/hub\", \"capabilities\": {\"automationName\": \"UiAutomator2\", \"deviceName\": \"emulator-5554\", \"platformName\": \"Android\"}}}],\n    \"elements_sources\": [\"appium\"],\n    \"text_detection\": [\"easyocr\"],\n    \"image_detection\": [\"opencv\"]\n  }'\n</code></pre></p> <p>Notes</p> <ul> <li>Automatically executes <code>launch_app</code> keyword after session creation</li> <li>Returns both <code>session_id</code> and <code>driver_id</code> (the underlying driver session ID)</li> <li>If <code>appium_url</code> or <code>appium_config</code> are provided, a deprecation warning is logged</li> </ul>"},{"location":"usage/REST_API_usage/#execute-keyword","title":"Execute Keyword","text":"<p>POST <code>/v1/sessions/{session_id}/action</code></p> <p>Execute a keyword in the specified session. Supports both positional and named parameters with fallback support.</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Request Body: <code>ExecuteRequest</code></p> <ul> <li><code>mode</code> (str): Must be <code>\"keyword\"</code>.</li> <li><code>keyword</code> (str): Keyword name (e.g. <code>\"Press Element\"</code>).</li> <li><code>params</code>: Positional list or named dict of string parameters.</li> <li><code>template_images</code> (optional): Map of logical name \u2192 base64-encoded image. Use these names in <code>params</code> (e.g. <code>element</code>) for vision-based keywords. Values can be raw base64 or a data URL (<code>data:image/png;base64,...</code>). Inline images apply only to this request.</li> </ul> <p>Response: <code>ExecutionResponse</code></p> <p>Example with positional parameters: <pre><code>curl -X POST \"http://localhost:8000/v1/sessions/{session_id}/action\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"mode\": \"keyword\",\n    \"keyword\": \"Press Element\",\n    \"params\": [\"button_login\"]\n  }'\n</code></pre></p> <p>Example with named parameters: <pre><code>curl -X POST \"http://localhost:8000/v1/sessions/{session_id}/action\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"mode\": \"keyword\",\n    \"keyword\": \"Press Element\",\n    \"params\": {\n      \"element\": \"button_login\",\n      \"repeat\": \"2\"\n    }\n  }'\n</code></pre></p> <p>Example with fallback values: <pre><code>curl -X POST \"http://localhost:8000/v1/sessions/{session_id}/action\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"mode\": \"keyword\",\n    \"keyword\": \"Press Element\",\n    \"params\": [[\"button_login\", \"login_btn\"], \"1\"]\n  }'\n</code></pre></p> <p>Parameter Handling</p> <ul> <li>The API will try all combinations of fallback values until one succeeds</li> <li>If all combinations fail, an error is returned with details about each attempt</li> <li>Named parameters are converted to positional based on the method signature</li> </ul> <p>Example with inline template images (vision-based Press Element): <pre><code>curl -X POST \"http://localhost:8000/v1/sessions/{session_id}/action\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"mode\": \"keyword\",\n    \"keyword\": \"Press Element\",\n    \"params\": {\"element\": \"my_button\"},\n    \"template_images\": {\"my_button\": \"&lt;base64-encoded-png&gt;\"}\n  }'\n</code></pre> Use the same name in <code>params</code> (e.g. <code>element</code>) as in <code>template_images</code>. You can also register templates per session via Upload Template and reuse names across execute calls.</p>"},{"location":"usage/REST_API_usage/#upload-template","title":"Upload Template","text":"<p>POST <code>/v1/sessions/{session_id}/templates</code></p> <p>Upload a template image for the session. The given name can be used in execute <code>params</code> (e.g. <code>element</code>) for vision-based keywords. Overwrites if the name already exists. Files are removed when the session is terminated.</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Request Body: <code>{\"name\": \"&lt;logical-name&gt;\", \"image_base64\": \"&lt;base64-or-data-url&gt;\"}</code></p> <p>Response: <code>{\"name\": \"&lt;logical-name&gt;\", \"status\": \"ok\"}</code></p> <p>Example: <pre><code>curl -X POST \"http://localhost:8000/v1/sessions/{session_id}/templates\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"my_button\", \"image_base64\": \"&lt;base64-encoded-png&gt;\"}'\n</code></pre></p> <p>Then call execute with <code>\"params\": {\"element\": \"my_button\"}</code> (no need to send the image again).</p>"},{"location":"usage/REST_API_usage/#add-api-definitions-for-invoke-api","title":"Add API definitions (for Invoke API)","text":"<p>POST <code>/v1/sessions/{session_id}/api</code></p> <p>Add or replace API definitions for the session. Use this when you need to call the Invoke API keyword and did not supply <code>api_data</code> at session creation. The request body replaces the session's API data (same semantics as the Add API keyword).</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Request Body: A JSON object representing API data. Either a top-level <code>\"api\"</code> key with <code>collections</code> (and optional <code>global_defaults</code>), or the API content at root. Structure matches the API definition YAML format (e.g. <code>collections</code> \u2192 each collection has <code>name</code>, <code>base_url</code>, <code>global_headers</code>, <code>apis</code> \u2192 each API has <code>endpoint</code>, <code>request</code>, <code>expected_result</code>, etc.).</p> <p>Response: 204 No Content on success.</p> <p>Example: <pre><code>curl -X POST \"http://localhost:8000/v1/sessions/{session_id}/api\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"api\": {\n      \"collections\": {\n        \"auth\": {\n          \"name\": \"Auth APIs\",\n          \"base_url\": \"https://api.example.com\",\n          \"apis\": {\n            \"token\": {\n              \"name\": \"Get Token\",\n              \"endpoint\": \"/token\",\n              \"request\": { \"method\": \"POST\", \"body\": {\"user\": \"x\"} },\n              \"expected_result\": { \"expected_status\": 200, \"extract\": {\"access_token\": \"access_token\"} }\n            }\n          }\n        }\n      }\n    }\n  }'\n</code></pre></p>"},{"location":"usage/REST_API_usage/#using-invoke-api","title":"Using Invoke API","text":"<p>To run the Invoke API keyword via the REST API, the session must have API definitions. You can either:</p> <ol> <li>At session creation: include <code>api_data</code> in the SessionConfig as an inline JSON object, or</li> <li>After creation: call Add API definitions above with your API payload.</li> </ol> <p>Then execute the keyword:</p> <pre><code>curl -X POST \"http://localhost:8000/v1/sessions/{session_id}/action\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"mode\": \"keyword\",\n    \"keyword\": \"Invoke API\",\n    \"params\": [\"collection_name.api_name\"]\n  }'\n</code></pre> <p>Use the identifier format <code>collection_name.api_name</code> (e.g. <code>auth.token</code>). Extracted values from the API response are stored in the session and can be used by subsequent keywords or reads.</p>"},{"location":"usage/REST_API_usage/#capture-screenshot","title":"Capture Screenshot","text":"<p>GET <code>/v1/sessions/{session_id}/screenshot</code></p> <p>Capture a screenshot in the specified session.</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Response: <code>ExecutionResponse</code> with screenshot data in base64 format</p> <p>Example: <pre><code>curl \"http://localhost:8000/v1/sessions/{session_id}/screenshot\"\n</code></pre></p>"},{"location":"usage/REST_API_usage/#get-driver-session-id","title":"Get Driver Session ID","text":"<p>GET <code>/v1/sessions/{session_id}/driver-id</code></p> <p>Get the underlying Driver session ID for this Optics session.</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Response: <code>ExecutionResponse</code> with driver session ID in <code>data.result</code></p> <p>Example: <pre><code>curl \"http://localhost:8000/v1/sessions/{session_id}/driver-id\"\n</code></pre></p>"},{"location":"usage/REST_API_usage/#get-elements","title":"Get Elements","text":"<p>GET <code>/v1/sessions/{session_id}/elements</code></p> <p>Get interactive elements from the current session screen.</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Query Parameters: - <code>filter_config</code> (Optional[List[str]]): Filter types. Valid values:   - <code>\"all\"</code>: Show all elements (default when None or empty)   - <code>\"interactive\"</code>: Only interactive elements   - <code>\"buttons\"</code>: Only button elements   - <code>\"inputs\"</code>: Only input/text field elements   - <code>\"images\"</code>: Only image elements   - <code>\"text\"</code>: Only text elements   - Can be combined: <code>?filter_config=buttons&amp;filter_config=inputs</code></p> <p>Response: <code>ExecutionResponse</code> with elements array in <code>data.result</code></p> <p>Example: <pre><code>curl \"http://localhost:8000/v1/sessions/{session_id}/elements?filter_config=buttons&amp;filter_config=inputs\"\n</code></pre></p>"},{"location":"usage/REST_API_usage/#get-page-source","title":"Get Page Source","text":"<p>GET <code>/v1/sessions/{session_id}/source</code></p> <p>Capture the page source from the current session.</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Response: <code>ExecutionResponse</code> with page source in <code>data.result</code></p> <p>Example: <pre><code>curl \"http://localhost:8000/v1/sessions/{session_id}/source\"\n</code></pre></p>"},{"location":"usage/REST_API_usage/#get-screen-elements","title":"Get Screen Elements","text":"<p>GET <code>/v1/sessions/{session_id}/screen_elements</code></p> <p>Capture and get screen elements from the current session.</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Response: <code>ExecutionResponse</code> with screen elements in <code>data.result</code></p> <p>Example: <pre><code>curl \"http://localhost:8000/v1/sessions/{session_id}/screen_elements\"\n</code></pre></p>"},{"location":"usage/REST_API_usage/#stream-events","title":"Stream Events","text":"<p>GET <code>/v1/sessions/{session_id}/events</code></p> <p>Stream execution events for the specified session using Server-Sent Events (SSE).</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Response: Server-Sent Events stream</p> <p>Event Format: Each event is a JSON object: <pre><code>{\n  \"execution_id\": \"uuid-string\",\n  \"status\": \"RUNNING|SUCCESS|FAIL|HEARTBEAT\",\n  \"message\": \"Event message\"\n}\n</code></pre></p> <p>Example: <pre><code>curl -N \"http://localhost:8000/v1/sessions/{session_id}/events\"\n</code></pre></p> <p>Event Streaming</p> <ul> <li>Sends heartbeat events every 15 seconds if no execution events occur</li> <li>Connection remains open until the session is terminated or client disconnects</li> </ul>"},{"location":"usage/REST_API_usage/#stream-workspace","title":"Stream Workspace","text":"<p>GET <code>/v1/sessions/{session_id}/workspace/stream</code></p> <p>Stream workspace data (screenshot, elements, optionally source) for the specified session using Server-Sent Events (SSE). Only emits updates when workspace data actually changes.</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Query Parameters: - <code>interval_ms</code> (int, default: 2000): Polling interval in milliseconds (minimum 500ms) - <code>include_source</code> (bool, default: false): Include page source in workspace data - <code>filter_config</code> (Optional[List[str]]): Filter types for elements (same as <code>/elements</code> endpoint)</p> <p>Response: Server-Sent Events stream</p> <p>Event Format: Each event is a JSON object: <pre><code>{\n  \"screenshot\": \"base64-encoded-image\",\n  \"elements\": [...],\n  \"screenshotFailed\": false,\n  \"source\": \"...\" // only if include_source=true\n}\n</code></pre></p> <p>Or heartbeat: <pre><code>{\n  \"type\": \"heartbeat\",\n  \"timestamp\": 1234567890.123\n}\n</code></pre></p> <p>Example: <pre><code>curl -N \"http://localhost:8000/v1/sessions/{session_id}/workspace/stream?interval_ms=2000&amp;include_source=true\"\n</code></pre></p> <p>Performance</p> <ul> <li>Only emits when workspace data actually changes (detected via hash comparison)</li> <li>Sends heartbeat events every 15 seconds if no changes occur</li> <li>Screenshot and elements are gathered in parallel for better performance</li> </ul>"},{"location":"usage/REST_API_usage/#list-keywords","title":"List Keywords","text":"<p>GET <code>/v1/keywords</code></p> <p>List all available keywords and their parameters.</p> <p>Response: <code>List[KeywordInfo]</code></p> <p>Example: <pre><code>curl \"http://localhost:8000/v1/keywords\"\n</code></pre></p> <p>Response Example: <pre><code>[\n  {\n    \"keyword\": \"Press Element\",\n    \"keyword_slug\": \"press_element\",\n    \"description\": \"Taps on a given element with optional offset and repeat parameters.\",\n    \"parameters\": [\n      {\n        \"name\": \"element\",\n        \"type\": \"str\",\n        \"default\": null\n      },\n      {\n        \"name\": \"repeat\",\n        \"type\": \"int\",\n        \"default\": 1\n      }\n    ]\n  }\n]\n</code></pre></p>"},{"location":"usage/REST_API_usage/#terminate-session","title":"Terminate Session","text":"<p>DELETE <code>/v1/sessions/{session_id}/stop</code></p> <p>Terminate the specified session and clean up resources.</p> <p>Path Parameters: - <code>session_id</code> (str): The session ID</p> <p>Response: <code>TerminationResponse</code></p> <p>Example: <pre><code>curl -X DELETE \"http://localhost:8000/v1/sessions/{session_id}/stop\"\n</code></pre></p> <p>Termination</p> <ul> <li>Automatically executes <code>close_and_terminate_app</code> keyword before termination</li> <li>Cleans up all session resources</li> </ul>"},{"location":"usage/REST_API_usage/#error-handling","title":"Error Handling","text":"<p>The API uses standard HTTP status codes:</p> <ul> <li><code>200 OK</code>: Request succeeded</li> <li><code>400 Bad Request</code>: Invalid request parameters</li> <li><code>404 Not Found</code>: Session not found</li> <li><code>500 Internal Server Error</code>: Server error</li> </ul> <p>Error responses include a <code>detail</code> field with the error message:</p> <pre><code>{\n  \"detail\": \"Session not found\"\n}\n</code></pre> <p>For Optics-specific errors, the response may include additional fields:</p> <pre><code>{\n  \"detail\": {\n    \"code\": \"E0402\",\n    \"message\": \"Keyword not found\",\n    \"status\": 400\n  }\n}\n</code></pre>"},{"location":"usage/REST_API_usage/#common-workflows","title":"Common Workflows","text":""},{"location":"usage/REST_API_usage/#basic-session-workflow","title":"Basic Session Workflow","text":"<ol> <li> <p>Create a session: <pre><code>POST /v1/sessions/start\n</code></pre></p> </li> <li> <p>Execute keywords: <pre><code>POST /v1/sessions/{session_id}/action\n</code></pre></p> </li> <li> <p>Monitor execution (optional): <pre><code>GET /v1/sessions/{session_id}/events\n</code></pre></p> </li> <li> <p>Terminate session: <pre><code>DELETE /v1/sessions/{session_id}/stop\n</code></pre></p> </li> </ol>"},{"location":"usage/REST_API_usage/#real-time-workspace-monitoring","title":"Real-time Workspace Monitoring","text":"<ol> <li> <p>Create a session: <pre><code>POST /v1/sessions/start\n</code></pre></p> </li> <li> <p>Stream workspace updates: <pre><code>GET /v1/sessions/{session_id}/workspace/stream?interval_ms=1000\n</code></pre></p> </li> <li> <p>Terminate when done: <pre><code>DELETE /v1/sessions/{session_id}/stop\n</code></pre></p> </li> </ol>"},{"location":"usage/REST_API_usage/#notes","title":"Notes","text":"<ul> <li>All endpoints that accept <code>session_id</code> will return <code>404</code> if the session doesn't exist</li> <li>The API supports CORS for all origins</li> <li>Session creation automatically launches the app configured in the session</li> <li>Fallback parameter support allows trying multiple values until one succeeds</li> <li>Named parameters are automatically converted to positional parameters based on method signatures</li> <li>Workspace streaming only emits when data changes, reducing load on the driver</li> </ul>"},{"location":"usage/keyword_usage/","title":"Keyword Usage","text":"<p>This document outlines the available keywords for the Optics Framework, which can be used in the <code>test_modules.csv</code> file to define test steps. Keywords are derived from the framework's Python API, with method names converted to a space-separated format (e.g., <code>press_element</code> becomes <code>Press Element</code>). Each keyword corresponds to a specific action, verification, or control flow operation. Below, each keyword includes detailed parameter explanations to guide their usage.</p>"},{"location":"usage/keyword_usage/#keyword-data-sources","title":"Keyword data sources","text":"<ul> <li>Element-based keywords (Press Element, Assert Elements, Type Text, Validate Element, etc.) use element data from element files (CSV with columns such as <code>element_name</code> / <code>element_id</code>, or YAML with an <code>elements</code> key). Element names in test steps refer to these definitions.</li> <li>Invoke API uses API definition data from API YAML files (top-level <code>api</code> or <code>apis</code>). It does not use element files. You reference an API by the identifier <code>collection.api_name</code>.</li> </ul>"},{"location":"usage/keyword_usage/#action-keywords","title":"Action Keywords","text":"<p>These keywords handle interactions with the application, such as clicking, swiping, and text input.</p>"},{"location":"usage/keyword_usage/#press-element","title":"Press Element","text":"<p>Presses a specified element on the screen.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The target to press. Can be:\u2022 Text: A string to locate via text detection (e.g., \"Home\", <code>${Home_text}</code>)\u2022 XPath: An XPath expression for Appium/Selenium (e.g., <code>//android.widget.Button[@resource-id=\"id\"]</code>)\u2022 Image: A filename of an image in <code>input_templates/</code> (e.g., \"home.png\", <code>${Home_image}</code>) - <code>repeat</code> Optional Number of times to press the element (integer) <code>1</code> <code>offset_x</code> Optional Horizontal offset in pixels from the element's center (integer) <code>0</code> <code>offset_y</code> Optional Vertical offset in pixels from the element's center (integer) <code>0</code> <code>index</code> Optional Index of the element if multiple matches are found (integer, 0-based) <code>0</code> <code>aoi_x</code> Optional X percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_y</code> Optional Y percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_width</code> Optional Width percentage of Area of Interest (0-100, float) <code>100</code> <code>aoi_height</code> Optional Height percentage of Area of Interest (0-100, float) <code>100</code> <code>event_name</code> Optional A string identifier for logging or triggering events (e.g., \"click_home\") - <p>Example:</p> <pre><code>Press Element,${Subscriptions_text},2,10,20,0,0,0,100,100,click_event\n</code></pre>"},{"location":"usage/keyword_usage/#press-by-percentage","title":"Press By Percentage","text":"<p>Presses at percentage-based coordinates on the screen.</p> <p>Parameters:</p> Parameter Type Description Default <code>percent_x</code> Required X-coordinate as a percentage of screen width (float, 0.0 to 1.0, e.g., 0.5 for 50%) - <code>percent_y</code> Required Y-coordinate as a percentage of screen height (float, 0.0 to 1.0) - <code>repeat</code> Optional Number of times to press (integer) <code>1</code> <code>event_name</code> Optional A string identifier for the press event (e.g., \"center_press\") - <p>Example:</p> <pre><code>Press By Percentage,0.5,0.5,,press_center\n</code></pre>"},{"location":"usage/keyword_usage/#press-by-coordinates","title":"Press By Coordinates","text":"<p>Presses at absolute coordinates on the screen.</p> <p>Parameters:</p> Parameter Type Description Default <code>coor_x</code> Required X-coordinate in pixels (integer, e.g., 500) - <code>coor_y</code> Required Y-coordinate in pixels (integer, e.g., 800) - <code>repeat</code> Optional Number of times to press (integer) <code>1</code> <code>event_name</code> Optional A string identifier for the press event (e.g., \"tap_event\") - <p>Example:</p> <pre><code>Press By Coordinates,500,800,,tap_event\n</code></pre>"},{"location":"usage/keyword_usage/#detect-and-press","title":"Detect And Press","text":"<p>Detects a specified element and presses it if found.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The element to detect and press (Image template, OCR template, or XPath) - <code>timeout</code> Optional Timeout for the detection operation in seconds (integer) <code>30</code> <code>event_name</code> Optional A string identifier for the press event - <p>Example:</p> <pre><code>Detect And Press,login_button.png,30,detect_login\n</code></pre>"},{"location":"usage/keyword_usage/#swipe","title":"Swipe","text":"<p>Performs a swipe action in a specified direction from given coordinates.</p> <p>Parameters:</p> Parameter Type Description Default <code>coor_x</code> Required X coordinate of the swipe starting point (integer) - <code>coor_y</code> Required Y coordinate of the swipe starting point (integer) - <code>direction</code> Optional The swipe direction: <code>up</code>, <code>down</code>, <code>left</code>, or <code>right</code> <code>right</code> <code>swipe_length</code> Optional The length of the swipe in pixels (integer) <code>50</code> <code>event_name</code> Optional A string identifier for the swipe event - <p>Example:</p> <pre><code>Swipe,500,800,down,100,swipe_down\n</code></pre>"},{"location":"usage/keyword_usage/#swipe-percentage","title":"Swipe Percentage","text":"<p>Performs a swipe action in a specified direction by percentage of the screen (0-100).</p> <p>Parameters:</p> Parameter Type Description Default <code>percent_x</code> Required X position of the swipe start as a percentage of screen width (integer, 0-100) - <code>percent_y</code> Required Y position of the swipe start as a percentage of screen height (integer, 0-100) - <code>direction</code> Optional The swipe direction: <code>up</code>, <code>down</code>, <code>left</code>, or <code>right</code> <code>right</code> <code>swipe_length</code> Optional Length of the swipe as a percentage of the screen (integer, 0-100) <code>50</code> <code>event_name</code> Optional A string identifier for the swipe event - <p>Example:</p> <pre><code>Swipe Percentage,50,50,up,25,swipe_up\n</code></pre>"},{"location":"usage/keyword_usage/#swipe-until-element-appears","title":"Swipe Until Element Appears","text":"<p>Swipes in a specified direction until an element appears.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The target element to find (Image template, OCR template, or XPath) - <code>direction</code> Required The swipe direction: <code>up</code>, <code>down</code>, <code>left</code>, or <code>right</code> - <code>timeout</code> Required Timeout in seconds until element search is performed (integer) - <code>event_name</code> Optional A string identifier for the swipe event - <p>Example:</p> <pre><code>Swipe Until Element Appears,next_button.png,down,30,find_next\n</code></pre>"},{"location":"usage/keyword_usage/#swipe-from-element","title":"Swipe From Element","text":"<p>Performs a swipe action starting from a specified element.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The element to swipe from (Image template, OCR template, or XPath) - <code>direction</code> Required The swipe direction: <code>up</code>, <code>down</code>, <code>left</code>, or <code>right</code> - <code>swipe_length</code> Required The length of the swipe in pixels (integer) - <code>aoi_x</code> Optional X percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_y</code> Optional Y percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_width</code> Optional Width percentage of Area of Interest (0-100, float) <code>100</code> <code>aoi_height</code> Optional Height percentage of Area of Interest (0-100, float) <code>100</code> <code>event_name</code> Optional A string identifier for the swipe event - <p>Example:</p> <pre><code>Swipe From Element,slider.png,right,50,0,0,100,100,swipe_slider\n</code></pre>"},{"location":"usage/keyword_usage/#scroll","title":"Scroll","text":"<p>Performs a scroll action in a specified direction.</p> <p>Parameters:</p> Parameter Type Description Default <code>direction</code> Required The scroll direction: <code>up</code>, <code>down</code>, <code>left</code>, or <code>right</code> - <code>event_name</code> Optional A string identifier for the scroll event - <p>Example:</p> <pre><code>Scroll,down,scroll_down\n</code></pre>"},{"location":"usage/keyword_usage/#scroll-until-element-appears","title":"Scroll Until Element Appears","text":"<p>Scrolls in a specified direction until an element appears.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The target element to find (Image template, OCR template, or XPath) - <code>direction</code> Required The scroll direction: <code>up</code>, <code>down</code>, <code>left</code>, or <code>right</code> - <code>timeout</code> Required Timeout in seconds for the scroll operation (integer) - <code>event_name</code> Optional A string identifier for the scroll event - <p>Example:</p> <pre><code>Scroll Until Element Appears,footer.png,down,30,find_footer\n</code></pre>"},{"location":"usage/keyword_usage/#scroll-from-element","title":"Scroll From Element","text":"<p>Performs a scroll action starting from a specified element.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The element to scroll from (Image template, OCR template, or XPath) - <code>direction</code> Required The scroll direction: <code>up</code>, <code>down</code>, <code>left</code>, or <code>right</code> - <code>scroll_length</code> Required The length of the scroll in pixels (integer) - <code>aoi_x</code> Optional X percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_y</code> Optional Y percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_width</code> Optional Width percentage of Area of Interest (0-100, float) <code>100</code> <code>aoi_height</code> Optional Height percentage of Area of Interest (0-100, float) <code>100</code> <code>event_name</code> Optional A string identifier for the scroll event - <p>Example:</p> <pre><code>Scroll From Element,scrollable_area.png,down,100,0,0,100,100,scroll_area\n</code></pre>"},{"location":"usage/keyword_usage/#enter-text","title":"Enter Text","text":"<p>Enters text into a specified element.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The target element (Image template, OCR template, or XPath) - <code>text</code> Required The text to be entered - <code>aoi_x</code> Optional X percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_y</code> Optional Y percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_width</code> Optional Width percentage of Area of Interest (0-100, float) <code>100</code> <code>aoi_height</code> Optional Height percentage of Area of Interest (0-100, float) <code>100</code> <code>event_name</code> Optional A string identifier for the input event - <p>Example:</p> <pre><code>Enter Text,username_field.png,myusername,0,0,100,100,enter_username\n</code></pre>"},{"location":"usage/keyword_usage/#enter-text-direct","title":"Enter Text Direct","text":"<p>Enters text directly using the keyboard without targeting a specific element.</p> <p>Parameters:</p> Parameter Type Description Default <code>text</code> Required The text to be entered - <code>event_name</code> Optional A string identifier for the input event - <p>Example:</p> <pre><code>Enter Text Direct,Hello World,type_text\n</code></pre>"},{"location":"usage/keyword_usage/#enter-text-using-keyboard","title":"Enter Text Using Keyboard","text":"<p>Enters text or presses a special key using the keyboard. Supports special keys like <code>&lt;enter&gt;</code>, <code>&lt;tab&gt;</code>, etc.</p> <p>Parameters:</p> Parameter Type Description Default <code>text_input</code> Required The text or special key identifier to send (e.g., \"hello\" or \"\") - <code>event_name</code> Optional A string identifier for the keyboard event - <p>Example:</p> <pre><code>Enter Text Using Keyboard,&lt;enter&gt;,press_enter\n</code></pre>"},{"location":"usage/keyword_usage/#enter-number","title":"Enter Number","text":"<p>Enters a specified number into an element.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The target element (Image template, OCR template, or XPath) - <code>number</code> Required The number to be entered - <code>aoi_x</code> Optional X percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_y</code> Optional Y percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_width</code> Optional Width percentage of Area of Interest (0-100, float) <code>100</code> <code>aoi_height</code> Optional Height percentage of Area of Interest (0-100, float) <code>100</code> <code>event_name</code> Optional A string identifier for the input event - <p>Example:</p> <pre><code>Enter Number,phone_field.png,1234567890,0,0,100,100,enter_phone\n</code></pre>"},{"location":"usage/keyword_usage/#press-keycode","title":"Press Keycode","text":"<p>Presses a specified keycode (useful for Android keycodes like BACK, HOME, etc.).</p> <p>Parameters:</p> Parameter Type Description Default <code>keycode</code> Required The keycode to be pressed (e.g., \"4\" for BACK, \"3\" for HOME) - <code>event_name</code> Optional A string identifier for the keycode event - <p>Example:</p> <pre><code>Press Keycode,4,press_back\n</code></pre>"},{"location":"usage/keyword_usage/#clear-element-text","title":"Clear Element Text","text":"<p>Clears text from a specified element.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The target element (Image template, OCR template, or XPath) - <code>aoi_x</code> Optional X percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_y</code> Optional Y percentage of Area of Interest top-left corner (0-100, float) <code>0</code> <code>aoi_width</code> Optional Width percentage of Area of Interest (0-100, float) <code>100</code> <code>aoi_height</code> Optional Height percentage of Area of Interest (0-100, float) <code>100</code> <code>event_name</code> Optional A string identifier for the clear event - <p>Example:</p> <pre><code>Clear Element Text,text_field.png,0,0,100,100,clear_field\n</code></pre>"},{"location":"usage/keyword_usage/#get-text","title":"Get Text","text":"<p>Gets the text from a specified element. Currently supports XPath and Text-based elements with Appium.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The target element (Text or XPath) - <p>Example:</p> <pre><code>Get Text,//android.widget.TextView[@resource-id=\"title\"]\n</code></pre> <p>Note: This keyword returns text but does not store it in CSV format. Use with flow control keywords to store results.</p>"},{"location":"usage/keyword_usage/#sleep","title":"Sleep","text":"<p>Sleeps for a specified duration.</p> <p>Parameters:</p> Parameter Type Description Default <code>duration</code> Required The duration of the sleep in seconds (integer) - <p>Example:</p> <pre><code>Sleep,5\n</code></pre>"},{"location":"usage/keyword_usage/#execute-script","title":"Execute Script","text":"<p>Executes JavaScript/script in the current context. Supports both plain script strings and JSON format with arguments.</p> <p>Parameters:</p> Parameter Type Description Default <code>script_or_json</code> Required The JavaScript code/script command, or a JSON string containing <code>{\"script\": \"...\", \"args\": {...}}</code> or <code>{\"script\": \"...\"}</code> - <code>event_name</code> Optional A string identifier for the script execution event - <p>Example:</p> <pre><code>Execute Script,{\"script\": \"mobile:pressKey\", \"args\": {\"keycode\": 3}},execute_back\n</code></pre>"},{"location":"usage/keyword_usage/#verification-keywords","title":"Verification Keywords","text":"<p>These keywords handle verification and validation operations.</p>"},{"location":"usage/keyword_usage/#validate-element","title":"Validate Element","text":"<p>Verifies the specified element is present on the screen.</p> <p>Parameters:</p> Parameter Type Description Default <code>element</code> Required The element to be verified (Image template, OCR template, or XPath) - <code>timeout</code> Optional The time to wait for verification in seconds (integer) <code>10</code> <code>rule</code> Optional The rule used for verification: <code>all</code> or <code>any</code> <code>all</code> <code>event_name</code> Optional The name of the event associated with the verification - <p>Example:</p> <pre><code>Validate Element,login_button.png,10,any,verify_login\n</code></pre>"},{"location":"usage/keyword_usage/#assert-presence","title":"Assert Presence","text":"<p>Asserts the presence of elements. Can check multiple elements with pipe separator (<code>|</code>).</p> <p>Parameters:</p> Parameter Type Description Default <code>elements</code> Required Comma-separated or pipe-separated string of elements to check (e.g., \"button1.png|button2.png\") - <code>timeout_str</code> Optional The time to wait for the elements in seconds (integer) <code>30</code> <code>rule</code> Optional The rule for verification: <code>any</code> (at least one) or <code>all</code> (all must be present) <code>any</code> <code>event_name</code> Optional The name of the event associated with the assertion - <p>Example:</p> <pre><code>Assert Presence,login_button.png|signup_button.png,30,any,check_buttons\n</code></pre>"},{"location":"usage/keyword_usage/#validate-screen","title":"Validate Screen","text":"<p>Verifies the specified screen by checking element presence. Similar to <code>Assert Presence</code> but does not fail if elements are not found.</p> <p>Parameters:</p> Parameter Type Description Default <code>elements</code> Required Comma-separated or pipe-separated string of elements to verify - <code>timeout</code> Optional The time to wait for verification in seconds (integer) <code>30</code> <code>rule</code> Optional The rule for verification: <code>any</code> or <code>all</code> <code>any</code> <code>event_name</code> Optional The name of the event associated with the verification - <p>Example:</p> <pre><code>Validate Screen,home_screen.png|menu.png,30,any,verify_home\n</code></pre>"},{"location":"usage/keyword_usage/#capture-screenshot","title":"Capture Screenshot","text":"<p>Captures a screenshot of the current screen.</p> <p>Parameters:</p> Parameter Type Description Default <code>event_name</code> Optional The name of the event associated with the screenshot capture - <p>Example:</p> <pre><code>Capture Screenshot,screenshot_before_action\n</code></pre>"},{"location":"usage/keyword_usage/#capture-page-source","title":"Capture Page Source","text":"<p>Captures the page source of the current screen.</p> <p>Parameters:</p> Parameter Type Description Default <code>event_name</code> Optional The name of the event associated with the page source capture - <p>Example:</p> <pre><code>Capture Page Source,get_source\n</code></pre>"},{"location":"usage/keyword_usage/#get-interactive-elements","title":"Get Interactive Elements","text":"<p>Retrieves a list of interactive elements on the current screen.</p> <p>Parameters:</p> Parameter Type Description Default <code>filter_config</code> Optional Optional list of filter types (e.g., \"buttons,inputs\") - <p>Example:</p> <pre><code>Get Interactive Elements,buttons\n</code></pre>"},{"location":"usage/keyword_usage/#app-management-keywords","title":"App Management Keywords","text":"<p>These keywords handle application lifecycle operations.</p>"},{"location":"usage/keyword_usage/#launch-app","title":"Launch App","text":"<p>Launches the specified application.</p> <p>Parameters:</p> Parameter Type Description Default <code>app_identifier</code> Optional The app identifier (package name for Android, bundle ID for iOS) - <code>app_activity</code> Optional The app activity (Android only) - <code>event_name</code> Optional The event triggering the app launch - <p>Example:</p> <pre><code>Launch App,com.example.app,MainActivity,launch_main\n</code></pre>"},{"location":"usage/keyword_usage/#start-appium-session","title":"Start Appium Session","text":"<p>Starts an Appium session. This is typically called automatically during setup.</p> <p>Parameters:</p> Parameter Type Description Default <code>event_name</code> Optional The event triggering the session start - <p>Example:</p> <pre><code>Start Appium Session,start_session\n</code></pre>"},{"location":"usage/keyword_usage/#launch-other-app","title":"Launch Other App","text":"<p>Starts another application.</p> <p>Parameters:</p> Parameter Type Description Default <code>app_name</code> Required The package name or bundle ID of the application - <code>event_name</code> Optional The event triggering the app start - <p>Example:</p> <pre><code>Launch Other App,com.example.otherapp,launch_other\n</code></pre>"},{"location":"usage/keyword_usage/#close-and-terminate-app","title":"Close And Terminate App","text":"<p>Closes and terminates the current application.</p> <p>Parameters:</p> <p>None</p> <p>Example:</p> <pre><code>Close And Terminate App\n</code></pre>"},{"location":"usage/keyword_usage/#force-terminate-app","title":"Force Terminate App","text":"<p>Forcefully terminates the specified application.</p> <p>Parameters:</p> Parameter Type Description Default <code>app_name</code> Required The name of the application to terminate - <code>event_name</code> Optional The event triggering the forced termination - <p>Example:</p> <pre><code>Force Terminate App,com.example.app,terminate_app\n</code></pre>"},{"location":"usage/keyword_usage/#get-app-version","title":"Get App Version","text":"<p>Gets the version of the application.</p> <p>Parameters:</p> <p>None</p> <p>Example:</p> <pre><code>Get App Version\n</code></pre>"},{"location":"usage/keyword_usage/#get-driver-session-id","title":"Get Driver Session Id","text":"<p>Returns the current driver session ID, if available.</p> <p>Parameters:</p> <p>None</p> <p>Example:</p> <pre><code>Get Driver Session Id\n</code></pre>"},{"location":"usage/keyword_usage/#flow-control-keywords","title":"Flow Control Keywords","text":"<p>These keywords handle control flow operations like loops, conditions, and data manipulation. Module execution is performed by the runner when it runs test-case steps; the Optics API does not expose user-facing \"Initialise Setup\" or \"Execute Module\" keywords.</p>"},{"location":"usage/keyword_usage/#run-loop","title":"Run Loop","text":"<p>Runs a loop over a target module, either by count or with variables.</p> <p>Parameters:</p> Parameter Type Description Default <code>target</code> Required The module name to execute in the loop - <code>args</code> Variable Either a count (integer) or variable-iterable pairs:\u2022 Count: <code>[\"5\"]</code> - runs 5 times\u2022 Variables: <code>[\"${var1}\", \"value1\\|value2\\|value3\", \"${var2}\", \"a\\|b\\|c\"]</code> - iterates over values - <p>Example (by count):</p> <pre><code>Run Loop,test_module,5\n</code></pre> <p>Example (with variables):</p> <pre><code>Run Loop,test_module,${username},user1|user2|user3,${password},pass1|pass2|pass3\n</code></pre>"},{"location":"usage/keyword_usage/#condition","title":"Condition","text":"<p>Evaluates conditions and executes corresponding targets. Supports both module-based and expression-based conditions.</p> <p>Parameters:</p> Parameter Type Description Default <code>args</code> Variable Condition-target pairs, optionally ending with an else target:\u2022 <code>[\"condition1\", \"target1\", \"condition2\", \"target2\", \"else_target\"]</code>\u2022 Conditions can be module names (prefixed with <code>!</code> to invert) or expressions - <p>Example (module condition):</p> <pre><code>Condition,login_success,show_dashboard,login_failed,show_error\n</code></pre> <p>Example (expression condition):</p> <pre><code>Condition,${count} &gt; 10,handle_large_count,handle_small_count\n</code></pre> <p>Example (with else):</p> <pre><code>Condition,${status} == \"active\",activate,deactivate,default_action\n</code></pre>"},{"location":"usage/keyword_usage/#read-data","title":"Read Data","text":"<p>Reads tabular data from a CSV file, JSON file, environment variable, or a 2D list, applies optional filtering and column selection, and stores the result in the session's elements.</p> <p>For the programmatic API and full parameter details, see Flow Control in the API reference.</p> <p>Parameters:</p> Parameter Type Description Default <code>input_element</code> Required The variable name where data will be stored. Prefer the form <code>${name}</code> (e.g. <code>${data}</code>). If another form is used, the value is still stored under that name (a warning may be logged). - <code>file_path</code> Required The data source. One of:\u2022 File path: Path to a <code>.csv</code> or <code>.json</code> file (relative paths are resolved from the project path). Only these extensions are supported.\u2022 Environment variable: Use the prefix <code>ENV:</code> followed by the variable name. Example: <code>ENV:APP_CONFIG</code> reads the env var <code>APP_CONFIG</code>. The value is interpreted as: (1) if it looks like JSON (starts with <code>[</code>, <code>{</code>, or <code>\"</code>), it is parsed as JSON and objects/arrays are normalized to a table; (2) otherwise it is parsed as CSV if valid; (3) otherwise the whole value is stored as a single string.\u2022 2D list: Only when using the Python API: a list whose first row is headers and following rows are data (e.g. <code>[[\"col1\",\"col2\"],[\"a\",\"b\"]]</code>). Not passable as a literal in CSV test steps; see Library Usage for programmatic use. - <code>query</code> Optional Semicolon-separated parts. Each part is either:\u2022 Column selection: <code>select=col1,col2,...</code> (comma-separated column names).\u2022 Filter: A pandas-style expression, e.g. <code>status=='active'</code>, <code>count&gt;10</code>. Multiple filter parts are combined with <code>and</code>.Any <code>${varname}</code> in the query is replaced from <code>session.elements</code> before evaluation (e.g. <code>role=='${expected_role}'</code>). <code>\"\"</code> <p>Example (CSV file):</p> <pre><code>Read Data,${users},users.csv,select=username,email\n</code></pre> <p>Example (with filter):</p> <pre><code>Read Data,${active_users},users.csv,status='active';select=username,email\n</code></pre> <p>Example (environment variable):</p> <pre><code>Read Data,${config},ENV:APP_CONFIG\n</code></pre> <p>Example (query with variable):</p> <pre><code>Read Data,${filtered},users.csv,role=='${expected_role}';select=id,name\n</code></pre> <p>Note: Inline list data (e.g. a 2D list) is supported only when calling the Python API; see Library Usage for examples.</p>"},{"location":"usage/keyword_usage/#evaluate","title":"Evaluate","text":"<p>Evaluates an expression and stores the result in session.elements.</p> <p>Parameters:</p> Parameter Type Description Default <code>param1</code> Required The variable name where the result will be stored (e.g., <code>${result}</code>) - <code>param2</code> Required The expression to evaluate (can use variables like <code>${var1} + ${var2}</code>) - <p>Example:</p> <pre><code>Evaluate,${sum},${a} + ${b}\n</code></pre> <p>Example (with comparison):</p> <pre><code>Evaluate,${is_valid},${count} &gt; 10\n</code></pre>"},{"location":"usage/keyword_usage/#date-evaluate","title":"Date Evaluate","text":"<p>Evaluates a date expression based on an input date and stores the result in session.elements.</p> <p>Parameters:</p> Parameter Type Description Default <code>param1</code> Required The variable name where the evaluated date result will be stored (e.g., <code>${tomorrow}</code>) - <code>param2</code> Required The input date string (e.g., \"04/25/2025\" or \"2025-04-25\"). Format is auto-detected - <code>param3</code> Required The date expression to evaluate, such as \"+1 day\", \"-2 days\", or \"today\" - <code>param4</code> Optional The output format for the evaluated date (default is \"%d %B\", e.g., \"26 April\") <code>%d %B</code> <p>Example:</p> <pre><code>Date Evaluate,${tomorrow},04/25/2025,+1 day\n</code></pre> <p>Example (with custom format):</p> <pre><code>Date Evaluate,${next_week},2025-04-25,+7 days,%Y-%m-%d\n</code></pre>"},{"location":"usage/keyword_usage/#add-api","title":"Add API","text":"<p>Adds or updates API definitions in the current session by loading from a file path or a dictionary. Use this when not using the runner's auto-discovery (e.g. when driving the framework programmatically). The supplied data replaces the session's API data.</p> <p>Parameters:</p> Parameter Type Description Default <code>api_data</code> Required Either a path to an API YAML file, or a dictionary with the same structure (top-level <code>api</code> key with <code>collections</code>, etc.) - <p>Example (file path):</p> <pre><code>Add API,path/to/api.yaml\n</code></pre> <p>Example (programmatic): Pass a dict with an <code>api</code> key holding the collection/endpoint definitions. Relative paths are resolved against the project path when a string is given.</p>"},{"location":"usage/keyword_usage/#invoke-api","title":"Invoke API","text":"<p>Invokes an API call based on a definition from the session's API data.</p> <p>Parameters:</p> Parameter Type Description Default <code>api_identifier</code> Required The API identifier in format <code>collection.api_name</code> - <p>Example:</p> <pre><code>Invoke API,users.get_user\n</code></pre> <p>Data source: API definition YAML</p> <p>Invoke API does not use element files. It uses API definition YAML files only. The format is different from element CSV/YAML: definitions live under a top-level <code>api</code> (or <code>apis</code>) key, with <code>collections</code> \u2192 each collection has <code>base_url</code>, <code>global_headers</code>, and <code>apis</code> \u2192 each API has <code>endpoint</code>, <code>request</code> (e.g. <code>method</code>, <code>headers</code>, <code>body</code>), and optionally <code>expected_result</code>, <code>extract</code>, and so on.</p> <p>How API definitions reach the session:</p> <ul> <li>CLI/runner: YAML files under the project that contain a top-level <code>api</code> or <code>apis</code> key are auto-discovered and loaded as API data.</li> <li>Programmatic: The Add API keyword can load from a file path or a dict to set or replace session API data.</li> </ul>"},{"location":"usage/library_usage/","title":"Library Usage Guide","text":"<p>This guide demonstrates how to use the Optics Framework as a Python library for programmatic test automation.</p>"},{"location":"usage/library_usage/#installation","title":"Installation","text":"<p>Install the Optics Framework:</p> <pre><code>pip install optics-framework\n</code></pre>"},{"location":"usage/library_usage/#quick-start","title":"Quick Start","text":""},{"location":"usage/library_usage/#basic-example","title":"Basic Example","text":"<pre><code>from optics_framework import Optics\n\n# Initialize Optics\noptics = Optics()\n\n# Configure with driver and element sources\noptics.setup(\n    driver_sources=[{\"appium\": {\"enabled\": True, \"url\": \"http://localhost:4723\"}}],\n    elements_sources=[{\"appium_find_element\": {\"enabled\": True}}]\n)\n\n# Launch app\noptics.launch_app(\"com.example.app\")\n\n# Interact with elements\noptics.press_element(\"submit_button\")\noptics.enter_text(\"username_field\", \"testuser\")\n\n# Verify elements\noptics.validate_element(\"welcome_message\")\n\n# Cleanup\noptics.quit()\n</code></pre>"},{"location":"usage/library_usage/#configuration","title":"Configuration","text":""},{"location":"usage/library_usage/#configuration-from-dictionary","title":"Configuration from Dictionary","text":"<pre><code>from optics_framework import Optics\n\nconfig = {\n    \"driver_sources\": [\n        {\n            \"appium\": {\n                \"enabled\": True,\n                \"url\": \"http://localhost:4723\",\n                \"capabilities\": {\n                    \"platformName\": \"Android\",\n                    \"deviceName\": \"emulator-5554\"\n                }\n            }\n        }\n    ],\n    \"elements_sources\": [\n        {\"appium_find_element\": {\"enabled\": True}}\n    ],\n    \"text_detection\": [\n        {\"easyocr\": {\"enabled\": True}}\n    ],\n    \"image_detection\": [\n        {\"templatematch\": {\"enabled\": True}}\n    ],\n    \"project_path\": \"/path/to/project\"\n}\n\noptics = Optics(config=config)\n</code></pre>"},{"location":"usage/library_usage/#configuration-from-yaml-file","title":"Configuration from YAML File","text":"<pre><code>from optics_framework import Optics\n\noptics = Optics()\noptics.setup_from_file(\"config.yaml\")\n</code></pre> <p>config.yaml: <pre><code>driver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\n      capabilities:\n        platformName: \"Android\"\n        deviceName: \"emulator-5554\"\n\nelements_sources:\n  - appium_find_element:\n      enabled: true\n\ntext_detection:\n  - easyocr:\n      enabled: true\n\nimage_detection:\n  - templatematch:\n      enabled: true\n\nproject_path: \"/path/to/project\"\n</code></pre></p>"},{"location":"usage/library_usage/#configuration-from-yaml-string","title":"Configuration from YAML String","text":"<pre><code>from optics_framework import Optics\n\nyaml_config = \"\"\"\ndriver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\nelements_sources:\n  - appium_find_element:\n      enabled: true\n\"\"\"\n\noptics = Optics()\noptics.setup(config=yaml_config)\n</code></pre>"},{"location":"usage/library_usage/#app-management","title":"App Management","text":""},{"location":"usage/library_usage/#launching-apps","title":"Launching Apps","text":"<pre><code># Launch app by package name\noptics.launch_app(\"com.example.app\")\n\n# Launch other app\noptics.launch_other_app(\"com.other.app\")\n\n# Get app version\nversion = optics.get_app_version()\nprint(f\"App version: {version}\")\n\n# Get driver session ID\nsession_id = optics.get_driver_session_id()\nprint(f\"Session ID: {session_id}\")\n</code></pre>"},{"location":"usage/library_usage/#app-lifecycle","title":"App Lifecycle","text":"<pre><code># Launch app\noptics.launch_app(\"com.example.app\")\n\n# Perform test operations\noptics.press_element(\"button\")\n\n# Close and terminate app\noptics.close_and_terminate_app()\n\n# Or force terminate\noptics.force_terminate_app()\n</code></pre>"},{"location":"usage/library_usage/#element-interactions","title":"Element Interactions","text":""},{"location":"usage/library_usage/#pressing-elements","title":"Pressing Elements","text":"<pre><code># Press element by ID\noptics.press_element(\"submit_button\")\n\n# Press with fallback (tries multiple identifiers)\noptics.press_element([\"button1\", \"button2\", \"//button[@id='submit']\"])\n\n# Press by coordinates\noptics.press_by_coordinates(100, 200)\n\n# Press by percentage (50% x, 50% y)\noptics.press_by_percentage(50, 50)\n\n# Press element with index (if multiple matches)\noptics.press_element_with_index(\"button\", index=0)\n</code></pre>"},{"location":"usage/library_usage/#text-input","title":"Text Input","text":"<pre><code># Enter text in element\noptics.enter_text(\"username_field\", \"testuser\")\n\n# Enter text directly (without element)\noptics.enter_text_direct(\"input_field\", \"text\")\n\n# Enter text using keyboard\noptics.enter_text_using_keyboard(\"field\", \"text\")\n\n# Enter number\noptics.enter_number(\"number_field\", 123)\n\n# Clear element text\noptics.clear_element_text(\"input_field\")\n</code></pre>"},{"location":"usage/library_usage/#gestures","title":"Gestures","text":"<pre><code># Swipe from (x1, y1) to (x2, y2)\noptics.swipe(100, 200, 300, 400)\n\n# Swipe by percentage (x%, y%, direction, swipe length % \u2014 all integers 0-100)\noptics.swipe_percentage(50, 50, \"up\", 25)\n\n# Swipe until element appears\noptics.swipe_until_element_appears(\"target_element\", direction=\"up\")\n\n# Swipe from element\noptics.swipe_from_element(\"source_element\", 300, 400)\n\n# Scroll\noptics.scroll(100, 200, 300, 400)\n\n# Scroll until element appears\noptics.scroll_until_element_appears(\"target_element\", direction=\"down\")\n\n# Scroll from element\noptics.scroll_from_element(\"source_element\", 300, 400)\n</code></pre>"},{"location":"usage/library_usage/#other-actions","title":"Other Actions","text":"<pre><code># Press keycode\noptics.press_keycode(4)  # Back button\n\n# Get text from element\ntext = optics.get_text(\"element_id\")\nprint(f\"Element text: {text}\")\n\n# Sleep\noptics.sleep(2)  # Sleep for 2 seconds\n\n# Execute script\nresult = optics.execute_script(\"mobile: shell\", {\"command\": \"echo hello\"})\n</code></pre>"},{"location":"usage/library_usage/#verification","title":"Verification","text":""},{"location":"usage/library_usage/#element-validation","title":"Element Validation","text":"<pre><code># Validate single element exists\noptics.validate_element(\"welcome_message\")\n\n# Assert presence with rules\noptics.assert_presence([\"element1\", \"element2\"], rule=\"all\")  # All must be present\noptics.assert_presence([\"element1\", \"element2\"], rule=\"any\")   # Any must be present\n\n# Validate screen (multiple elements)\noptics.validate_screen([\"header\", \"content\", \"footer\"])\n</code></pre>"},{"location":"usage/library_usage/#screenshots-and-page-source","title":"Screenshots and Page Source","text":"<pre><code># Capture screenshot\nscreenshot = optics.capture_screenshot()\nprint(f\"Screenshot: {screenshot}\")\n\n# Capture page source\npage_source = optics.capture_page_source()\nprint(f\"Page source: {page_source}\")\n\n# Get interactive elements\nelements = optics.get_interactive_elements()\nfor element in elements:\n    print(f\"Element: {element}\")\n</code></pre>"},{"location":"usage/library_usage/#flow-control","title":"Flow Control","text":""},{"location":"usage/library_usage/#conditional-execution","title":"Conditional Execution","text":"<pre><code># Condition with variable\noptics.condition(\"${status} == 'ready'\", \"proceed_keyword\")\n\n# Condition with expression\noptics.condition(\"${count} &gt; 10\", \"handle_large_count\")\n</code></pre>"},{"location":"usage/library_usage/#data-operations","title":"Data Operations","text":"<pre><code># Read data from CSV (element, source, optional query)\ndata = optics.read_data(\"${data}\", \"data.csv\")\nprint(f\"Data: {data}\")\n\n# Read with query: filter and column selection\ndata = optics.read_data(\"${users}\", \"users.csv\", \"status=='active';select=username,email\")\n\n# Read from a 2D list: first row = headers, following rows = data\ndata = optics.read_data(\"${items}\", [[\"id\", \"name\"], [\"1\", \"a\"], [\"2\", \"b\"]])\nprint(f\"Data: {data}\")\n\n# Invoke API\nresponse = optics.invoke_api(\"GET\", \"https://api.example.com/data\")\nprint(f\"API response: {response}\")\n</code></pre>"},{"location":"usage/library_usage/#loops","title":"Loops","text":"<pre><code># Run loop 5 times\noptics.run_loop(5, \"keyword_name\")\n\n# Run loop with condition\noptics.run_loop(10, \"process_item\", condition=\"${status} == 'active'\")\n</code></pre>"},{"location":"usage/library_usage/#evaluation","title":"Evaluation","text":"<pre><code># Evaluate expression\nresult = optics.evaluate(\"${var1} + ${var2}\")\nprint(f\"Result: {result}\")\n\n# Date evaluation\nfuture_date = optics.date_evaluate(\"today + 1 day\")\npast_date = optics.date_evaluate(\"today - 7 days\")\n</code></pre>"},{"location":"usage/library_usage/#element-management","title":"Element Management","text":""},{"location":"usage/library_usage/#adding-elements","title":"Adding Elements","text":"<pre><code># Add element\noptics.add_element(\"submit_button\", \"//button[@id='submit']\")\n\n# Get element value\nelement_value = optics.get_element_value(\"submit_button\")\nprint(f\"Element value: {element_value}\")\n\n# Use element in keywords\noptics.press_element(\"submit_button\")  # Uses stored element\n\n# Use element variable\noptics.press_element(\"${submit_button}\")  # Resolves variable\n</code></pre>"},{"location":"usage/library_usage/#element-variables","title":"Element Variables","text":"<pre><code># Add multiple elements\noptics.add_element(\"username\", \"//input[@name='user']\")\noptics.add_element(\"password\", \"//input[@name='pass']\")\noptics.add_element(\"submit\", \"//button[@type='submit']\")\n\n# Use in sequence\noptics.enter_text(\"${username}\", \"testuser\")\noptics.enter_text(\"${password}\", \"testpass\")\noptics.press_element(\"${submit}\")\n</code></pre>"},{"location":"usage/library_usage/#session-management","title":"Session Management","text":""},{"location":"usage/library_usage/#basic-session-lifecycle","title":"Basic Session Lifecycle","text":"<pre><code>from optics_framework import Optics\n\n# Create and configure session\noptics = Optics()\noptics.setup(config=config)\n\n# Use session\noptics.launch_app(\"com.example.app\")\noptics.press_element(\"button\")\n\n# Cleanup session\noptics.quit()\n</code></pre>"},{"location":"usage/library_usage/#context-manager-pattern","title":"Context Manager Pattern","text":"<pre><code>from contextlib import contextmanager\nfrom optics_framework import Optics\n\n@contextmanager\ndef optics_session(config):\n    \"\"\"Context manager for automatic session cleanup.\"\"\"\n    optics = Optics()\n    optics.setup(config=config)\n    try:\n        yield optics\n    finally:\n        optics.quit()\n\n# Usage\nconfig = {...}\nwith optics_session(config) as optics:\n    optics.launch_app(\"com.example.app\")\n    optics.press_element(\"button\")\n    # Session automatically cleaned up on exit\n</code></pre>"},{"location":"usage/library_usage/#multiple-sessions","title":"Multiple Sessions","text":"<pre><code>from optics_framework import Optics\n\n# Create multiple instances for different sessions\noptics1 = Optics(config=config1)\noptics2 = Optics(config=config2)\n\n# Each instance has its own session\noptics1.launch_app(\"app1\")\noptics2.launch_app(\"app2\")\n\n# Cleanup both\noptics1.quit()\noptics2.quit()\n</code></pre>"},{"location":"usage/library_usage/#error-handling","title":"Error Handling","text":""},{"location":"usage/library_usage/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>from optics_framework import Optics\nfrom optics_framework.common.error import OpticsError\n\noptics = Optics()\noptics.setup(config=config)\n\ntry:\n    optics.press_element(\"nonexistent_element\")\nexcept OpticsError as e:\n    print(f\"Error code: {e.code}\")\n    print(f\"Error message: {e.message}\")\n    print(f\"Error details: {e.details}\")\n</code></pre>"},{"location":"usage/library_usage/#handling-specific-errors","title":"Handling Specific Errors","text":"<pre><code>from optics_framework.common.error import OpticsError, Code\n\ntry:\n    optics.press_element(\"button\")\nexcept OpticsError as e:\n    if e.code == Code.E0101:\n        print(\"Driver not initialized\")\n    elif e.code == Code.E0201:\n        print(\"Element not found\")\n    else:\n        print(f\"Other error: {e.message}\")\n</code></pre>"},{"location":"usage/library_usage/#complete-example","title":"Complete Example","text":"<pre><code>from optics_framework import Optics\nfrom optics_framework.common.error import OpticsError\n\ndef test_login_flow():\n    \"\"\"Complete test example.\"\"\"\n    config = {\n        \"driver_sources\": [\n            {\"appium\": {\"enabled\": True, \"url\": \"http://localhost:4723\"}}\n        ],\n        \"elements_sources\": [\n            {\"appium_find_element\": {\"enabled\": True}}\n        ],\n        \"project_path\": \"/path/to/project\"\n    }\n\n    optics = Optics()\n\n    try:\n        # Setup\n        optics.setup(config=config)\n\n        # Launch app\n        optics.launch_app(\"com.example.app\")\n\n        # Add elements\n        optics.add_element(\"username\", \"//input[@id='username']\")\n        optics.add_element(\"password\", \"//input[@id='password']\")\n        optics.add_element(\"login_button\", \"//button[@id='login']\")\n\n        # Perform login\n        optics.enter_text(\"${username}\", \"testuser\")\n        optics.enter_text(\"${password}\", \"testpass\")\n        optics.press_element(\"${login_button}\")\n\n        # Verify login\n        optics.validate_element(\"welcome_message\")\n\n        # Capture screenshot\n        screenshot = optics.capture_screenshot()\n        print(f\"Screenshot saved: {screenshot}\")\n\n    except OpticsError as e:\n        print(f\"Test failed: {e.message}\")\n        raise\n    finally:\n        # Cleanup\n        optics.quit()\n\nif __name__ == \"__main__\":\n    test_login_flow()\n</code></pre>"},{"location":"usage/library_usage/#best-practices","title":"Best Practices","text":""},{"location":"usage/library_usage/#1-configuration-management","title":"1. Configuration Management","text":"<ul> <li>Store configuration in YAML files for complex setups</li> <li>Use environment variables for sensitive data</li> <li>Keep configuration separate from test logic</li> </ul>"},{"location":"usage/library_usage/#2-resource-cleanup","title":"2. Resource Cleanup","text":"<ul> <li>Always call <code>quit()</code> when done</li> <li>Use context managers for automatic cleanup</li> <li>Handle exceptions to ensure cleanup</li> </ul>"},{"location":"usage/library_usage/#3-element-management","title":"3. Element Management","text":"<ul> <li>Store frequently used elements</li> <li>Use descriptive element names</li> <li>Leverage fallback parameters for resilience</li> </ul>"},{"location":"usage/library_usage/#4-error-handling","title":"4. Error Handling","text":"<ul> <li>Wrap operations in try/except blocks</li> <li>Handle <code>OpticsError</code> specifically</li> <li>Log errors for debugging</li> </ul>"},{"location":"usage/library_usage/#5-code-organization","title":"5. Code Organization","text":"<ul> <li>Separate configuration from test logic</li> <li>Create helper functions for common operations</li> <li>Organize tests into logical modules</li> </ul>"},{"location":"usage/library_usage/#related-documentation","title":"Related Documentation","text":"<ul> <li>Library Layer Architecture - Detailed architecture documentation</li> <li>Keyword Usage - Complete keyword reference</li> <li>Configuration - Configuration guide</li> <li>REST API Usage - REST API endpoint reference</li> <li>API Reference - Python API documentation</li> </ul>"},{"location":"usage/robot_usage/","title":"Robot Framework Usage Guide","text":"<p>This guide demonstrates how to use the Optics Framework with Robot Framework for test automation.</p>"},{"location":"usage/robot_usage/#installation","title":"Installation","text":"<p>Install the Optics Framework and Robot Framework:</p> <pre><code>pip install optics-framework robotframework\n</code></pre>"},{"location":"usage/robot_usage/#quick-start","title":"Quick Start","text":""},{"location":"usage/robot_usage/#basic-example","title":"Basic Example","text":"<pre><code>*** Settings ***\nLibrary    optics_framework.optics.Optics\n\n*** Test Cases ***\nExample Test\n    Setup    driver_sources=[{\"appium\": {\"enabled\": True, \"url\": \"http://localhost:4723\"}}]    elements_sources=[{\"appium_find_element\": {\"enabled\": True}}]\n    Launch App    com.example.app\n    Press Element    submit_button\n    Enter Text    username_field    testuser\n    Validate Element    welcome_message\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#library-import","title":"Library Import","text":""},{"location":"usage/robot_usage/#basic-import","title":"Basic Import","text":"<pre><code>*** Settings ***\nLibrary    optics_framework.optics.Optics\n</code></pre>"},{"location":"usage/robot_usage/#import-with-alias","title":"Import with Alias","text":"<pre><code>*** Settings ***\nLibrary    optics_framework.optics.Optics    WITH NAME    Optics\n</code></pre>"},{"location":"usage/robot_usage/#configuration","title":"Configuration","text":""},{"location":"usage/robot_usage/#configuration-from-dictionary","title":"Configuration from Dictionary","text":"<pre><code>*** Settings ***\nLibrary    optics_framework.optics.Optics\n\n*** Variables ***\n${CONFIG}    {\"driver_sources\": [{\"appium\": {\"enabled\": true, \"url\": \"http://localhost:4723\"}}], \"elements_sources\": [{\"appium_find_element\": {\"enabled\": true}}]}\n\n*** Test Cases ***\nTest With Config\n    Setup    config=${CONFIG}\n    Launch App    com.example.app\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#configuration-from-yaml-file","title":"Configuration from YAML File","text":"<pre><code>*** Settings ***\nLibrary    optics_framework.optics.Optics\n\n*** Test Cases ***\nTest With YAML Config\n    Setup From File    config.yaml\n    Launch App    com.example.app\n    Quit\n</code></pre> <p>config.yaml: <pre><code>driver_sources:\n  - appium:\n      enabled: true\n      url: \"http://localhost:4723\"\n      capabilities:\n        platformName: \"Android\"\n        deviceName: \"emulator-5554\"\n\nelements_sources:\n  - appium_find_element:\n      enabled: true\n\ntext_detection:\n  - easyocr:\n      enabled: true\n\nimage_detection:\n  - templatematch:\n      enabled: true\n\nproject_path: \"/path/to/project\"\n</code></pre></p>"},{"location":"usage/robot_usage/#configuration-with-parameters","title":"Configuration with Parameters","text":"<pre><code>*** Settings ***\nLibrary    optics_framework.optics.Optics\n\n*** Test Cases ***\nTest With Parameters\n    Setup    driver_sources=[{\"appium\": {\"enabled\": True, \"url\": \"http://localhost:4723\"}}]    elements_sources=[{\"appium_find_element\": {\"enabled\": True}}]    text_detection=[{\"easyocr\": {\"enabled\": True}}]\n    Launch App    com.example.app\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#app-management","title":"App Management","text":""},{"location":"usage/robot_usage/#launching-apps","title":"Launching Apps","text":"<pre><code>*** Test Cases ***\nLaunch App Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n    ${version}=    Get App Version\n    Log    App version: ${version}\n    ${session_id}=    Get Driver Session Id\n    Log    Session ID: ${session_id}\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#app-lifecycle","title":"App Lifecycle","text":"<pre><code>*** Test Cases ***\nApp Lifecycle Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n    Press Element    button\n    Close And Terminate App\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#element-interactions","title":"Element Interactions","text":""},{"location":"usage/robot_usage/#pressing-elements","title":"Pressing Elements","text":"<pre><code>*** Test Cases ***\nPress Element Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n\n    # Press element by ID\n    Press Element    submit_button\n\n    # Press with fallback\n    Press Element    button1    button2    //button[@id='submit']\n\n    # Press by coordinates\n    Press By Coordinates    100    200\n\n    # Press by percentage\n    Press By Percentage    50    50\n\n    # Press element with index\n    Press Element With Index    button    0\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#text-input","title":"Text Input","text":"<pre><code>*** Test Cases ***\nText Input Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n\n    # Enter text\n    Enter Text    username_field    testuser\n    Enter Text Direct    input_field    text\n    Enter Text Using Keyboard    field    text\n\n    # Enter number\n    Enter Number    number_field    123\n\n    # Clear text\n    Clear Element Text    input_field\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#gestures","title":"Gestures","text":"<pre><code>*** Test Cases ***\nGesture Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n\n    # Swipe\n    Swipe    100    200    300    400\n    # Swipe by percentage (x%, y%, direction, swipe length % \u2014 integers 0-100)\n    Swipe Percentage    50    50    up    25\n    Swipe Until Element Appears    target_element    direction=up\n    Swipe From Element    source_element    300    400\n\n    # Scroll\n    Scroll    100    200    300    400\n    Scroll Until Element Appears    target_element    direction=down\n    Scroll From Element    source_element    300    400\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#other-actions","title":"Other Actions","text":"<pre><code>*** Test Cases ***\nOther Actions Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n\n    # Press keycode\n    Press Keycode    4\n\n    # Get text\n    ${text}=    Get Text    element_id\n    Log    Element text: ${text}\n\n    # Sleep\n    Sleep    2\n\n    # Execute script\n    ${result}=    Execute Script    mobile: shell    command=echo hello\n    Log    Script result: ${result}\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#verification","title":"Verification","text":""},{"location":"usage/robot_usage/#element-validation","title":"Element Validation","text":"<pre><code>*** Test Cases ***\nValidation Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n\n    # Validate single element\n    Validate Element    welcome_message\n\n    # Assert presence\n    Assert Presence    element1    element2    rule=all\n    Assert Presence    element1    element2    rule=any\n\n    # Validate screen\n    Validate Screen    header    content    footer\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#screenshots-and-page-source","title":"Screenshots and Page Source","text":"<pre><code>*** Test Cases ***\nCapture Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n\n    # Capture screenshot\n    ${screenshot}=    Capture Screenshot\n    Log    Screenshot: ${screenshot}\n\n    # Capture page source\n    ${page_source}=    Capture Page Source\n    Log    Page source: ${page_source}\n\n    # Get interactive elements\n    ${elements}=    Get Interactive Elements\n    Log    Elements: ${elements}\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#flow-control","title":"Flow Control","text":""},{"location":"usage/robot_usage/#conditional-execution","title":"Conditional Execution","text":"<pre><code>*** Test Cases ***\nConditional Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n\n    # Condition with variable\n    Set Test Variable    ${status}    ready\n    Condition    ${status} == 'ready'    proceed_keyword\n\n    # Condition with expression\n    Set Test Variable    ${count}    15\n    Condition    ${count} &gt; 10    handle_large_count\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#data-operations","title":"Data Operations","text":"<pre><code>*** Test Cases ***\nData Operations Test\n    Setup    config=config.yaml\n\n    # Read data from CSV\n    ${data}=    Read Data    data.csv\n    Log    Data: ${data}\n\n    # Invoke API\n    ${response}=    Invoke API    GET    https://api.example.com/data\n    Log    API response: ${response}\n\n    # Read data from list\n    ${data}=    Read Data    item1    item2    item3\n    Log    Data: ${data}\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#loops","title":"Loops","text":"<pre><code>*** Test Cases ***\nLoop Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n\n    # Run loop\n    Run Loop    5    keyword_name\n\n    # Run loop with condition\n    Set Test Variable    ${status}    active\n    Run Loop    10    process_item    condition=${status} == 'active'\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#evaluation","title":"Evaluation","text":"<pre><code>*** Test Cases ***\nEvaluation Test\n    Setup    config=config.yaml\n\n    # Evaluate expression\n    Set Test Variable    ${var1}    10\n    Set Test Variable    ${var2}    20\n    ${result}=    Evaluate    ${var1} + ${var2}\n    Log    Result: ${result}\n\n    # Date evaluation\n    ${future_date}=    Date Evaluate    today + 1 day\n    ${past_date}=    Date Evaluate    today - 7 days\n    Log    Future date: ${future_date}\n    Log    Past date: ${past_date}\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#element-management","title":"Element Management","text":""},{"location":"usage/robot_usage/#adding-elements","title":"Adding Elements","text":"<pre><code>*** Test Cases ***\nElement Management Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n\n    # Add element\n    Add Element    submit_button    //button[@id='submit']\n\n    # Get element value\n    ${element_value}=    Get Element Value    submit_button\n    Log    Element value: ${element_value}\n\n    # Use element\n    Press Element    submit_button\n\n    # Use element variable\n    Press Element    ${submit_button}\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#element-variables","title":"Element Variables","text":"<pre><code>*** Test Cases ***\nElement Variables Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n\n    # Add multiple elements\n    Add Element    username    //input[@name='user']\n    Add Element    password    //input[@name='pass']\n    Add Element    submit    //button[@type='submit']\n\n    # Use in sequence\n    Enter Text    ${username}    testuser\n    Enter Text    ${password}    testpass\n    Press Element    ${submit}\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#test-organization","title":"Test Organization","text":""},{"location":"usage/robot_usage/#test-suite-structure","title":"Test Suite Structure","text":"<pre><code>*** Settings ***\nDocumentation    Example test suite using Optics Framework\nLibrary    optics_framework.optics.Optics\nResource    keywords.robot\n\n*** Variables ***\n${CONFIG_FILE}    config.yaml\n\n*** Test Cases ***\nTest Case 1\n    [Documentation]    First test case\n    Setup    config=${CONFIG_FILE}\n    Launch App    com.example.app\n    Press Element    button1\n    Validate Element    result1\n    Quit\n\nTest Case 2\n    [Documentation]    Second test case\n    Setup    config=${CONFIG_FILE}\n    Launch App    com.example.app\n    Press Element    button2\n    Validate Element    result2\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#keywords-resource-file","title":"Keywords Resource File","text":"<p>keywords.robot: <pre><code>*** Settings ***\nLibrary    optics_framework.optics.Optics\n\n*** Keywords ***\nLogin\n    [Arguments]    ${username}    ${password}\n    Enter Text    username_field    ${username}\n    Enter Text    password_field    ${password}\n    Press Element    login_button\n    Validate Element    welcome_message\n\nLogout\n    Press Element    logout_button\n    Validate Element    login_screen\n</code></pre></p>"},{"location":"usage/robot_usage/#using-resource-keywords","title":"Using Resource Keywords","text":"<pre><code>*** Settings ***\nLibrary    optics_framework.optics.Optics\nResource    keywords.robot\n\n*** Test Cases ***\nLogin Test\n    Setup    config=config.yaml\n    Launch App    com.example.app\n    Login    testuser    testpass\n    Logout\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#complete-example","title":"Complete Example","text":"<pre><code>*** Settings ***\nDocumentation    Complete example test suite\nLibrary    optics_framework.optics.Optics\n\n*** Variables ***\n${CONFIG_FILE}    config.yaml\n${APP_PACKAGE}    com.example.app\n\n*** Test Cases ***\nLogin Flow Test\n    [Documentation]    Test complete login flow\n    [Tags]    smoke    login\n\n    # Setup\n    Setup    config=${CONFIG_FILE}\n\n    # Launch app\n    Launch App    ${APP_PACKAGE}\n\n    # Add elements\n    Add Element    username    //input[@id='username']\n    Add Element    password    //input[@id='password']\n    Add Element    login_button    //button[@id='login']\n\n    # Perform login\n    Enter Text    ${username}    testuser\n    Enter Text    ${password}    testpass\n    Press Element    ${login_button}\n\n    # Verify login\n    Validate Element    welcome_message\n\n    # Capture screenshot\n    ${screenshot}=    Capture Screenshot\n    Log    Screenshot saved: ${screenshot}\n\n    # Cleanup\n    Quit\n\nElement Interaction Test\n    [Documentation]    Test various element interactions\n    [Tags]    interaction\n\n    Setup    config=${CONFIG_FILE}\n    Launch App    ${APP_PACKAGE}\n\n    # Press elements\n    Press Element    button1\n    Press By Coordinates    100    200\n    Press By Percentage    50    50\n\n    # Text input\n    Enter Text    input_field    test text\n    Enter Number    number_field    123\n\n    # Gestures\n    Swipe    100    200    300    400\n    Swipe Percentage    50    50    up    25\n    Scroll    100    200    300    400\n\n    # Verification\n    Validate Element    result_element\n    Assert Presence    element1    element2    rule=all\n\n    Quit\n</code></pre>"},{"location":"usage/robot_usage/#best-practices","title":"Best Practices","text":""},{"location":"usage/robot_usage/#1-configuration-management","title":"1. Configuration Management","text":"<ul> <li>Store configuration in YAML files</li> <li>Use variables for reusable values</li> <li>Keep configuration separate from test logic</li> </ul>"},{"location":"usage/robot_usage/#2-test-organization","title":"2. Test Organization","text":"<ul> <li>Use resource files for reusable keywords</li> <li>Organize tests into logical test suites</li> <li>Use tags for test categorization</li> </ul>"},{"location":"usage/robot_usage/#3-element-management","title":"3. Element Management","text":"<ul> <li>Store elements using Add Element</li> <li>Use descriptive element names</li> <li>Leverage element variables</li> </ul>"},{"location":"usage/robot_usage/#4-error-handling","title":"4. Error Handling","text":"<ul> <li>Use Robot Framework's built-in error handling</li> <li>Add proper documentation to test cases</li> <li>Use tags to mark flaky tests</li> </ul>"},{"location":"usage/robot_usage/#5-test-data","title":"5. Test Data","text":"<ul> <li>Use variables for test data</li> <li>Store data in external files when needed</li> <li>Use data-driven testing for multiple scenarios</li> </ul>"},{"location":"usage/robot_usage/#running-tests","title":"Running Tests","text":""},{"location":"usage/robot_usage/#basic-execution","title":"Basic Execution","text":"<pre><code>robot tests/login_test.robot\n</code></pre>"},{"location":"usage/robot_usage/#with-tags","title":"With Tags","text":"<pre><code>robot --include smoke tests/\nrobot --exclude flaky tests/\n</code></pre>"},{"location":"usage/robot_usage/#with-variables","title":"With Variables","text":"<pre><code>robot -v CONFIG_FILE:config.yaml -v APP_PACKAGE:com.example.app tests/\n</code></pre>"},{"location":"usage/robot_usage/#generate-reports","title":"Generate Reports","text":"<pre><code>robot --outputdir results tests/\n</code></pre>"},{"location":"usage/robot_usage/#related-documentation","title":"Related Documentation","text":"<ul> <li>Library Usage - Python library usage guide</li> <li>Library Layer Architecture - Detailed architecture documentation</li> <li>Keyword Usage - Complete keyword reference</li> <li>Configuration - Configuration guide</li> <li>REST API Usage - REST API endpoint reference</li> <li>API Reference - Python API documentation</li> </ul>"},{"location":"usage/usage/","title":"Usage","text":"<p>The Usage section of the Optics Framework documentation provides detailed guidance on how to interact with and leverage the framework effectively. Whether you're setting up test automation, executing test cases, or integrating keywords into your workflows, this section covers the essential tools and processes you need to get started and succeed.</p> <p>Below are the primary usage guides, each tailored to a specific aspect of the framework:</p> <ul> <li> <p>CLI Usage Learn how to use the Optics Framework's command-line interface (CLI) to set up the environment, execute test cases, initialize projects, and manage configurations.</p> </li> <li> <p>Library Usage Learn how to use the Optics Framework as a Python library for programmatic test automation, including configuration, element interactions, and session management.</p> </li> <li> <p>Robot Usage Discover how to use the Optics Framework with Robot Framework, including library import, keyword usage, and test organization patterns.</p> </li> <li> <p>Keyword Usage Explore the available keywords for defining test steps in test modules, including actions, verifications, and flow control operations, with detailed parameter explanations.</p> </li> <li> <p>REST API Usage Learn how to use the Optics Framework's REST API for programmatic interaction, including session management, keyword execution, and real-time workspace monitoring.</p> </li> </ul>"}]}